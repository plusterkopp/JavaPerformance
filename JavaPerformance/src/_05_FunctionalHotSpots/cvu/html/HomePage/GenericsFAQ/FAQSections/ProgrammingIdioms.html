<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.79 [en] (Windows NT 5.0; U) [Netscape]">
   <meta name="Author" content="Angelika Langer">
   <meta name="KeyWords" content="Java Generics parameterized type parameterized methodwildcard">
   <title>Java Generics FAQs - Programming With Java Generics</title>
</head>
<body text="#000000" bgcolor="#FFFFFF" link="#113E79" vlink="#677DAD" alink="#008080">

<h1>
<a NAME="Top"></a><a NAME="FAQProgrammingIdioms"></a><a NAME="Practicalities - Programming With Java Generics"></a>Practicalities
- Programming With Java Generics</h1>
<font size=-2>&copy; Copyright 2004-2005 by Angelika Langer.&nbsp; All
Rights Reserved.</font>
<table CELLPADDING=10 WIDTH="100%" >
<tr>
<td COLSPAN="2"><font size=+0><a href="#Using Parameterized Types and Methods">Using
Generic Types and Methods</a></font>
<ul>
<li>
<font size=+0><a href="#Should I prefer instantiations of a parameterized type over raw types?">Should
I prefer parameterized types over raw types?</a></font></li>

<li>
<a href="#Why shouldn't I mix instantiations and raw types?">Why shouldn't
I mix parameterized and raw types, if I feel like it?</a></li>

<li>
<font size=+0><a href="#Should I use the parameterized collections or better stick to the old non-generic collections?">Should
I use the generic collections or better stick to the old non-generic collections?</a></font></li>

<li>
<font size=+0><a href="#What is a checked collection?">What is a checked
collection?</a></font></li>

<li>
<font size=+0><a href="#What is the difference">What is the difference
between a Collection&lt;?> and a Collection&lt;Object>?</a></font></li>

<li>
<font size=+0><a href="#How do I express a mixed sequence of instantiations of a given parameterized type?">How
do I express that a collection is a mix of objects of different types?</a></font></li>

<li>
<a href="#How can I make sure that the same wildcard stand for the same type?">How
can I make sure that the same wildcard stand for the same type?</a></li>
</ul>
<font size=+0><a href="#Coping With Legacy">Coping With Legacy</a></font>
<ul>
<li>
<font size=+0><a href="#What happens when I mix generic and non-generic code?">What
happens when I mix generic and non-generic legacy code?</a></font></li>

<li>
<font size=+0><a href="#Should I re-engineer all my existing classes and generify them?">Should
I re-engineer all my existing classes and generify them?</a></font></li>

<li>
<font size=+0><a href="#How do I generify an existing non-generic class?">How
do I generify an existing non-generic type or method?</a></font></li>

<li>
<font size=+0><a href="#How do I avoid breaking binary compatibility when I generify an existing type or method?">How
do I avoid breaking binary compatibility when I generify an existing type
or method?</a></font></li>
</ul>
<font size=+0><a href="#Defining Parameterized Types and Methods">Defining
Generic Types and Methods</a></font>
<ul>
<li>
<font size=+0><a href="#When would I implement a parameterized class (or method) instead of a regular one?">When
would I implement a generic class (or method) instead of a regular one?</a></font></li>

<li>
<font size=+0><a href="#When would I use an unbounded wildcard instantiation instead of a bounded or concrete instantiation?">When
would I use an unbounded wildcard parameterized type instead of a bounded
or concrete parameterized type?</a></font></li>

<li>
<font size=+0><a href="#When would I use a wildcard instantiation instead of a concrete instantiation?">When
would I use a wildcard </a><a href="#When would I use an unbounded wildcard instantiation instead of a bounded or concrete instantiation?">parameterized
type</a><a href="#When would I use a wildcard instantiation instead of a concrete instantiation?">
instead of a concrete</a><a href="#When would I use an unbounded wildcard instantiation instead of a bounded or concrete instantiation?">
parameterized type</a><a href="#When would I use a wildcard instantiation instead of a concrete instantiation?">?</a></font></li>

<li>
<font size=+0><a href="#When would I use a wildcard instantiation with a lower bound?">When
would I use a wildcard</a><a href="#When would I use an unbounded wildcard instantiation instead of a bounded or concrete instantiation?">
parameterized type</a><a href="#When would I use a wildcard instantiation with a lower bound?">
with an lower bound?</a></font></li>
</ul>
<font size=+0><a href="#Designing Generic Methods">Designing Generic Methods</a></font>
<ul>
<li>
<font size=+0><a href="#Which role do wildcards play in method signatures?">Which
role do wildcards play in method signatures?</a></font></li>

<li>
<font size=+0><a href="#Is it better to parameterize a method rather than using wildcards?">Is
it better to generify a method rather than using wildcards?</a></font></li>

<li>
<font size=+0><a href="#Should I use wildcards in the return type of a method?">Should
I use wildcards in the return type of a method?</a></font></li>

<li>
<a href="#How do I implement a method that takes a wildcard argument?">How
do I implement a method that takes a wildcard argument?</a></li>

<li>
<font size=+0><a href="#How do I implement a method that takes a multi-level wildcard argument?">How
do I implement a method that takes a multi-level wildcard argument?</a></font></li>

<li>
<a href="#I want to pass a U and a X to a method.  How do I correctly declare that method?">I
want to pass a U and a X&lt;U> to a method.&nbsp; How do I correctly declare
that method?</a></li>
</ul>
<font size=+0><a href="#Working With Parameterized Interfaces">Working
With Generic Interfaces</a></font>
<ul>
<li>
<font size=+0><a href="#Can a class implement different instantiations of the same parameterized interface?">Can
a class implement different instantiations of the same generic interface?</a></font></li>

<li>
<font size=+0><a href="#Can a class implement different instantiations of the same parameterized interface?">Can
a subclass implement a parameterized interface other than any of its superclasses
does?</a></font></li>

<li>
<font size=+0><a href="#What happens if a class implements two parameterized interfaces that define the same method?">What
happens if a class implements two parameterized interfaces that define
the same method?</a></font></li>

<li>
<font size=+0><a href="#Can an interface type nested into a parameterized type use the enclosing type's type parameters?">Can
an interface type nested into a generic type use the enclosing type's type
parameters?</a></font></li>
</ul>
<font size=+0><a href="#Implementing Infrastructure Methods">Implementing
Infrastructure Methods</a></font>
<ul>
<li>
<font size=+0><a href="#How do I best implement the equals method of a parameterized type?">How
do I best implement the <tt>equals</tt> method of a generic type?</a></font></li>

<li>
<font size=+0><a href="#How do I best implement the clone method of a parameterized type">How
do I best implement the <tt>clone</tt> method of a generic type?</a></font></li>

<li>
<font size=+0>How do I best implement the <tt>compareTo</tt> method of
a generic type?</font></li>
</ul>
<a href="#Using Runtime Type Information">Using Runtime Type Information</a>
<ul>
<li>
<font size=+0><a href="#What does the type parameter of class java.lang.Class mean?">What
does the type parameter of class <tt>java.lang.Class</tt> mean?</a></font></li>

<li>
<font size=+0><a href="#How do I pass type information to a method?">How
do I pass type information to a method so that it can be used at runtime?</a></font></li>

<li>
<font size=+0><a href="#How do I generically create objects and arrays?">How
do I generically create objects and arrays?</a></font></li>

<li>
<font size=+0><a href="#How do I perform a runtime type check whose target type is a type parameter?">How
do I perform a runtime type check whose target type is a type parameter?</a></font></li>
</ul>
<font size=+0>Reflection</font>
<ul>
<li>
<font size=+0>Can I access information related to generics via reflection?</font></li>
</ul>
</td>
</tr>

<tr>
<td></td>
</tr>
</table>

<h1>
<img SRC="../../Images/bar.gif" NOSAVE height=5 width=600></h1>

<h2>
<a NAME="Programming With Generics"></a>Programming With Generics</h2>
<img SRC="../../Images/bar.gif" NOSAVE height=5 width=600>
<br>&nbsp;
<h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450></h3>

<h3>
<a NAME="Using Parameterized Types and Methods"></a>Using Generic Types
and Methods</h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450><a NAME="FAQ001"></a>
<h2>
<a NAME="Should I prefer instantiations of a parameterized type over raw types?"></a><font face="Arial,Helvetica"><font size=+0>Should
I prefer parameterized types over raw types?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Yes, using parameterized types has various
advantages and is recommended, unless you have&nbsp; a compelling reason
to prefer the raw type.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">It is permitted to use generic types without type arguments,
that is, in their raw form. In principle, you can entirely ignore Java
Generics and use raw types throughout your programs.&nbsp; It is, however,
recommended that type arguments are provided when a generic type is used,
unless there is a compelling reason not to do so.&nbsp;
<p>Providing the type arguments rather than using the raw type has a couple
of advantages:
<ul>
<li>
<b>Improved readability.</b>&nbsp; An instantiation with type arguments
is more informative and improves the readability of the source code.</li>
</ul>

<ul>
<li>
<b>Fewer ClassCastExceptions.</b>&nbsp;<i>&nbsp; </i>Type arguments enable
the compiler to perform static type checks to ensure type safety at compile
time, as opposed to dynamic type checks performed by the virtual machine
at runtime.&nbsp; As a result there are fewer opportunities for the program
to raise a <tt>ClassCastException</tt>.</li>
</ul>

<ul>
<li>
<b>Fewer casts. </b>More specific type informations is available when type
arguments are provided, so that hardly any casts are needed compared to
the substantial number of casts that clutter the source code when raw types
are used.</li>
</ul>

<ul>
<li>
<b>No unchecked warnings.&nbsp;</b><i> </i>Raw types lead to "unchecked"
warning, which can be prevented by use of type arguments.</li>
</ul>

<ul>
<li>
<b>No future deprecation. </b>The Java Language Specification states that
raw types might be deprecated in a future version of Java, and might ultimately
be withdrawn as a language feature.</li>
</ul>
Raw types have an advantage, too:
<ul>
<li>
<b>Zero learning effort.</b> If you ignore Java Generics and use raw types
everywhere in you program you need not familiarize yourself with new language
features or learn how to read any puzzling error messages.</li>
</ul>
Advantages that are no advantages:
<ul>
<li>
<b>Improved Performance</b>.&nbsp; Especially C++ programmers might expect
that generic programs are more efficient than non-generic programs, because
C++ templates can boost runtime efficiency.&nbsp; However, if you take
a look under the hood of the Java compiler and study how the compiler translates
generic source code to byte code you realize that Java code using parameterized
types does not perform any faster than non-generic programs.&nbsp;</li>
</ul>
</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ001">#FAQ001</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#How does the compiler translate Java generics?">How
does the compiler translate Java generics?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#What is an unchecked warning?">What
is an "unchecked" warning?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="Fundamentals.html#What is the benefit of using Java generics?">What
is the benefit of using Java generics?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ002"></a>
<p><a NAME="Why shouldn't I mix instantiations and raw types?"></a><b><font face="Arial,Helvetica">Why
shouldn't I mix parameterized and raw types, if I feel like it?</font></b>
<br>&nbsp;
<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Because it is poor style and highly confusing
to readers of your source code.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Despite of the benefits of parameterized types you might
still prefer use of raw types over using pre-defined generic types in their
parameterized form, perhaps because the raw types look more familiar. To
some extent it is a matter of style and taste and both styles are permitted.&nbsp;
No matter what your preferences are: be consistent and stick to it.&nbsp;
Either ignore Java generics and use raw type in all places, or take advantage
of the improved type-safety and provide type arguments in all places. Mixing
both styles is confusing and results in "unchecked" warnings that can and
should be avoided.
<p>Naturally, you have to mix both styles when you interface with source
code that was written before the advent of Java generics. In these cases
you cannot avoid the mix and the inevitable "unchecked" warnings. However,
one should never have any "unchecked" warnings in code that is written
in generic style and does not interface with non-generic APIs.
<p>Here is a typical beginner's mistake for illustration.
<p>Example (of poor programming style):
<blockquote><tt><font color="#000000">List</font><b><font color="#000099">&lt;String></font></b>
list = new ArrayList<b><font color="#000099">&lt;String></font></b>();</tt>
<br><tt><b><font color="#660000">Iterator</font></b> iter = list.iterator();&nbsp;</tt>
<br><tt>String s = <b><font color="#660000">(String)</font></b> iter.next();</tt>
<br><tt>...</tt></blockquote>
Beginners often start out correctly providing type arguments and suddenly
forget, in the heat of the fighting, that methods of parameterized types
often return other parameterized types.&nbsp; This way they end up with
a mix of generic and non-generic programming style, where there is no need
for it.&nbsp; Avoid mistakes like this and provide type arguments in <i>all</i>
places.&nbsp;
<p>Example (corrected):
<blockquote><tt><font color="#000000">List</font><b><font color="#000099">&lt;String></font></b>
list = new ArrayList<b><font color="#000099">&lt;String></font></b>();</tt>
<br><tt><font color="#000000">Iterator</font><b><font color="#000099">&lt;String></font></b>
iter = list.iterator();&nbsp;</tt>
<br><tt>String s = iter.next();</tt>
<br><tt>...</tt></blockquote>
Here is an example of a code snippet that produces avoidable "unchecked"
warnings.
<p>Example (of avoidable "unchecked" warning):
<blockquote><tt>void f(Object obj) {</tt>
<br><tt>&nbsp; <b><font color="#660000">Class</font></b> type = obj.getClass();</tt>
<br><tt>&nbsp; Annotation a = type.getAnnotation(Documented.class); <b><font color="#666600">//
unchecked warning</font></b></tt>
<br><tt><b><font color="#660000">&nbsp; </font></b>...</tt>
<br><tt>}</tt>
<br>
<hr WIDTH="100%">
<br><tt>warning: [unchecked] unchecked call to &lt;A>getAnnotation(java.lang.Class&lt;A>)
as a member of the raw type java.lang.Class</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Annotation a = type.getAnnotation(Documented.class);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt></blockquote>
The <tt>getClass</tt> method returns an instantiation of class <tt>Class</tt>,
namely <tt>Class&lt;? extends X></tt>, where <tt>X </tt>is the erasure
of the static type of the expression on which <tt>getClass</tt> is called.
In the example, the parameterization of the return type is ignored and
the raw type <tt>Class</tt> is used instead.&nbsp; As a result, certain
method calls, such as the invocation of <tt>getAnnotation</tt>, are flagged
with an "unchecked" warning.&nbsp;
<p>In general, it is recommended that type arguments are provided unless
there is a compelling reason not to do so.&nbsp; In case of doubt, often
the unbounded wildcard <font size=+0>parameterized type</font> is the best
alternative to the raw type.&nbsp; It is sematically equivalent, eliminates
"unchecked" warnings and yields to error messages if their use is unsafe.
<p>Example (corrected):
<blockquote><tt>void f(Object obj) {</tt>
<br><tt>&nbsp; Class<b><font color="#000099">&lt;?></font></b> type = obj.getClass();</tt>
<br><tt>&nbsp; Annotation a = type.getAnnotation(Documented.class);&nbsp;</tt>
<br><tt><b><font color="#660000">&nbsp; </font></b>...</tt>
<br><tt>}</tt></blockquote>
</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ002">#FAQ002</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="Fundamentals.html#What is the benefit of using Java generics?">What
is the benefit of using Java generics?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="Fundamentals.html#What does type-safety mean?">What
does type-safety mean?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#What is an unchecked warning?">What
is an "unchecked" warning?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is the raw type?">What
is the raw type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a parameterized (or generic) type?">What
is a parameterized or generic)type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#How is a parameterized type instantiated?">How
is a generic type instantiated?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is an unbounded wildcard instantiation?">What
is an unbounded wildcard parameterized type?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ003"></a>
<p><a NAME="Should I use the parameterized collections or better stick to the old non-generic collections?"></a><b><font face="Arial,Helvetica"><font size=+0>Should
I use the generic collections or stick to the old non-generic collections?</font></font></b>
<br>&nbsp;
<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Provide type arguments when you use collections;
it improves clarity and expressiveness of your source code.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">The JDK collection framework has been re-engineered. All
collections are generic types since Java 5.0.&nbsp; In principle, you can
choose whether you want to use the pre-defined generic collections in their
parameterized or raw form.&nbsp; Both is permitted, but use of the parameterized
form is recommended because it improves the readability of your source
code.
<p>Let us compare the generic and non-generic programming style and see
how they differ.
<p>Example (of non-generic style):
<p><tt>&nbsp;&nbsp;&nbsp; final class HtmlProcessor {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static <b><font color="#000099">Collection</font></b>
process(<b><font color="#000099">Collection</font></b> files) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Collection imageFileNames = new TreeSet();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for (Iterator i = files.iterator(); i.hasNext(); ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
URI uri = <b><font color="#003300">(URI)</font></b>i.next();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Collection tokens = HtmlTokenizer.tokenize(new File(uri));</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
imageFileNames.addAll(ImageCollector.collect(tokens));&nbsp; <b><font color="#666600">//
unchecked warning</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return imageFileNames;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; final class ImageCollector {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static <b><font color="#000099">Collection</font></b>
collect(<b><font color="#000099">Collection</font></b> tokens) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Set images = new TreeSet();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for (Iterator i = tokens.iterator(); i.hasNext(); ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
HtmlToken tok = <b><font color="#003300">(HtmlToken)</font></b>i.next();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (tok.getTag().3("img") &amp;&amp; tok.hasAttribute("src"))&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Attribute attr = tok.getAttribute("src");</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
images.add(attr.getValue());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<b><font color="#666600">//
unchecked warning</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return images;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<p>From the code snippet above it is relatively difficult to tell what
the various collections contain.&nbsp; This is typical for non-generic
code.&nbsp; The raw type collections do not carry information regarding
their elements.&nbsp; This lack of type information also requires that
we cast to the alledged element type each time an element is retrieved
from any of the collections.&nbsp; Each of these casts can potentially
fail at runtime with a <tt>ClassCastException</tt>.
<tt>ClassCastException</tt>s
are a phenomenon typical to non-generic code.
<p>If we translate this non-generic source code with a Java 5.0 compiler,
we&nbsp; receive "unchecked" warnings when we invoke certain operations
on the raw type collections.&nbsp; We would certainly ignore all these
warnings, or suppress them with the <tt>SuppressWarnings</tt> annotation.
<p>Example (of generic counterpart):
<p><tt>&nbsp;&nbsp;&nbsp; final class HtmlProcessor {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static <b><font color="#000099">Collection&lt;String></font></b>
process(<b><font color="#000099">Collection&lt;URI></font></b> files) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Collection&lt;String> imageFileNames = new TreeSet&lt;String>();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for (URI uri : files) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Collection&lt;HtmlToken> tokens = HtmlTokenizer.tokenize(new File(uri));</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
imageFileNames.addAll(ImageCollector.collect(tokens));</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return imageFileNames;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; final class ImageCollector {&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static <b><font color="#000099">Collection&lt;String></font></b>
collect(<b><font color="#000099">Collection&lt;HtmlToken></font></b> tokens)
{</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Set&lt;String> images = new TreeSet&lt;String>();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for (HtmlToken tok : tokens) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (tok.getTag().equals("img") &amp;&amp; tok.hasAttribute("src"))&nbsp;
{</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Attribute attr = tok.getAttribute("src");</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
images.add(attr.getValue());</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return images;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<p>From the generic source code we can easily tell what type of elements
are stored in the various collections. This is one of the benefits of generic
Java: the source code is substantially more expressive and captures more
of the programmer's intent. In addition it enables the compiler to perform
lots of type checks at compile time that would otherwise be performed at
runtime.&nbsp; Note that we got rid of all casts. As a consequence there
will be no runtime failure due to a <tt>ClassCastException</tt>.&nbsp;
<p>This is a general rule in Java 5.0:&nbsp; if your source code compiled
without any warnings then there will be no unexpected <tt>ClassCastException</tt>s
at runtime. Of course, if your code contains explicit cast expressions
any exceptions resulting from these casts are not considered unexpected.&nbsp;
But the number of casts in your source code will drop substantially with
the use of generics.&nbsp;
<br>&nbsp;</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ003">#FAQ003</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/package-summary.html">package
java.util</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Should I prefer instantiations of a parameterized type over raw types?">Should
I prefer parameterized types over raw types?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="Fundamentals.html#What is the benefit of using Java generics?">What
is the benefit of using Java generics?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#What is an unchecked warning?">What
is an "unchecked" warning?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#How can I disable or enable unchecked warnings?">How
can I disable or enable unchecked warnings?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#What is the SuppressWarnings annotation?">What
is the SuppressWarnings annotation?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is the raw type?">What
is the raw type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a parameterized (or generic) type?">What
is a parameterized or generic type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#How is a parameterized type instantiated?">How
is a generic type instantiated?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ004"></a>
<p><a NAME="What is a checked collection?"></a><b><font face="Arial,Helvetica"><font size=+0>What
is a checked collection?</font></font></b>
<br>&nbsp;
<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>A view to a regular collection that performs
a runtime type check each time an element is inserted.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Despite of all the type checks that the compiler performs
based on type arguments in order to ensure type safety it is still possible
to smuggle elements of the wrong type into a generic collection.&nbsp;
This can happen easily when generic and non-generic code is mixed.
<p>Example (of smuggling an alien into a collection):
<blockquote><tt>class Legacy {</tt>
<br><tt>&nbsp; public static List create() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; List rawList = new ArrayList();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; rawList.add("abc");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b><font color="#993300">// unchecked warning</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return rawList;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; public static void insert(List rawList) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; rawList.add(new <b><font color="#003300">Date</font></b>());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b><font color="#993300">// unchecked warning</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br><tt>class Modern {</tt>
<br><tt>&nbsp; private void someMethod() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; List&lt;<b><font color="#003300">String</font></b>>
stringList = Legacy.create();&nbsp; <b><font color="#993300">// unchecked
warning</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; Legacy.insert(stringList);&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Unrelated.useStringList(stringList);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br><tt>class Unrelated {</tt>
<br><tt>&nbsp; public static void useStringList(List&lt;String> stringList)
{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp;&nbsp;&nbsp; String s = stringList.get(1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b><font color="#660000">// ClassCastException</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
An "alien" <tt>Date</tt> object is successfully inserted into a list of
strings.&nbsp; This can happen inadvertantly when a parameterized type
is passed to a piece of legacy code that accepts the corresponding raw
type and then adds alien elements.&nbsp; The compiler can neither detect
nor prevent this kind of violation of the type safety, beyond issuing an
"unchecked" warning when certain methods of the raw type are invoked. The
inevitable type mismatch will later show up in a potentially unrelated
part of the program and will mainfest itself as an unexpected
<tt>ClassCastException</tt>.
<p>For purposes of diagnostics and debugging JDK 5.0 adds a set of “checked”
views to the collection framework (see <tt><a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Collections.html">java.util.Collections</a></tt>),
which can detect the kind of problem explained above.&nbsp; If a checked
view is used instead of the original collection then the error is reported
at the correct location, namely when the "alien" element is inserted.
<p>Example (of using a checked collection):
<blockquote><tt>class Legacy {</tt>
<br><tt>&nbsp; public static List create() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; List rawList = new ArrayList();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; rawList.add("abc");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<font color="#000000">// unchecked warning</font></tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return rawList;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; public static void insert(List rawList) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; rawList.add(new Date());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<b><font color="#660000">// ClassCastException</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br><tt>class Modern {</tt>
<br><tt>&nbsp; private void someMethod() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; List&lt;String> stringList&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = <b><font color="#000099">Collections.checkedList(L</font></b>egacy.create()<b><font color="#000099">,String.class)</font></b>;
<font color="#000000">//
unchecked warning</font></tt>
<br><tt>&nbsp;&nbsp;&nbsp; Legacy.insert(stringList);&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Unrelated.useStringList(stringList);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br><tt>class Unrelated</tt>
<br><tt>&nbsp; public static void useStringList(List&lt;String> stringList)
{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp;&nbsp;&nbsp; String s = stringList.get(1);&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
The checked collection is a view to an underlying collection, similar to
the unmodifiable and synchronized views provided by class <tt>Collections</tt>.
The purpose of the checked view is to detect insertion of "aliens" and
prevent it by throwing a <tt>ClassCastException</tt> in case the element
to be inserted is of an unexptected type.&nbsp; The expected type of the
elements is provided by means of a <tt>Class</tt> object when the checked
view is created. Each time an element is added to the checked collection
a runtime type check is performed to make sure that element is of an acceptable
type.&nbsp; Here is a snippet of the implementation of&nbsp; the checked
view for illustration.
<p>Example (excerpt from a checked view implementation):
<blockquote><tt>public class Collections {&nbsp;</tt>
<br><tt>&nbsp; public static &lt;E> Collection&lt;E> checkedCollection(Collection&lt;E>
c, <b><font color="#000099">Class&lt;E> type</font></b>) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return new CheckedCollection&lt;E>(c, type);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; private static class CheckedCollection&lt;E> implements
Collection&lt;E> {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; final Collection&lt;E> c;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; final Class&lt;E> type;</tt>
<p><tt>&nbsp;&nbsp;&nbsp; CheckedCollection(Collection&lt;E> c, Class&lt;E>
type) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.c = c;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.type = type;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public boolean add(E o){</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!<b><font color="#000099">type.isInstance</font></b>(o))</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new ClassCastException();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return c.add(o);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
The advantage of using a checked view is that the error is reported at
the correct location. The downside of using a checked collection is the
performance overhead of an additional dynamic type check each time an element
is inserted into the collection.
<p>
<hr WIDTH="100%">
<p>The error detection capabilities of the checked view are somewhat limited.&nbsp;
The type check that is performed when an element is inserted into a checked
collection is performed at runtime - using the runtime type representation
of the expected element type.&nbsp; If the element type is a parameterized
type the check cannot be exact, because only the raw type is available
at runtime.&nbsp; As a result, aliens can be inserted into a checked collection,
although the checked collection was invented to prevent exactly that.&nbsp;
<p>Example (of limitations of checked collections):
<blockquote><tt>class Legacy {</tt>
<br><tt>&nbsp; public static List legacyCreate() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; List rawList = new ArrayList();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; rawList.add(new Pair("abc","xyz"));&nbsp;&nbsp;&nbsp;&nbsp;

<font color="#000000">// unchecked warning</font></tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return rawList;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; public static void legacyInsert(List rawList) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; rawList.add(new <b><font color="#003300">Pair(new
Date(),"Xmas")</font></b>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#000000">//
unchecked warning</font></tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br><tt>class Modern {</tt>
<br><tt>&nbsp; private void someModernMethod() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; List&lt;<b><font color="#003300">Pair&lt;String,String></font></b>>
stringPairs&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = <b><font color="#000099">Collections.checkedList(</font></b>legacyCreate()<b><font color="#000099">,Pair.class)</font></b>;
<font color="#000000">//
unchecked warning</font></tt>
<br><tt>&nbsp;&nbsp;&nbsp; Legacy.insert(stringPairs);&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Unrelated.useStringPairs(stringPairs);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br><tt>class Unrelated {</tt>
<br><tt>&nbsp; public static void useStringPairs(List&lt;Pair&lt;String,String>>
stringPairList) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp;&nbsp;&nbsp; String s = stringPairList.get(1).getFirst();
<b><font color="#660000">//
ClassCastException</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
The checked view can only check against the raw type <tt>Pair</tt> and
cannot prevent that an alien pair of type <tt>Pair&lt;Date,String></tt>
is inserted into the checked view to a collection of <tt>Pair&lt;String,String></tt>.&nbsp;
Remember, parameterized types do not have an exact runtime type representation
and there is not class literal for a parameterized type that we could provide
for creation of the checked view.&nbsp;
<p>Note, that a checked view to a collection of type <tt>Pair&lt;String,String></tt>
cannot be created without a warning.
<p>Example:
<blockquote><tt>Lis<font color="#000000">t&lt;Pair&lt;String,String>> stringPairs&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = Collections.checkedList</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(new</font><font color="#000099"> </font><font color="#000000">ArrayList&lt;<b>Pair&lt;String,String></b>></font>()<font color="#000000">,<b>Pair</b>.class);
</font><b><font color="#660000">//
error</font></b></tt>
<p><tt>Lis<font color="#000000">t&lt;Pair&lt;String,String>> stringPairs&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = Collections.checkedList</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(</font><b><font color="#000099">(List&lt;Pair>)</font></b><font color="#000000">(new
ArrayList&lt;<b>Pair&lt;String,String></b>></font>())<font color="#000000">,<b>Pair</b>.class);
</font><b><font color="#660000">//
error</font></b></tt>
<p><tt>Lis<font color="#000000">t&lt;Pair&lt;String,String>> stringPairs&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = Collections.checkedList</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(</font><b><font color="#000099">(List)</font></b><font color="#000000">(new
ArrayList&lt;<b>Pair&lt;String,String></b>></font>())<font color="#000000">,<b>Pair</b>.class);
</font><b><font color="#993300">//
unchecked warning</font></b></tt></blockquote>
We cannot create a checked view to a parameterized type such as <tt>List&lt;Pair&lt;String,String>></tt>,
because it is required that we supply the runtime type representation of
the collection's element type as the second argument to the factory method
<tt><font color="#000000">Collections.checkedList</font></tt>.&nbsp;
The element type <tt>Pair&lt;String,String> </tt>does not have a runtime
type representation of its own; there is no such thing as <tt>Pair&lt;String,String>.class</tt>.&nbsp;
At best, we can specify the raw type <tt>Pair </tt>as the runtime type
representation of the collection's element type.&nbsp; But this is the
element type of a collection of type <tt>List&lt;Pair></tt>, not of a <tt>List&lt;Pair&lt;String,String>></tt>.
<p>This explains why we have to add a cast.&nbsp; The natural cast would
be to type <tt>List&lt;Pair></tt>, but the conversion from <tt><font color="#000000">ArrayList&lt;Pair&lt;String,String>>
</font></tt>to
<tt>List&lt;Pair></tt>
is not permitted. These two types a inconvertible because they are instantiations
of the same generic type for different type arguments.&nbsp;
<p>As a workaround we resort to the raw type <tt>List</tt>, because the
conversion <tt><font color="#000000">ArrayList&lt;Pair&lt;String,String>>
</font></tt>to
<tt>List</tt>
is permitted for reasons of compatibility.&nbsp; Use of the raw type results
in the usual "unchecked" warnings.&nbsp; In this case the compiler complains
that we pass a raw type <tt>List</tt> as the first arguments to the <tt><font color="#000000">Collections.checkedList
</font></tt>method,
where actually a <tt>List&lt;Pair> </tt>is exptected.
<p>In general, we cannot create a checked view&nbsp; to an instantiation
of a collection whose type argument is a parameterized type (such as <tt>List&lt;Pair&lt;String,String>></tt>).
This is only possible using debatable casts, as demonstrated above.&nbsp;
However, it is likely that checked collections are used in cases where
generic and non-generic legacy code is mixed, because that is the situation
in which alien elements can be inserted into a collection inadvertantly.&nbsp;
In a mixed style context, you might not even notice that you work around
some of the compiler's type checks, when you create a checked view, because
you have to cope with countless "unchecked" warnings anyway.&nbsp;
<p>The point to take home is that checked views provide a certain safety
net for collections whose element type is a raw type, but fails to provide
the same kind of safety for collections whose element type is a parameterized
type.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ004">#FAQ004</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Collections.html">class
java.util.Collections</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#What is an unchecked warning?">What
is an "unchecked" warning?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is the raw type?">What
is the raw type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#What happens when I mix generic and non-generic code?">What
happens when I mix generic and non-generic code?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#How do I pass type information to a method?">How
do I pass type information to a method so that it can be used at runtime?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#How do I perform a runtime type check whose target type is a type parameter?">How
do I perform a runtime type check whose target type is a type parameter?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#Why is there no class literal for the concrete instantiation of a parameterized type?">Why
is there no class literal for concrete parameterized types?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#How does the compiler translate Java generics?">How
does the compiler translate Java generics?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#What is type erasure?">What
is type erasure?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#What is the type erasure of a parameterized type?">What
is the type erasure of a parameterized type?&nbsp;</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ005"></a>
<h2>
<a NAME="What is the difference"></a><font face="Arial,Helvetica"><font size=+0>What
is the difference between a Collection&lt;?> and a Collection&lt;Object>?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i><tt>Collection&lt;Object></tt> is a heterogenous
collection, while <tt>Collection&lt;?></tt> is a homogenous collection
of elements of the same unknown type.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">The type <tt>Collection&lt;Object></tt> is a <i>heterogenous</i>
collection of objects of different types.&nbsp; It's a mixed bag and can
contain elements of all reference types.
<p>The type <tt>Collection&lt;?> </tt>stands for a representative from
the family of types that are instantiations of the generic interface <tt>Collection</tt>,
where the type argument is an arbitrary reference type.&nbsp; For instance,
it refers to a <tt>Collection&lt;Date></tt>, or a <tt>Collection&lt;String></tt>,
or a <tt>Collection&lt;Number></tt>, or even a <tt>Collection&lt;Object></tt>.&nbsp;
<p>A <tt>Collection&lt;?> </tt>is a <i>homogenous</i> collection in the
sense that it can only contain elements that have a common unknown supertype,
and that unknown supertype might be more restrictive than <tt>Object</tt>.&nbsp;
If the unknown supertype is a <tt>final</tt> class then the collection
is truly homogenous.&nbsp; Otherwise, the collection is not really homogenous
because it can contain objects of different types, but all these types
are subtypes of the unknown supertype. For instance, the <tt>Collection&lt;?>
</tt>might
stand for <tt>Collection&lt;Number></tt>, which is homogenous in the sense
that it contains numbers and not apples or pears, yet it can contain a
mix of elements of type <tt>Short</tt>, <tt>Integer</tt>, <tt>Long</tt>,
etc.
<br>&nbsp;
<p>A similar distinction applies to bounded wildcards, not just the unbounded
wildcard "<tt>?</tt>".&nbsp;
<p>A <tt>List&lt;Iterable></tt> is a concrete parameterized type.&nbsp;
It is a mixed list of objects whose type is a subtype of <tt>Iterable</tt>.&nbsp;
I can contain an <tt>ArrayList</tt> and a <tt>TreeSet</tt> and a <tt>SynchronousQueue</tt>,
and so on.
<p>A <tt>List&lt;? extends Iterable></tt> is a wildcard parameterized type
and stands for a representative from the family of types that are instantiations
of the generic interface <tt>List</tt>, where the type argument is a subtype
of <tt>Iterable</tt>, or <tt>Iterable</tt> itself.&nbsp; Again, the list
is truly homogenous if the unknown subtype of <tt>Iterable</tt> is a <tt>final</tt>
class.&nbsp; Otherwise, it is a mix of objects with a common unknown supertype
and that supertype itself is a subtype of <tt>Iterable</tt>.&nbsp; For
example,
<tt>List&lt;? extends Iterable> </tt>might stand for <tt>List&lt;Set></tt>,
which is homogenous in the sense that it contains sets and not lists or
queues. Yet the <tt>List&lt;Set></tt> can be heterogenous because it might
contain a mix of <tt>TreeSet</tt>s and <tt>HashSet</tt>s.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ005">#FAQ005</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a concrete instantiation?">What
is a concrete parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a wildcard instantiation?">What
is a wildcard parameterized type?</a></font></font></td>
</tr>
</table>

<h3>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ006"></a></h3>

<h2>
<a NAME="How do I express a mixed sequence of instantiations of a given parameterized type?"></a><font face="Arial,Helvetica"><font size=+0>How
do I express that a collection is a mix of objects of different types?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Using wildcard instantiations of the
generic collections.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Occasionally, we want to refer to sequences of objects
of different types.&nbsp; An example would be a <tt>List&lt;Object></tt>
or a <tt>Object[]</tt>.&nbsp; Both denote sequences of objects of arbitrary
types, because <tt>Object</tt> is the supertype of all reference types.
<p>How do we express a sequence of objects not of arbitrary different types,
but of different instantiations of a certain generic type? Say, we need
to refer to a sequence of pairs of arbitrary elements.&nbsp; We would need
the supertype of all instantiations of the generic <tt>Pair</tt> type.
This supertype is the unbounded wildcard instantiation <tt>Pair&lt;?,?></tt>.&nbsp;
Hence a <tt>List&lt;Pair&lt;?,?>></tt> and a <tt>Pair&lt;?,?>[]</tt> would
denote sequences of pairs of different types.
<br>&nbsp;
<table BORDER CELLSPACING=0 CELLPADDING=5 >
<tr BGCOLOR="#CCCCCC">
<td></td>

<td><b>of any type&nbsp;</b></td>

<td><b>of any pair type</b></td>
</tr>

<tr>
<td BGCOLOR="#CCCCCC"><b>collection</b></td>

<td><tt>List&lt;Object></tt></td>

<td><tt>List&lt;Pair&lt;?,?>></tt></td>
</tr>

<tr>
<td BGCOLOR="#CCCCCC"><b>array</b></td>

<td><tt>Object[]</tt></td>

<td><tt>Pair&lt;?,?>[]</tt></td>
</tr>
</table>

<p>When we want to refer to a mixed sequence of certain types, instead
of all arbitrary types, we use the supertype of those "certain types" to
express the mixed sequence.&nbsp; Examples are <tt>List&lt;Number></tt>
or <tt>Number[]</tt>.&nbsp;&nbsp; The corresponding mixed sequences of
instantiations of a generic type is expressed in a similar way.&nbsp; A
mixed sequences of pairs of numbers can be expressed as <tt>List&lt;Pair&lt;?
extends Number, ? extends Number>></tt> or as <tt>Pair&lt;? extends Number,
? extends Number>[]</tt>.
<br>&nbsp;
<table BORDER=0 >
<tr>
<td>
<table BORDER CELLSPACING=0 CELLPADDING=5 >
<tr BGCOLOR="#CCCCCC">
<td></td>

<td><b>of any number type&nbsp;</b></td>

<td><b>of any type of pair of numbers</b></td>
</tr>

<tr>
<td BGCOLOR="#CCCCCC"><b>collection</b></td>

<td><tt>List&lt;Number></tt></td>

<td><tt>List&lt;Pair&lt;? extends Number,? extends Number>></tt></td>
</tr>

<tr>
<td BGCOLOR="#CCCCCC"><b>array</b></td>

<td><tt>Number[]</tt></td>

<td><tt>Pair&lt;? extends Number,? extends Number>[] <b><sup><font color="#330000"><font size=+1>*)</font></font></sup></b></tt></td>
</tr>
</table>
</td>

<td VALIGN=BOTTOM><sup><b><tt><font color="#330000"><font size=+1>*) </font></font></tt></b><font color="#000000">Legal
as the type of reference variable, but illegal in a new expression.</font></sup></td>
</tr>
</table>

<p>The array type <tt>Pair&lt;? extends Number, ? extends Number>[]</tt>needs
further explanation.&nbsp; This type would in principle denote a mixed
sequence of pairs of different type, but this array type is not overly
useful.&nbsp; It can only be used for declaration of reference variables,
while it must not appear in <tt>new</tt> expressions.&nbsp; That is, we
can declare reference variables of type <tt>Pair&lt;? extends Number, ?
extends Number>[]</tt>, but the reference can never refer to an array of
its type, because no such array can be created.&nbsp;
<p>Example (of illegal array creation):
<blockquote><tt>Pair&lt;? extends Number, ? extends Number>[] makeNumberPairs(int
size) {</tt>
<br><tt>&nbsp; return <b><font color="#000000">new Pair&lt;? extends Number,
? extends Number>[size];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

</font><font color="#660000">// error</font></b></tt>
<br><tt>}</tt>
<br>
<hr WIDTH="100%">
<br><tt>error: generic array creation</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return new Pair&lt;? extends Number, ? extends Number>[size];</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt></blockquote>
By and large an array type such as <tt>Pair&lt;? extends Number, ? extends
Number>[]</tt> is not particularly useful, because it cannot refer to an
array of its type.&nbsp; It can refer to an array of the corresponding
raw type, i.e. <tt>Pair[]</tt>, or to an array of a non-generic subtype,
e.g.<tt>Point[]</tt>, where <tt>Point</tt> is a subclass of <tt>Pair&lt;Double,Double></tt>
for instance.&nbsp; In each of these cases using a reference variable of
type <tt>Pair&lt;? extends Number, ? extends Number>[]</tt> offers no advantage
over using a reference variable that matches the type of the array being
refered to.&nbsp; Quite the converse; it is error prone and should be avoided.
This rules applies to all array types with a component type that is a concrete
or bounded wildcard parameterized type. For details see <font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#FAQ104A">#FAQ104A</a></font></font>
and <font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#FAQ307A">#FAQ307A</a></font></font>.&nbsp;
<p>Note that arrays of <u>un</u>bounded wildcard parameterized types do
not suffer from this restriction.&nbsp; The creation of an array of an
unbounded wildcard parameterized type is permitted, because the unbounded
wildcard parameterized type is a so-called reifiable type, so that an array
reference variable with an unbounded wildcard parameterized type as its
component type, such as <tt>Pair&lt;?,?>[]</tt>, can refer to an array
of its type.
<p>Example (of legal array creation):
<blockquote><tt>Pair&lt;?,?>[] makeNumberPairs(int size) {</tt>
<br><tt>&nbsp; return <b><font color="#000000">new Pair&lt;?,?>[size];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

</font><font color="#003300">// fine</font></b></tt>
<br><tt>}</tt></blockquote>
</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ006">#FAQ006</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#Can I create an object whose type is a wildcard instantiation of a parameterized type?">Can
I create an object whose type is a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#Can I create an array whose component type is a wildcard instantiation of a parameterized type?">Can
I create an array whose component type is a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#Why is it allowed to create an array whose component type is an unbounded wildcard instantiation?">Why
is it allowed to create an array whose component type is an unbounded wildcard
parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#Can I declare a reference variable of an array type whose component type is a concrete instantiation">Can
I declare a reference variable of an array type whose component type is
a concrete parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#Can I declare a reference variable of an array type whose component type is a bounded wildcard instantiation of a">Can
I declare a reference variable of an array type whose component type is
a bounded wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#Can I declare a reference variable of an array type whose component type is an unbounded wildcard instantiation of a">Can
I declare a reference variable of an array type whose component type is
an unbounded wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#What is a reifiable type?">What
is a reifiable type?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ007"></a>
<h2>
<a NAME="How can I make sure that the same wildcard stand for the same type?"></a><font face="Arial,Helvetica"><font size=+0>How
can I make sure that a wildcard that occurs repeatedly in the same scope
stands for the same type?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>In general you can't.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">If the same wildcard appears repeatedly, each occurrence
of the wildcard stands for a potentially different type. There is no way
to make sure that the same wildcard represents the same type.&nbsp;
<p>Example (using the same wildcard repeatedly):
<blockquote><tt>Pair&lt;<b>?</b>,<b>?</b>> couple = new Pair&lt;<b>String</b>,<b>String</b>>("Orpheus","Eurydike");</tt>
<br><tt>Pair&lt;<b>?</b>,<b><font color="#000066">?</font></b>> xmas&nbsp;&nbsp;
= new Pair&lt;<b>String</b>,<b><font color="#000066">Date</font></b>>("Xmas",
new Date(104,11,24));</tt></blockquote>
There is nothing you can do to make sure that a reference variable of type
<tt>Pair&lt;?,?></tt>
represents a pair of elements of the same type.&nbsp;
<p>Depending on the circumstances there might be work-arounds that achieve
this goal. For instance, if the type <tt>Pair&lt;?,?></tt>&nbsp; is the
type of a method argument, it might be possible to generify the method
to ensure that the method argument is a pair of elements of the same type.
<p>For instance, the following method
<blockquote><tt>void someMethod(Pair&lt;<b>?</b>,<b>?</b>> pair) { ...
}</tt></blockquote>
accepts all types of pairs.&nbsp; It is mostly equivalent to the following
generic method:
<blockquote><tt>&lt;<b>X</b>,<b>Y</b>> void someMethod(Pair&lt;<b>X</b>,<b>Y</b>>
pair) { ... }</tt></blockquote>
In order to make sure that only pairs of elements of the same type are
passed to the method, the method can be generified as follows:
<blockquote><tt>&lt;<b><font color="#000066">T</font></b>> void someMethod(Pair&lt;<b><font color="#000066">T</font></b>,<b><font color="#000066">T</font></b>>
pair) { ... }</tt></blockquote>
Now it is guaranteed that the method accepts only pairs of elements of
the same type.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ007">#FAQ007</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a wildcard instantiation?">What
is a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#If a wildcard appears repeatedly in a type argument section, does it stand for the same type">If
a wildcard appears repeatedly in a type argument section, does it stand
for the same type?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350>
<br>&nbsp;
<h3>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350></h3>

<h3>
<a NAME="Coping With Legacy"></a>Coping With Legacy</h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450><a NAME="FAQ101"></a>
<p><a NAME="What happens when I mix generic and non-generic code?"></a><b><font face="Arial,Helvetica"><font size=+0>What
happens when I mix generic and non-generic legacy code?</font></font></b>
<br>&nbsp;
<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>The compiler issues lots of "unchecked"
warnings.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">It is permitted that a generic class or method is used
in both its parameterized and its raw form.&nbsp; Both forms can be mixed
freely.&nbsp; However, all uses that potentially violate the type-safety
are reported by means of an "unchecked warning".&nbsp; In practice, you
will see a lot of unchecked warnings when you use generic types and methods
in their raw form.
<p>Example (of mixing paramterized and raw use of a generic type):
<blockquote><tt>interface <b>Comparable&lt;T></b> {</tt>
<br><tt>&nbsp; int compareTo(T other);</tt>
<br><tt>}</tt>
<br><tt>class SomeClass implements <b><font color="#000000">Comparable</font></b>
{</tt>
<br><tt>&nbsp; public int compareTo(Object other) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br><tt>class Test {</tt>
<br><tt>&nbsp; public static void main(String[] args) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; <b><font color="#000000">Comparable</font></b>
x = new SomeClass();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; x.compareTo(x);&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#993300">//
"unchecked" warning</font></b></tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br>
<hr WIDTH="100%">
<br><tt>warning: [unchecked] unchecked call to compareTo(T) as a member
of the raw type java.lang.Comparable</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x.compareTo(x);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt></blockquote>
The <tt>Comparable</tt> interface is a generic type.&nbsp; Its raw use
in the example above leads to "unchecked" warnings each time the <tt>compareTo</tt>
method is invoked.
<p>The warning is issued because the method invocation is considered a
potential violation of the type-safety guarantee.&nbsp; This particular
invocation of <tt>compareTo</tt> is not unsafe, but other methods invoked
on raw types might be.
<p>Example (of type-safety problem when mixing parameterized and raw use):
<blockquote><tt>class Test {</tt>
<br><tt>&nbsp; public static void someMethod(<b><font color="#000000">List</font></b>
list) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; list.add("xyz");&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#993300">//
"unchecked" warning</font></b></tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; public static void test() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; <b><font color="#000000">List&lt;Long></font></b>
list = new <b><font color="#000000">ArrayList&lt;Long></font></b>();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; someMethod(list);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br>
<hr WIDTH="100%">
<br><tt>warning: [unchecked] unchecked call to add(E) as a member of the
raw type java.util.List</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; list.add("xyz");</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt></blockquote>
Similar to the previous example, the invocation of the <tt>add</tt> method
on the raw type <tt>List</tt> is flagged with an "unchecked" warning.&nbsp;
The invocation is indeed unsafe, because it inserts a string into a list
of long values.
<p>The compiler cannot distinguish between invocations that are safe and
those that are not.&nbsp; It reports "unchecked" warnings just in case
that a call might be unsafe.&nbsp; It applies a simple rule: every invocation
of a method of a raw type that takes an argument of the unknown type that
the class's type parameter stands for, is potentially unsafe.&nbsp; That
does not mean, it must be unsafe (see <tt>Comparable.compareTo</tt>), but
it can be unsafe (see <tt>List.add</tt>).
<p>If you find that you must intermix legacy and generic code, pay close
attention to the unchecked warnings. Think carefully how you can justify
the safety of the code that gives rise to the warning. Once you've made
sure the warning is harmless suppress it using the <tt>SuppressWarnings</tt>
annotation.
<p>If you can re-engineer existing code or if you write new code from scratch
you should use generic types and methods in their parmeterized form and
avoid any raw use.&nbsp; For instance, the examples above can be "repaired"
as follows:
<p>Example #1 (corrected):
<blockquote><tt>interface <b>Comparable&lt;T></b> {</tt>
<br><tt>&nbsp; int compareTo(T other);</tt>
<br><tt>}</tt>
<br><tt>class SomeClass implements <b><font color="#000000">Comparable</font><font color="#000066">&lt;Object></font></b>
{</tt>
<br><tt>&nbsp; public int compareTo(Object other) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br><tt>class Test {</tt>
<br><tt>&nbsp; public static void main(String[] args) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; <b><font color="#000000">Comparable</font><font color="#000066">&lt;Object></font></b>
x = new SomeClass();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; x.compareTo(x);&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#003300">//
fine</font></b></tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
No "unchecked" warning occurs if the <tt>Comparable</tt> interface is used
in its parameterized form in all places.
<p>Example #2 (corrected):
<blockquote><tt>class Test {</tt>
<br><tt>&nbsp; public static void someMethod(<b><font color="#000000">List</font><font color="#000099">&lt;String></font></b>
list) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; list.add("xyz");&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#003300">//
fine</font></b></tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; public static void test() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; <b><font color="#000000">List&lt;Long></font></b>
list = new <b><font color="#000000">ArrayList&lt;Long></font></b>();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; someMethod(list);&nbsp;&nbsp; <b><font color="#330000">//
error</font></b></tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br>
<hr WIDTH="100%">
<br><tt>error: someMethod(java.util.List&lt;java.lang.String>) cannot be
applied to java.util.List&lt;java.lang.Long>)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; someMethod(list);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^</tt></blockquote>
The "unchecked" warning in <tt>someMethod</tt> is no longer necessary if
the generic type <tt>List</tt> is used in its parameterized form as <tt>List&lt;String></tt>.&nbsp;
With this additional type information the compiler is now capable of flagging
the formerly undetected type-safety problem in method <tt>test</tt> as
an error.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ101">#FAQ101</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="Fundamentals.html#What does type-safety mean?">What
does type-safety mean?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is the raw type?">What
is the raw type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#Can I use a raw type like any other type?">Can
I use a raw type like any other type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#What is an unchecked warning?">What
is an "unchecked" warning?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#How can I disable or enable unchecked warnings?">How
can I disable or enable unchecked warnings?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#What is the SuppressWarnings annotation?">What
is the SuppressWarnings annotation?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ102"></a>
<h2>
<a NAME="Should I re-engineer all my existing classes and generify them?"></a><font face="Arial,Helvetica"><font size=+0>Should
I re-engineer all my existing types and generify them?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>No, most likely not.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Not all types are inherently generic.&nbsp; There is no
point to turning a type into a generic type if the type does not semantically
depend on a particular unknown type that can be more adequately be expressed
by means of a type parameter.&nbsp;
<p>Example (of an arbitrary non-generic type taken from package <tt>org.w3c.dom</tt>):
<blockquote><tt>public interface NameList {</tt>
<br><tt>&nbsp; boolean&nbsp; contains(String str);</tt>
<br><tt>&nbsp; boolean&nbsp; containsNS(String namespaceURI, String name);</tt>
<br><tt>&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getLength();</tt>
<br><tt>&nbsp; String&nbsp;&nbsp; getName(int index);</tt>
<br><tt>&nbsp; String&nbsp;&nbsp; getNamespaceURI(int index);</tt>
<br><tt>}</tt></blockquote>
The <tt>NameList</tt> interface takes and returns either strings or primitive
types and there is no reason why this class should be generic in any form.
<p>
<hr WIDTH="100%">
<p>Other non-generic types would benefit from generics.
<p>Example (of another arbitrary non-generic type):
<blockquote><tt>public interface Future {</tt>
<br><tt>&nbsp; boolean&nbsp; cancel(boolean mayInterruptIfRunning);</tt>
<br><tt>&nbsp; <b><font color="#000099">Object</font></b>&nbsp;&nbsp; get();</tt>
<br><tt>&nbsp; <b><font color="#000099">Object</font></b>&nbsp;&nbsp; get(long
timeout, TimeUnit unit);</tt>
<br><tt>&nbsp; boolean&nbsp; isCancelled();</tt>
<br><tt>&nbsp; boolean&nbsp; isDone();</tt>
<br><tt>}</tt></blockquote>
This interface has get methods that return <tt>Object</tt> references.&nbsp;
If these methods return the same type of object for a given instance of
type <tt>Future</tt>, then the interface is more precisely declared as
a generic interface.
<p>Example (of corresponding generic type):
<blockquote><tt>public interface Future<b><font color="#000099">&lt;V></font></b>
{</tt>
<br><tt>&nbsp; boolean&nbsp; cancel(boolean mayInterruptIfRunning);</tt>
<br><tt>&nbsp; <b><font color="#000099">V</font></b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
get();</tt>
<br><tt>&nbsp; <b><font color="#000099">V</font></b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
get(long timeout, TimeUnit unit);</tt>
<br><tt>&nbsp; boolean&nbsp; isCancelled();</tt>
<br><tt>&nbsp; boolean&nbsp; isDone();</tt>
<br><tt>}</tt></blockquote>

<hr WIDTH="100%">
<p>Occasionally, the generification of one type leads to the generification
of other related types.
<p>Example (of non-generic types taken from package <tt>java.lang.ref</tt>
in JDK 1.4):
<blockquote><tt>public class ReferenceQueue {</tt>
<br><tt>&nbsp; public ReferenceQueue() { }</tt>
<br><tt>&nbsp; public <b><font color="#000000">Reference</font></b> poll()
{ ... }</tt>
<br><tt>&nbsp; public <b><font color="#000000">Reference</font></b> remove(long
timeout)&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; throws IllegalArgumentException, InterruptedException
{ ... }</tt>
<br><tt>&nbsp; public <b><font color="#000000">Reference</font></b> remove()&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; throws InterruptedException { ... }&nbsp;</tt>
<br><tt>}</tt>
<br><tt>public abstract class Reference {</tt>
<br><tt>&nbsp; private <b><font color="#000099">Object</font></b> referent;&nbsp;</tt>
<br><tt>&nbsp; <b>ReferenceQueue</b> queue;</tt>
<br><tt>&nbsp; Reference next;</tt>
<br><tt>&nbsp; Reference(<b><font color="#000099">Object</font></b> referent)
{ ... }</tt>
<br><tt>&nbsp; Reference(<b><font color="#000099">Object</font></b> referent,
<b>ReferenceQueue</b>
queue) { ... }</tt>
<br><tt>&nbsp; public void clear() { ... }</tt>
<br><tt>&nbsp; public boolean enqueue() { ... }</tt>
<br><tt>&nbsp; public <b><font color="#000099">Object</font></b> get()
{ ... }</tt>
<br><tt>&nbsp; public boolean isEnqueued() { ... }</tt>
<br><tt>}</tt></blockquote>
The abstract class <tt>Reference </tt>internally holds a reference of type<tt>Object</tt>
and has methods that take and return <tt>Object</tt> references.&nbsp;
If these methods take and return the same type of object that is held internally,
then the class is more precisely declared as a generic class, namely as
<font color="#000000"><tt>Reference&lt;T>
</tt>where
<tt>T</tt>
is the type of the referent.</font>
<p>When we decide to parameterize class <tt>Reference </tt>then we must
provide type arguments in all places where type <tt>Reference </tt>is used.&nbsp;
This affects class <tt>ReferenceQueue</tt> because it has methods that
return references of type <tt>Reference</tt>.&nbsp; Consequently, we would
declare class <tt>ReferenceQueue </tt>as a generic class, too.
<p>Once we have generified class <tt>ReferenceQueue </tt>then we must return
to class <tt>Reference </tt>and provide type arguments in all places where
type <tt>ReferenceQueue </tt>is used.&nbsp;
<p>Example (of corresponding generic type in JDK 5.0):
<blockquote><tt>public class ReferenceQueue<b><font color="#000099">&lt;T></font></b>
{</tt>
<br><tt>&nbsp; public ReferenceQueue() { }</tt>
<br><tt>&nbsp; public <b><font color="#000000">Reference</font><font color="#000099">&lt;?
extends T></font></b> poll() { ... }</tt>
<br><tt>&nbsp; public <b><font color="#000000">Reference</font><font color="#000099">&lt;?
extends T></font></b> remove(long timeout)&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; throws IllegalArgumentException, InterruptedException
{ ... }</tt>
<br><tt>&nbsp; public <b><font color="#000000">Reference</font><font color="#000099">&lt;?
extends T> </font></b>remove()&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; throws InterruptedException { ... }&nbsp;</tt>
<br><tt>}</tt>
<br><tt>public abstract class Reference<b><font color="#000099">&lt;T></font></b>&nbsp;
{</tt>
<br><tt>&nbsp; private <b><font color="#000099">T</font></b> referent;&nbsp;</tt>
<br><tt>&nbsp; <b>ReferenceQueue<font color="#000099">&lt;? super T></font></b>queue;</tt>
<br><tt>&nbsp; Reference next;</tt>
<br><tt>&nbsp; Reference(<b><font color="#000099">T</font></b> referent)
{ ... }</tt>
<br><tt>&nbsp; Reference(<b><font color="#000099">T</font></b> referent,
<b>ReferenceQueue<font color="#000099">&lt;?
super T></font></b> queue) { ... }</tt>
<br><tt>&nbsp; public void clear() { ... }</tt>
<br><tt>&nbsp; public boolean enqueue() { ... }</tt>
<br><tt>&nbsp; public <b><font color="#000099">T</font></b> get() { ...
}</tt>
<br><tt>&nbsp; public boolean isEnqueued() { ... }</tt>
<br><tt>}</tt></blockquote>
This is an example where a class, namely <tt>ReferenceQueue</tt>, is turned
into a generic class because the types it uses are generic.&nbsp; This
propagation of type parameters&nbsp; into related types is fairly common.
For instance, the subtypes of type <tt>Reference</tt> (namely <tt>PhantomReference</tt>,
<tt>SoftReference</tt>,
and <tt>WeakReference</tt>) are generic types as well.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ102">#FAQ102</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><b><font face="Arial,Helvetica"><font size=-2><a href="#How do I generify an existing non-generic class?">How
do I generify an existing non-generic class?</a></font></font></b></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ103"></a>
<p><a NAME="How do I generify an existing non-generic class?"></a><b><font face="Arial,Helvetica"><font size=+0>How
do I generify an existing non-generic type or method?</font></font></b>
<br>&nbsp;
<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>There are no carved-in-stone rules.&nbsp;
It all depends on the intended semantics of the generified type or method.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Modifying an existing type that was non-generic in the
past so that it becomes usable as a parameterized type in the future is
a non-trivial task. The generification must not break any existing code
that uses the type in its old non-generic form and it must preserve the
original non-generic type's semantic meaning.&nbsp;
<p>For illustration, we study a couple of examples from the collection
framework (see package <tt>java.util in <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/package-summary.html">J2SE
1.4.2</a> and <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/package-summary.html">J2SE
5.0</a></tt>).&nbsp; We will generify the traditional non-generic interface
<tt>Collection</tt>.&nbsp;
From the semantics of a collection it is obvious that for a homogenous
collection of elements of the same type the element type would be the type
parameter of a generic <tt>Collection</tt> interface.
<p>Example (from JDK 1.4; before generification):
<blockquote><tt>interface Collection {</tt>
<br><tt>&nbsp; boolean add&nbsp;&nbsp;&nbsp;&nbsp; (<b><font color="#000099">Object</font></b>
o);&nbsp;</tt>
<br><tt>&nbsp; boolean contains(<b><font color="#000099">Object</font></b>
o);</tt>
<br><tt>&nbsp; boolean remove&nbsp; (<b><font color="#000099">Object</font></b>
o);</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>}</tt></blockquote>
These methods take an element as an argument and insert, find or extract
the element from the collection.&nbsp; In a generic collection the method
parameters would be of type <tt>E</tt>, the interface's type parameter.
<p>Example (from JDK 5.0; after generification):
<blockquote><tt>interface Collection<b><font color="#000099">&lt;E></font></b>
{</tt>
<br><tt>&nbsp; boolean add&nbsp;&nbsp;&nbsp;&nbsp; (<b><font color="#000099">E</font></b>
o);&nbsp;</tt>
<br><tt>&nbsp; boolean contains(<b><font color="#000099">E</font></b> o);&nbsp;</tt>
<br><tt>&nbsp; boolean remove&nbsp; (<b><font color="#000099">E</font></b>
o);</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>}</tt></blockquote>
However, this modification does not exactly preserve the semantics of the
old class.&nbsp; Before the generification it was possible to pass an arbitrary
type of object to these methods.&nbsp; After the generification only objects
of the "right" type are accepted as method arguments.
<p>Example (of modified semantics):
<blockquote><tt>class ClientRepository {</tt>
<br><tt>&nbsp; private Collection<b><font color="#006600">&lt;Client></font></b>
clients = new LinkedList&lt;Client>();</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>&nbsp; boolean isClient(<b><font color="#006600">Object</font></b>
c) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return clients.contains(c);&nbsp;&nbsp; <b><font color="#660000">//
error</font></b></tt>
<br><tt>&nbsp; }&nbsp;</tt>
<br><tt>}</tt></blockquote>
Passing an <tt>Object</tt> reference to method <tt>contains</tt> used to
be permitted before the generification, but no longer compiles after generification.&nbsp;&nbsp;&nbsp;
Seemingly, our generified type is not semantically&nbsp; compatible with
the original non-generic type.&nbsp; A more relaxed generification would
look like this.
<p>Example (from JDK 5.0; after an alternative generification):
<blockquote><tt>interface Collection<b><font color="#000099">&lt;E></font></b>
{</tt>
<br><tt>&nbsp; boolean add&nbsp;&nbsp;&nbsp;&nbsp; (<b><font color="#000099">E</font></b>
o);&nbsp;</tt>
<br><tt>&nbsp; boolean contains(<b><font color="#000099">Object</font></b>
o);&nbsp;</tt>
<br><tt>&nbsp; boolean remove&nbsp; (<b><font color="#000099">Object</font></b>
o);</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>}</tt></blockquote>
Only for the <tt>add</tt> method now would accept the more restrictive
method parameter type <tt>E</tt>.&nbsp; Since a <tt>Collection&lt;E></tt>
is supposed to contain only elements of type <tt>E</tt>, it is expected
and desired that insertion of an alien element is rejected at compile time.&nbsp;
<p>This seemingly trivial example illustrates that decisions regarding
a "correct" generification are largely a matter of taste and style. Often,
there are several viable approaches for a generification.&nbsp; Which one
is "correct" depends on the specific requirements to and expectations of
the semantics of the resulting generified type.&nbsp;</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ103">#FAQ103</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#How do I avoid breaking binary compatibility when I generify an existing type or method?">How
do I avoid breaking binary compatibility when I generify an existing type
or method?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ104"></a>
<p><a NAME="How do I avoid breaking binary compatibility when I generify an existing type or method?"></a><b><font face="Arial,Helvetica"><font size=+0>How
do I avoid breaking binary compatibility when I generify an existing type
or method?</font></font></b>
<br>&nbsp;
<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Sometimes a dummy bound does the trick.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Occasionally, one must pay attention to the fact that a
generification might change the signature of some methods in the byte code.&nbsp;
Changing the signature will break existing code that cannot be recompiled
and relies on the binary compatibility of the old and new version of the
<tt>.class</tt>
file.
<p>Example (before generification, taken from package <tt><a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Collections.html#max(java.util.Collection)">java.util</a></tt>):
<blockquote><tt>class Collections {</tt>
<br><tt>&nbsp; public static <b><font color="#000099">Object</font></b>
max(<b><font color="#000099">Collection</font></b> coll) {...}&nbsp;</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>}</tt></blockquote>
The <tt>max</tt> method finds the largest element in a collection and obviously
the declared return type of the method should match the element type of
the collection passed to the method.&nbsp; A conceivable generification
could look like this.
<p>Example (after a naive generification):
<blockquote><tt>class Collections {</tt>
<br><tt>&nbsp; public static <b><font color="#000099">&lt;T extends Comparable&lt;?
super T>></font></b></tt>
<br><tt>&nbsp; <b><font color="#000099">T </font></b>max(Collection<b><font color="#000099">&lt;?
extends T></font></b> coll)&nbsp; {...}&nbsp;</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>}</tt></blockquote>
While this generification preserves the semantics of the method, it changes
the signature of the <tt>max</tt> method.&nbsp; It is now a method with
return type <tt>Comparable</tt>, instead of <tt>Object</tt>.&nbsp;
<p>Example (after type erasure):
<blockquote><tt>class Collections {</tt>
<br><tt>&nbsp; public static <b><font color="#330033">Comparable</font></b>
max(<b><font color="#330033">Collection</font></b> coll)&nbsp; {...}&nbsp;</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>}</tt></blockquote>
This will break existing code that relies on the binary compatibility of
the <tt>.class</tt> files.&nbsp; In order to preserve the signature and
thus the binary compatibility, an otherwise superfluous bound can be used.
<p>Example (after binary compatible generification, as available in package
<tt><a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Collections.html#max(java.util.Collection)">java.util</a></tt>):
<blockquote><tt>class Collections {</tt>
<br><tt>&nbsp; public stati<b><font color="#000000">c &lt;T extends </font><font color="#000099">Object
&amp;
</font><font color="#000000">Comparable&lt;? super T>></font></b></tt>
<br><tt><font color="#000000"><b>&nbsp; T</b> max(Collection<b>&lt;? extends
T></b> coll)&nbsp; {...}</font></tt>
<br><tt>&nbsp; ...</tt>
<br><tt>}</tt></blockquote>
The leftmost bound of the type parameter is now type <tt>Object</tt> instead
of type <tt>Comparable</tt>, so that the type parameter <tt>T</tt> is replaced
by <tt>Object</tt> during type erasure.
<p>Example (after type erasure):
<blockquote><tt>class Collections {</tt>
<br><tt>&nbsp; public static <b><font color="#330033">Object</font></b>
max(<b><font color="#330033">Collection</font></b> coll)&nbsp; {...}&nbsp;</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>}</tt></blockquote>

<hr WIDTH="100%">
<br>Afterthought:&nbsp;
<p>Perhaps you wonder why the hack decribed in this FAQ entry is needed.&nbsp;
Indeed, had the <tt>Collections.max</tt> method been defined as returning
a <tt>Comparable</tt> in the first place, no further measures, such as
adding <tt>Object</tt> as a type parameter bound, had been required to
preserve binary compatibility. Basically, the declared return type <tt>Object</tt>
is a mistake in the design of this method.&nbsp;
<p>If you carefully study the specification of the <tt>Collections.max&nbsp;</tt>
method's functionality then you realize that all elements of the collection
are required to implement the <tt>Comparable</tt> interface.&nbsp; Consequently,
the returned object is <tt>Comparable</tt>, too.&nbsp; There is no reason
why the method should return an <tt>Object</tt> reference.&nbsp;
<p>The only explanation one can think of is that in pre-generic Java there
was no way of ensuring by compile-time type checks that the <tt>Collection</tt>
contains only <tt>Comparable</tt> objects.&nbsp; However, this was ensured
via runtime type checks, namely an explicit downcast in the implementation
of the method.&nbsp; Hence this is not really an excuse for the bug.
<p>Note, that the runtime time type check in the pre-generic version of
the <tt>Collections.max</tt> method still exists in the generic version.&nbsp;
The former explicit cast is now an implicit one generated by the compiler.&nbsp;
In the generic version, this cast can never fail (unless there are unchecked
warnings), because the type parameter bound <tt>Comparable </tt>ensures
at compile-time that the elements in the <tt>Collection</tt> are <tt>Comparable</tt>.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ104">#FAQ104</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350>
<br>&nbsp;
<br>&nbsp;
<h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450></h3>

<h3>
<a NAME="Defining Parameterized Types and Methods"></a>Defining Generic
Types and Methods</h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450><a NAME="FAQ201"></a>
<h2>
<a NAME="When would I implement a parameterized class (or method) instead of a regular one?"></a><font face="Arial,Helvetica"><font size=+0>When
would I implement a generic class (or method) instead of a regular one?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>When your class or method uses a supertype
reference somewhere and you know that the supertype reference will refer
to the same type of object and not to various types of objects.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Consider a <tt>Callable</tt> interface (similar to <tt>java.util.concurrent.Callable</tt>).&nbsp;
It has a <tt>call</tt> method that returns a result.&nbsp; A natural approach
might be a definition like the one below.
<p>Example:
<blockquote><tt>interface Callable {</tt>
<br><tt>&nbsp; Object call();</tt>
<br><tt>}</tt></blockquote>
Usually, the <tt>call</tt> method does not return a different type of result
each time it is invoked.&nbsp; Quite the converse, every single callable
object always returns a result of a particular type.&nbsp; Hence it makes
sense to provides means for specifying that particular return type by generifying
the <tt>Callable</tt> interface.
<p>Example:
<blockquote><tt>interface Callable<b><font color="#000099">&lt;V></font></b>
{</tt>
<br><tt>&nbsp; <b><font color="#000099">V</font></b> call();</tt>
<br><tt>}</tt></blockquote>
Now, you would work with a <tt>Callable&lt;String></tt> for instance, saying
that this callable object returns a string when you call it.&nbsp; You
can still say that a callable object returns something different each time
you call it, by using a <tt>Callable&lt;Object></tt>.&nbsp; The generification
provides a way to guarantee homogenity, like "returns the same type of
result each time it is invoked".
<p>Consider a <tt>Triple</tt> class.&nbsp; It contains two elements of
the same type.&nbsp; It could be implemented as shown below.
<p>Example:
<blockquote><tt>class Triple {</tt>
<br><tt>&nbsp; private Object t1, t2, t3;</tt>
<br><tt>&nbsp; public Triple(Object a1, Object a2, Object a3) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; t1 = a1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; t2 = a2;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; t3 = a3;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; public void reset(Object a1, Object a2, Object a3) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; t1 = a1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; t2 = a2;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; t3 = a3;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; public void setFirst(Object a1) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; t1 = a1;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; public void setSecond(Object a2) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; t2 = a2;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; public void setThird(Object a3) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; t3 = a3;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; public Object getFirst() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return a1;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; public Object getSecond() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return a2;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; public Object getThird() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return a3;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>}</tt></blockquote>
First, a triple is expected to contain three elements of the same type,
like three strings, or three dates, or three integers.&nbsp; It is usually
not a triple of objects of different type.&nbsp; Secondly, a certain triple
object will probably contain the same type of members during its entire
lifetime. It will not contain strings today, and integers tomorrow.&nbsp;
This can be expressed more precisely by generification.
<p>Example:
<blockquote><tt>class Triple<b><font color="#000099">&lt;T></font></b>
{</tt>
<br><tt>&nbsp; private <b><font color="#000099">T</font></b> t1, t2, t3;</tt>
<br><tt>&nbsp; public Triple(<b><font color="#000099">T</font></b> a1,
<b><font color="#000099">T</font></b>
a2, <b><font color="#000099">T</font></b> a3) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; t1 = a1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; t2 = a2;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; t3 = a3;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; public void reset(<b><font color="#000099">T</font></b>
a1, <b><font color="#000099">T</font></b> a2, <b><font color="#000099">T</font></b>
a) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; t1 = a1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; t2 = a2;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; t3 = a3;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; public void setFirst(<b><font color="#000099">T</font></b>
a1) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; t1 = a1;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; public void setSecond(<b><font color="#000099">T</font></b>
a2) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; t2 = a2;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; public void setThird(<b><font color="#000099">T</font></b>
a3) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; t3 = a3;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; public <b><font color="#000099">T</font></b> getFirst()
{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return a1;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; public <b><font color="#000099">T</font></b> getSecond()
{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return a2;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; public <b><font color="#000099">T</font></b> getThird()
{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return a3;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>}</tt></blockquote>
Now we would work with a <tt>Triple&lt;String></tt>, saying that all members
are strings and will remain strings.&nbsp; We can still permit variations
like in a <tt>Triple&lt;Number></tt>, where the members can be of differents
number types like <tt>Long</tt>,&nbsp; <tt>Short </tt>and <tt>Integer</tt>,
and where a <tt>Short</tt> member can be replaced by a <tt>Long</tt> member
or vice versa.&nbsp; We can even use <tt>Triple&lt;Object></tt>, where
everything goes.&nbsp; The point is that the generification allows to be
more specific and enforce homogenity.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ201">#FAQ201</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ202"></a>
<h2>
<a NAME="When would I use an unbounded wildcard instantiation instead of a bounded or concrete instantiation?"></a><font face="Arial,Helvetica"><font size=+0>When
would I use an unbounded wildcard parameterized type instead of a bounded
wildcard or concrete parameterized type?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>When you need a reifiable type.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Occasionally, an unbounded wildcard parameterized type
is used because it is a so-called reifiable type and can be used in situations
where non-refiable types are not permitted.&nbsp;
<ul>
<li>
One of these situations are type checks (i.e., cast or <tt>instanceof</tt>
expressions).&nbsp; Non-reifiable types (i.e., concrete or bounded wildcard
parameterized type) are not permitted as the target type of a type check
or lead to "unchecked" warnings.&nbsp;</li>

<li>
Another situation is the use of arrays.&nbsp; Non-reifiable types (i.e.,
concrete or bounded wildcard parameterized type) are not permitted as the
component type of an array.</li>
</ul>
Depending on the situation, the unbounded wildcard parameterized type can
substitute a concrete or bounded wildcard parameterized type in a type
check or an array in order to avoid errors or warning.
<p>
<hr WIDTH="100%">
<p>Non-reifiable types (i.e., concrete or bounded wildcard parameterized
type) are not permitted as the target type of a type check or lead to "unchecked"
warnings. A typical situation, in shich such a cast would be needed, is
the implementation of methods such as the <tt>equals</tt> method, that
take <tt>Object</tt> reference and where a cast down to the actual type
must be performed.
<p>Example (not recommended):
<blockquote><tt>class Triple&lt;T> {</tt>
<br><tt>&nbsp; private T fst, snd, trd;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp; public boolean equals<font color="#000000">(Object other)
{</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; ...</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Triple&lt;T> otherTriple
= </font><b><font color="#000099">(Triple&lt;T>)</font></b>other; <b><font color="#660000">//
warning; unchecked cast</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; return (this.fst.equals(otherTriple.fst)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; this.snd.equals(otherTriple.snd)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; this.trd.equals(otherTriple.trd));</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
When we replace the cast to <tt>Triple&lt;T></tt> by a cast to <tt>Triple&lt;?></tt>
the warning disappears, because unbounded wildcard parameterized type are
permitted as target type of a cast without any warnings.
<p>Example (implementation of <tt>equals</tt>):
<blockquote><tt>class Triple&lt;T> {</tt>
<br><tt>&nbsp; private T fst, <font color="#000000">snd, trd;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; ...</font></tt>
<br><tt><font color="#000000">&nbsp; public boolean equals(Object other)
{</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; ...</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Triple&lt;?> otherTriple
= </font><b><font color="#000099">(Triple&lt;?>)</font></b><font color="#000000">other;</font></tt>
<br><tt>&nbsp;&nbsp;&nbsp; return (this.fst.equals(otherTriple.fst)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; this.snd.equals(otherTriple.snd)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; this.trd.equals(otherTriple.trd));</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
Note, that replacing the concrete parameterized type by the wildcard parameterized
type works in this example only because we need no write access to the
fields of the referenced object referred and we need not invoke any methods.&nbsp;
Remember, use of the object that a wildcard reference variable refers to
is restricted.&nbsp; In other situations, use of a wildcard parameterized
type might not be a viable solution, because full access to the referenced
object is needed.&nbsp; (Such a situation can arise, for instance, when
you implement the <tt>clone</tt> method of a generic class.)
<p>
<hr WIDTH="100%">
<br>Non-reifiable types (i.e., concrete or bounded wildcard parameterized
type) are not permitted as the component type of an array.&nbsp; Here is
an example:
<p>Example (of illegal array type):
<blockquote><tt>static void test() {</tt>
<br><tt>&nbsp; <b><font color="#000000">Pair&lt;Integer,Integer>[]</font></b>
arr = new <b><font color="#000000">Pair&lt;Integer,Integer>[10]</font></b>;
<b><font color="#660000">//
error</font></b></tt>
<br><tt>&nbsp; arr[0] = new Pair&lt;Integer,Integer>(0,0);</tt>
<br><tt>&nbsp; arr[1] = new Pair&lt;String,String>("","");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// would fail with ArrayStoreException</tt>
<p><tt>&nbsp; Pair&lt;Integer,Integer> pair = arr[0];</tt>
<br><tt>&nbsp; Integer i = pair.getFirst();</tt>
<br><tt>&nbsp; pair.setSecond(i);</tt>
<br><tt>}</tt></blockquote>
The concrete parameterized type <tt>Pair&lt;Integer,Integer></tt> is illegal.
As a workaround one might consider using an array of the corresponding
unbounded wildcard parameterized type.
<p>Example (of array of unbounded wildcard parameterized type):
<blockquote><tt>static void test() {</tt>
<br><tt>&nbsp; <b><font color="#000099">Pair&lt;?,?>[]</font></b> arr =
new <b><font color="#000099">Pair&lt;?,?>[10]</font></b>;&nbsp;</tt>
<br><tt>&nbsp; arr[0] = new Pair&lt;Integer,Integer>(0,0);</tt>
<br><tt>&nbsp; arr[1] = new Pair&lt;String,String>("","");&nbsp;&nbsp;&nbsp;
// succeeds</tt>
<p><tt>&nbsp; Pair&lt;Integer,Integer> pair1 = arr[0];&nbsp;&nbsp; <font color="#660000">//
<b>error</b></font></tt>
<br><tt>&nbsp;<b><font color="#660000"> </font></b>Pair&lt;?,?>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
pair2 = arr[0];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#003300">//
<b>ok</b></font></tt>
<p><tt>&nbsp; Integer i = pair2.getFirst();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#660000">//
<b>error</b></font></tt>
<br><tt>&nbsp; Object&nbsp; o = pair2.getFirst();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#003300">// <b>ok</b></font></tt>
<p><tt>&nbsp; pair2.setSecond(i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#660000">//
<b>error</b></font></tt>
<br><tt>}</tt></blockquote>
However, a <tt>Pair&lt;?,?>[] </tt>is semantically different from the illegal
<tt>Pair&lt;Integer,Integer>[]</tt>.&nbsp;
It is not homogenous, but contains a mix of arbitrary pair types.&nbsp;
The compiler does not and cannot prevent that they contain different instantiations
of the generic type.&nbsp; In the example, I can insert a pair of strings
into what was initially supposed to be a pair of integers.
<p>When we retrieve elements from the array we receive references of type
<tt>Pair&lt;?,?></tt>.&nbsp;&nbsp;
This is demonstrated in our example: we cannot assign the <tt>Pair&lt;?,?></tt>
taken from the array to the more specific <tt>Pair&lt;Integer,Integer></tt>,
that we really wanted to use.&nbsp;
<p>Various operations on the<tt> Pair&lt;?,?></tt> are rejected as errors,
because the wildcard type does not give access to all operations of the
referenced object. In our example, invocation of the <tt>set</tt>-methods
is rejected with error messages.
<p>Depending on the situation, an array of a wildcard parameterized type
may be a viable alternative to the illegal array of a concrete (or bounded
wildcard) parameterized type.&nbsp; If full access to the referenced element
is needed, this approach does not work and a better solution would be use
of a collection instead of an array.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ202">#FAQ202</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#What is a reifiable type?">What
is a reifiable type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#How can I avoid unchecked cast warnings?">How
can I avoid "unchecked cast" warnings?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#How can I work around the restriction that there are no arrays whose component type is a concrete instantiation of a">How
can I work around the restriction that there are no arrays whose component
type is a concrete parameterized type?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ203"></a>
<p><a NAME="When would I use a wildcard instantiation instead of a concrete instantiation?"></a><b><font face="Arial,Helvetica"><font size=+0>When
would I use a wildcard parameterized type instead of a concrete parameterized
type?</font></font></b>
<br>&nbsp;
<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Whenever you need the supertype of all
or some instantiations of a generic type.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">There are two typical situations in which wildcard parameterized
types are used because they act as supertype of all instantiations of a
given generic type:
<ul>
<li>
relaxing a method signature to allow a broader range of argument or return
types</li>

<li>
denoting a mix of instantiations of the same generic type</li>
</ul>
Details are discussed in the FAQ entries <font face="Arial,Helvetica"><font size=-2><a href="#Which role do wildcards play in method signatures?">#FAQ301</a></font></font>
and <font face="Arial,Helvetica"><font size=-2><a href="#How do I express a mixed sequence of instantiations of a given parameterized type?">#FAQ006</a></font></font>
listed in the reference section below.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ203">#FAQ203</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#Which role do wildcards play in method signatures?">Which
role do wildcards play in method signatures?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#How do I express a mixed sequence of instantiations of a given parameterized type?">How
do I express a mixed sequence of instantiations of a given generic type?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ204"></a>
<p><a NAME="When would I use a wildcard instantiation with a lower bound?"></a><b><font face="Arial,Helvetica"><font size=+0>When
would I use a wildcard parameterized type with a lower bound?</font></font></b>
<br>&nbsp;
<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>When a concrete parmeterized type would
be too restrictive.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Consider a class hierarchy where a the topmost superclass
implements an instantiation of the generic <tt>Comparable</tt> interface.&nbsp;
<p>Example:
<blockquote><tt>class Person implements Comparable&lt;Person> {</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>}</tt>
<br><tt>class Student extends Person {</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>}</tt></blockquote>
Note, the <tt>Student</tt> class does not and cannot implement <tt>Comparable&lt;Student></tt>,
because it would be a subtype of two different instantiations of the same
generic type then, and that is illegal (details <a href="#Can a class implement different instantiations of the same parameterized interface?">here</a>).&nbsp;
<p>Consider also a method that tries to sort a sequence of subtype objects,
such as a <tt>List&lt;Student></tt>.
<p>Example:
<blockquote><tt>class Utilities {</tt>
<br><tt>&nbsp; public static &lt;T extends Comparable&lt;T>> void sort(List&lt;T>
list) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>}</tt></blockquote>
This <tt>sort</tt> method cannot be applied to a list of students.
<p>Example:
<blockquote><tt>List&lt;Student> list = new ArrayList&lt;Student>();</tt>
<br><tt>...</tt>
<br><tt>Utilities.sort(list);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#660000">//
error</font></b></tt></blockquote>

<p><br>The reason for the error message is that the compiler infers the
type parameter of the sort method as <tt>T:=Student</tt> and that class
<tt>Student</tt>
is not <tt>Comparable&lt;Student></tt>.&nbsp; It is <tt>Comparable&lt;Person></tt>,
but that does not meet the requirements imposed by the bound of the type
parameter of method sort.&nbsp; It is required that <tt>T</tt> (i.e.<tt>
Student</tt>) is <tt>Comparable&lt;T></tt> (i.e.<tt> Comparable&lt;Student></tt>),
which in fact it is not.
<p>In order to make the <tt>sort</tt> method applicable to a list of subtypes
we would have to use a wildcard with a lower bound, like in the re-engineered
version of the <tt>sort</tt> method below.
<p>Example:
<blockquote><tt>class Utilities {</tt>
<br><tt>&nbsp; public static &lt;T extends Comparable<b><font color="#000099">&lt;?
super T</font><font color="#3333FF">></font></b>> void sort(List&lt;T>
list) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>}</tt></blockquote>
Now, we can sort a list of students, because students are comparable to
a supertype of <tt>Student</tt>, namely <tt>Person</tt>.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ204">#FAQ204</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#Can a class implement different instantiations of the same parameterized interface?">Can
a subclass implement another instantiation of a generic interface than
any of its superclasses does?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350>
<br>&nbsp;
<br>&nbsp;
<h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450></h3>

<h3>
<a NAME="Designing Generic Methods"></a>Designing Generic Methods</h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450><a NAME="FAQ301"></a>
<h2>
<a NAME="Which role do wildcards play in method signatures?"></a><font face="Arial,Helvetica"><font size=+0>Which
role do wildcards play in method signatures?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>They broaden the set of argument or return
types that a method accepts or returns.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Consider the problem of writing a routine that prints out
all the elements in a collection. In non-generic Java it might look like
this:
<p>Example (of non-generic <tt>print</tt> method):
<blockquote><tt>void printCollection(<b><font color="#000099">Collection</font></b>
c) {&nbsp;</tt>
<br><tt>&nbsp; Iterator i = c.iterator();</tt>
<br><tt>&nbsp; for (k = 0; k &lt; c.size(); k++) {&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; System.out.println(i.next());</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
In generic Java the same method might be implemented like this.
<p>Example (of generic <tt>print</tt> method):
<blockquote><tt>void printCollection(<b><font color="#000099">Collection&lt;Object></font></b>
c) {</tt>
<br><tt>&nbsp; for (Object e : c) {&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; System.out.println(e);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
The problem is that this new version is much less useful than the old one.
Whereas the old code could be called with any kind of collection as a parameter,
the new code only takes <tt>Collection&lt;Object></tt>, which is not a
supertype of all kinds of collections. For instance, it is possible to
invoke the old version supplying a <tt>List&lt;String></tt> as an argument,
while the new version rejects the <tt>List&lt;String></tt> argument because
it has an incompatible type.
<p>So what we need here is the supertype of all kinds of collections and
that's exactly what the unbounded wildcard parameterized type <tt>Collection&lt;?></tt>
is.
<p>Example (final version of <tt>print</tt> method):
<blockquote><tt>void printCollection(<b><font color="#000099">Collection&lt;?></font></b>
c) {</tt>
<br><tt>&nbsp; for (Object e : c) {&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; System.out.println(e);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
Now, we can call the <tt>print</tt> method with any type of collection.
<p>Bounded wildcards are used for similar purposes. The sole difference
is that the set of types that they allow is smaller (because it's restricted
by the respective bound).&nbsp; The key idea for use of wildcards in method
signatures is to allow a broader set of argument or return types than would
be possible with a concrete instantiation.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ301">#FAQ301</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ302"></a>
<p><a NAME="Is it better to parameterize a method rather than using wildcards?"></a><b><font face="Arial,Helvetica"><font size=+0>Is
it better to parameterize a method rather than using wildcards?</font></font></b>
<br>&nbsp;
<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>In case you have a choice between both,
the generic method is probably the better choice.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Consider a method that reverts the order of elements in
a list.&nbsp; One way of implementing it would be the one shown below,
where the <tt>reverse</tt> method is generic and takes a list of a certain
unknown element type and returns that same list.
<p>Example (implementation of a generic <tt>reverse</tt> method):
<blockquote><tt>public static <b><font color="#000099">&lt;T></font></b>
List<b><font color="#000099">&lt;T></font></b> reverse(List<b><font color="#000099">&lt;T></font></b>
list) {</tt>
<br><tt>&nbsp; List&lt;T> tmp = new ArrayList&lt;T>(list);</tt>
<br><tt>&nbsp; for (int i=0;i&lt;list.size();i++){</tt>
<br><tt>&nbsp;&nbsp;&nbsp; tmp.set(i,list.get(list.size()-i-1));</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; return tmp;</tt>
<br><tt>}</tt></blockquote>

<p><br>An alternative way of implementing it would involve wildcards, as
is sketched out below.
<p>Example (implementation of a <tt>reverse</tt> method with wildcards;
does not work):
<blockquote><tt>public static List<b><font color="#000099">&lt;?></font></b>
reverse(List<b><font color="#000099">&lt;?></font></b> list) {</tt>
<br><tt>&nbsp; List&lt;?> tmp = new ArrayList&lt;?>(list);&nbsp; <b><font color="#660000">//
error</font></b></tt>
<br><tt>&nbsp; for (int i=0;i&lt;list.size();i++){</tt>
<br><tt>&nbsp;&nbsp;&nbsp; tmp.set(i,list.get(list.size()-i-1)); <b><font color="#660000">//
error</font></b></tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; return tmp;</tt>
<br><tt>}</tt></blockquote>
The problem is that the temporary list cannot be created, because its actual
type is unknown and objects of a wildcard type such as <tt>ArrayList&lt;?></tt>
must not be created. In addition, we cannot invoke a method such as <tt>set</tt>
on a reference variable of a wildcard type; it's illegal.&nbsp;&nbsp; In
other word, if we use wildcard parameterized types as the method parameter
types we are severely restricted when it comes to the method implementation.
<p>The usual workaround is use of wildcard capture (see <font face="Arial,Helvetica"><font size=-2>#<a href="TechnicalDetails.html#What is the capture of a wildcard?">FAQ501</a></font></font>)
and a generic helper method.
<p>Example (corrected implementation of a <tt>reverse</tt> method with
wildcards):
<blockquote><tt>public static List<b><font color="#000099">&lt;?></font></b>
reverse(List<b><font color="#000099">&lt;?></font></b> list) {</tt>
<br><tt>&nbsp; return rev(list);</tt>
<br><tt>}</tt>
<br><tt>private static <b><font color="#000099">&lt;T></font></b> List<b><font color="#000099">&lt;T></font></b>
rev(List<b><font color="#000099">&lt;T></font></b> list) {</tt>
<br><tt>&nbsp; List&lt;T> tmp = new ArrayList&lt;T>(list);</tt>
<br><tt>&nbsp; for (int i=0;i&lt;list.size();i++){</tt>
<br><tt>&nbsp;&nbsp;&nbsp; tmp.set(i,list.get(list.size()-i-1));</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; return tmp;</tt>
<br><tt>}</tt></blockquote>
Wildcard capture makes it possible to invoke a generic helper method.&nbsp;
The helper method has unrestricted access to its arguments' methods and
can provide the necessary implementation.
<p>So far, the two versions look mostly equivalent.&nbsp; They accept the
same set of argument types, namely any instantiation of <tt>List</tt>.&nbsp;
Performance-wise there is no difference; the Hotspot compiler optimizes
away the extra method call in the wildcard version.&nbsp; It's the return
type that makes the difference.
<p>The wildcard version returns a <tt>List&lt;?></tt>, which gives only
restricted access to the returned object. The generic version, in contrast,
returns a concrete instantiation of <tt>List</tt>, that gives full access
to all methods of the <tt>List</tt> type.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ302">#FAQ302</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#Should I use wildcards in the return type of a method?">Should
I use wildcards in the return type of a method?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#Which methods and fields are accessible/inaccessible through a reference variable of a wildcard type?">Which
methods and fields are accessible/inaccessible through a reference variable
of a wildcard type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#What is the capture of a wildcard?">What
is the capture of a wildcard?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ303"></a>
<h2>
<a NAME="Should I use wildcards in the return type of a method?"></a><font face="Arial,Helvetica"><font size=+0>Should
I use wildcards in the return type of a method?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Avoid it, if you can.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Consider the example of a <tt>reverse</tt> method that
reverts the order of elements in a list.&nbsp; You can implement it as
a generic method or as a method that takes and return a wildcard parameterized
type.&nbsp;
<p>Example (implementation of a generic <tt>reverse</tt> method):
<blockquote><tt>public static <b><font color="#000099">&lt;T></font></b>
List<b><font color="#000099">&lt;T></font></b> reverse(List<b><font color="#000099">&lt;T></font></b>
list) {</tt>
<br><tt>&nbsp; List&lt;T> tmp = new ArrayList&lt;T>(list);</tt>
<br><tt>&nbsp; for (int i=0;i&lt;list.size();i++){</tt>
<br><tt>&nbsp;&nbsp;&nbsp; tmp.set(i,list.get(list.size()-i-1));</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; return tmp;</tt>
<br><tt>}</tt></blockquote>
Example (implementation of a <tt>reverse</tt> method with wildcards):
<blockquote><tt>public static List<b><font color="#000099">&lt;?></font></b>
reverse(List<b><font color="#000099">&lt;?></font></b> list) {</tt>
<br><tt>&nbsp; return rev(list);</tt>
<br><tt>}</tt>
<br><tt>private static <b><font color="#000099">&lt;T></font></b> List<b><font color="#000099">&lt;T></font></b>
rev(List<b><font color="#000099">&lt;T></font></b> list) {</tt>
<br><tt>&nbsp; List&lt;T> tmp = new ArrayList&lt;T>(list);</tt>
<br><tt>&nbsp; for (int i=0;i&lt;list.size();i++){</tt>
<br><tt>&nbsp;&nbsp;&nbsp; tmp.set(i,list.get(list.size()-i-1));</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; return tmp;</tt>
<br><tt>}</tt></blockquote>
The wildcard version returns a reference of a wildcard type, namely of
type
<tt>List&lt;?></tt>.&nbsp; This leads to slightly surprising effects.
<p>Example (of using the result of the wildcard <tt>reverse </tt>method):
<blockquote><tt>public static <b><font color="#000099">List&lt;?></font></b>
reverse(List&lt;?> list) {</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>}</tt>
<p><tt>List&lt;String> list = new ArrayList&lt;String>();</tt>
<br><tt>...</tt>
<br><tt>List&lt;String>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ll0 = reverse(list);&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#660000">//
error</font></b></tt>
<br><tt>List&lt;?>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ll1 = reverse(list);&nbsp;</tt>
<br>
<hr WIDTH="100%">
<br><tt>error: incompatible types</tt>
<br><tt>found&nbsp;&nbsp; : java.util.List&lt;capture of ?></tt>
<br><tt>required: java.util.List&lt;java.lang.String></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List&lt;String>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ll0 = reverse(list);</tt></blockquote>
The <tt>reverse </tt>method returns a reference of type <tt>List&lt;?></tt>,
which is a reference to an object of type <tt>ArrayList&lt;String></tt>
in our example. Yet the returned value is not assignable to a reference
variable of type <tt>List&lt;String></tt>. The method is declared to return
"any type of list", and "any type of list" is not compatible with a particular
type of list.&nbsp; All we can do is assign the result to a reference variable
of type <tt>List&lt;?></tt>, which takes away the access to a substantial
number of list operations.
<p>This is different for the generic version of the <tt>reverse</tt> method.
<p>Example:
<blockquote><tt>private static &lt;T> <b><font color="#000099">List&lt;T></font></b>
rev(List&lt;T> list) {</tt>
<br><tt>&nbsp; ...;</tt>
<br><tt>}</tt>
<p><tt>List&lt;String> list = new ArrayList&lt;String>();</tt>
<br><tt>...</tt>
<br><tt>List&lt;String>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
l0 = rev(list);</tt>
<br><tt>List&lt;?>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
l1 = rev(list);</tt>
<br>&nbsp;</blockquote>
The generic <tt>reverse </tt>method returns a reference of the same type
of list that was passed to the method.&nbsp; For this reason the result
in our example is of type <tt>List&lt;String></tt>.&nbsp; We can assign
the result to a reference variable of type <tt>List&lt;String></tt> and
have unrestricted access to all list operations.
<p>Returning a wildcard parameterized type is rarely a good idea and is
best avoided whenever possible.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ303">#FAQ303</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><b><font face="Arial,Helvetica"><font size=-2><a href="#Is it better to parameterize a method rather than using wildcards?">Is
it better to parameterize a method rather than using wildcards?</a></font></font></b>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#Which methods and fields are accessible/inaccessible through a reference variable of a wildcard type?">Which
methods and fields are accessible/inaccessible through a reference variable
of a wildcard parameterized type?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ304"></a>
<p><a NAME="How do I implement a method that takes a wildcard argument?"></a><b><font face="Arial,Helvetica"><font size=+0>How
do I implement a method that takes a wildcard argument?</font></font></b>
<br>&nbsp;
<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Using a generic helper method and wildcard
capture.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Consider the situation where you decided that a certain
method should take arguments whose type is a wildcard parameterized type.&nbsp;
When you start implementing such a method you will find that you do not
have full access to the argument.&nbsp; This is because wildcards do not
permit certain operations on the wildcard parameterized type.&nbsp;
<p>Example (implementation of a <tt>reverse</tt> method with wildcards;
does not work):
<blockquote><tt>public static void reverse(List<b><font color="#000099">&lt;?></font></b>
list) {</tt>
<br><tt>&nbsp; List&lt;?> tmp = <b>new ArrayList&lt;?></b>(list); <b><font color="#660000">//
error</font></b></tt>
<br><tt>&nbsp; for (int i=0;i&lt;list.size();i++){</tt>
<br><tt>&nbsp;&nbsp;&nbsp; tmp.<b>set</b>(i,list.get(list.size()-i-1));
<b><font color="#660000">//
error</font></b></tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; list = tmp;</tt>
<br><tt>}</tt></blockquote>
Using the wildcard type<tt> List&lt;?></tt> we can neither create a temporary
copy of the argument nor can we invoke the <tt>set</tt> method.&nbsp; A
workaround, that works in this particular case, is use of wildcard capture
and a generic helper method.
<p>Example (corrected implementation of a <tt>reverse</tt> method with
wildcards):
<blockquote><tt>public static void reverse(List<b><font color="#000099">&lt;?></font></b>
list) {</tt>
<br><tt>&nbsp; return rev(list);</tt>
<br><tt>}</tt>
<br><tt>private static <b><font color="#000099">&lt;T></font></b> void
rev(List<b><font color="#000099">&lt;T></font></b> list) {</tt>
<br><tt>&nbsp; List&lt;T> tmp = new ArrayList&lt;T>(list);</tt>
<br><tt>&nbsp; for (int i=0;i&lt;list.size();i++){</tt>
<br><tt>&nbsp;&nbsp;&nbsp; tmp.set(i,list.get(list.size()-i-1));</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; list = tmp;</tt>
<br><tt>}</tt></blockquote>
Wildcard capture makes it possible to invoke a generic helper method.&nbsp;
The helper method does not use any wildcards; it is generic and has a type
parameter instead.&nbsp; It has unrestricted access to its arguments' methods
and can provide the necessary implementation.&nbsp;
<p>Since the helper method has the exact same functionality as the original
method and permits the same set of argument types, one might consider using
it instead of the method with the wildcard argument in the first place.
<p>Example (generic version of the <tt>reverse</tt> method):
<blockquote><tt>public static <b><font color="#000099">&lt;T></font></b>
void reverse(List<b><font color="#000099">&lt;T></font></b> list) {</tt>
<br><tt>&nbsp; List&lt;T> tmp = new ArrayList&lt;T>(list);</tt>
<br><tt>&nbsp; for (int i=0;i&lt;list.size();i++){</tt>
<br><tt>&nbsp;&nbsp;&nbsp; tmp.set(i,list.get(list.size()-i-1));</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; list = tmp;</tt>
<br><tt>}</tt></blockquote>
</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ304">#FAQ304</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#What is the capture of a wildcard?">What
is the capture of a wildcard?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedMethods.html#What is a parameterized (or generic) method?">What
is a parameterized (or generic) method?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#Can I use a wildcard instantiation like any other type?">Can
I use a wildcard parameterized type like any other type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#Can I create an object whose type is a wildcard instantiation of a parameterized type?">Can
I create an object whose type is a wildcard parameterized type?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ305"></a>
<p><a NAME="How do I implement a method that takes a multi-level wildcard argument?"></a><b><font face="Arial,Helvetica"><font size=+0>How
do I implement a method that takes a multi-level wildcard argument?</font></font></b>
<br>&nbsp;
<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Using several&nbsp; generic helper methods
and wildcard capture.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Here is a an example of a method whose argument and return
type is a multi-level wildcard. It is a method that takes a list whose
element type is an arbitrary&nbsp; pair type and return such a list.&nbsp;
The <tt>swapAndReverse</tt> method reverses the order all the list elements
and swaps the members of each pair.&nbsp; It is a contrived example for
the purpose of illustrating the implementation technique.
<p>Example:
<blockquote><tt>class Pair&lt;E> {</tt>
<br><tt>&nbsp; private E fst, snd;</tt>
<br><tt>&nbsp; public E getFirst() { return fst; }</tt>
<br><tt>&nbsp; public void setFirst(S s) { fst = s; }</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>}</tt>
<br><tt>class Test {</tt>
<br><tt>&nbsp; <b>public static ArrayList&lt;? extends Pair&lt;?>> swapAndReverse(ArrayList<font color="#000099">&lt;?
extends Pair&lt;?>></font> l) {</b></tt>
<br><b><tt>&nbsp;&nbsp;&nbsp; ...&nbsp;</tt></b>
<br><b><tt>&nbsp; }</tt></b>
<br><tt>&nbsp; public static void main(String[] args) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#000099">ArrayList&lt;Pair&lt;Integer>></font></b>
list = new ArrayList&lt;Pair&lt;Integer>>();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list.add(new Pair&lt;Integer>(-1,1,0));</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list.add(new Pair&lt;Integer>(1,0,0));</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List&lt;?> result =
swapAndReverse(list);</tt>
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#000099">ArrayList&lt;Pair&lt;?>></font></b>list
= new ArrayList&lt;Pair&lt;?>>();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list.add(new Pair&lt;String>("a","b","c"));</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list.add(new Pair&lt;Integer>(1,0,-1));</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list.add(new Pair&lt;Object>(new
Date(),Thread.State.NEW,5));</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List&lt;?> result =
swapAndReverse(list);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
The <tt>swapAndReverse</tt> method can be invoked on homogenous lists of
pairs of the same type, such as a <tt>ArrayList&lt;Pair&lt;Integer>></tt>,
but also on a heterogenous list of pairs of different types, such as
<tt>ArrayList&lt;Pair&lt;?>></tt>.
<p>When we try to implement the method we find that the wildcard argument
type does not permit invocation of the operations that we need.
<p>Example (implementation of a <tt>swapAndReverse</tt> method with wildcards;
does not work):
<blockquote><tt>public static ArrayList&lt;? extends Pair&lt;?>> swapAndReverse(ArrayList<b><font color="#000099">&lt;?
extends Pair&lt;?>></font></b> l) {</tt>
<br><tt>&nbsp; ArrayList&lt;? extends Pair&lt;?>> list&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; = <b>new ArrayList&lt;? extends Pair&lt;?>></b>(l);
<b><font color="#660000">//
error</font></b></tt>
<br><tt>&nbsp; for (int i=0;i&lt;l.size();i++){</tt>
<br><tt>&nbsp;&nbsp;&nbsp; list.<b>set</b>(i,l.get(l.size()-i-1)); <b><font color="#660000">//
error</font></b></tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; for (Pair&lt;?> pair : list) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Object e = pair.getFirst();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; pair.<b>setFirst</b>(pair.getSecond());<b><font color="#660000">//
error</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; pair.<b>setSecond</b>(e);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<b><font color="#660000">// error</font></b></tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; return list;</tt>
<br><tt>}</tt></blockquote>
We cannot create a temporary copy of the list and cannot access the individual
pairs in the list.&nbsp; Hence we apply the capture-helper technique from
above.
<p>Example (implementation of a <tt>swapAndReverse</tt> method with helper
method; does not work):
<blockquote><tt>public static ArrayList&lt;? extends Pair&lt;?>> swapAndReverse(ArrayList<b><font color="#000099">&lt;?
extends Pair&lt;?>></font></b> l) {</tt>
<br><tt>&nbsp; return capturePairType(l);</tt>
<br><tt>}</tt>
<br><tt>private static <b><font color="#000099">&lt;T extends Pair&lt;?>></font></b>
ArrayList&lt;T> capturePairType(ArrayList<b><font color="#000099">&lt;T></font></b>
l) {</tt>
<br><tt>&nbsp; ArrayList&lt;T> list = new ArrayList&lt;T>(l);</tt>
<br><tt>&nbsp; for (int i=0;i&lt;l.size();i++){</tt>
<br><tt>&nbsp;&nbsp;&nbsp; list.set(i,l.get(l.size()-i-1));</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; for (T pair : list) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Object e = pair.getFirst();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; pair.<b>setFirst</b>(pair.getSecond());
<b><font color="#660000">//
error</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; pair.<b>setSecond</b>(e);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<b><font color="#660000">// error</font></b></tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; return list;</tt>
<br><tt>}</tt></blockquote>
The compiler will capture the type of the pairs contained in the list,
but we still do not know what type of members the pairs have. We can use
the capture-helper technique again to capture the pairs' type argument.
<p>Example (corrected implementation of a <tt>swapAndReverse</tt> method
with wildcards):
<blockquote><tt>public static ArrayList&lt;? extends Pair&lt;?>> swapAndReverse(ArrayList<b><font color="#000099">&lt;?
extends Pair&lt;?>></font></b> l) {</tt>
<br><tt>&nbsp; return capturePairType(l);</tt>
<br><tt>}</tt>
<br><tt>private static <b><font color="#000099">&lt;T extends Pair&lt;?>></font></b>
ArrayList&lt;T> capturePairType(ArrayList<b><font color="#000099">&lt;T></font></b>
l) {</tt>
<br><tt>&nbsp; ArrayList&lt;T> list = new ArrayList&lt;T>(l);</tt>
<br><tt>&nbsp; for (int i=0;i&lt;l.size();i++){</tt>
<br><tt>&nbsp;&nbsp;&nbsp; list.set(i,l.get(l.size()-i-1));</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; for (T pair : list) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; captureMemberType(pair);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; return list;</tt>
<br><tt>}</tt>
<br><tt>private static <b><font color="#000099">&lt;E></font></b> void
captureMemberType(Pair<b><font color="#000099">&lt;E></font></b> pair)
{</tt>
<br><tt>&nbsp; E e = pair.getFirst();</tt>
<br><tt>&nbsp; pair.setFirst(pair.getSecond());</tt>
<br><tt>&nbsp; pair.setSecond(e);</tt>
<br><tt>}</tt></blockquote>
In this case there is no alternative to the stepwise application of the
capture-helper technique.&nbsp; A generic version of the <tt>swapAndReverse</tt>
method would have slightly different semantics.
<p>Example (parameterized version of the <tt>swapAndReverse</tt> method):
<blockquote><tt>public static&nbsp; <b><font color="#000099">&lt;</font><font color="#000000">E</font><font color="#000099">,T
extends Pair</font><font color="#000000">&lt;E></font><font color="#000099">></font></b>
ArrayList&lt;T> swapAndReverse(ArrayList<b><font color="#000099">&lt;T></font></b>
l) {</tt>
<br><tt>&nbsp; ArrayList&lt;T> list = new ArrayList&lt;T>(l);</tt>
<br><tt>&nbsp; for (int i=0;i&lt;l.size();i++){</tt>
<br><tt>&nbsp;&nbsp;&nbsp; list.set(i,l.get(l.size()-i-1));</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; for (T pair : list) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; E e = pair.getFirst();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; pair.setFirst(pair.getSecond());</tt>
<br><tt>&nbsp;&nbsp;&nbsp; pair.setSecond(e);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; return list;</tt>
<br><tt>}</tt></blockquote>
This version of the <tt>swapAndReverse</tt> method has one disadvantage:&nbsp;
it does <i>not</i> accept a mixed list of pairs of arbitrary types, such
as <tt>ArrayList&lt;Pair&lt;?>></tt>.&nbsp;
<p>Example:
<blockquote><tt>class Test {</tt>
<br><tt>&nbsp; public static void main(String[] args) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#000099">ArrayList&lt;Pair&lt;Integer>></font></b>
list = new ArrayList&lt;Pair&lt;Integer>>();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list.add(new Pair&lt;Integer>(-1,1,0));</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list.add(new Pair&lt;Integer>(1,0,0));</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List&lt;?> result =
swapAndReverse(list);</tt>
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#000099">ArrayList&lt;Pair&lt;?>></font></b>
list = new ArrayList&lt;Pair&lt;?>>();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list.add(new Pair&lt;String>("a","b","c"));</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list.add(new Pair&lt;Integer>(1,0,0));</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list.add(new Pair&lt;Object>(new
Date(),Thread.State.NEW,5));</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List&lt;?> result =
swapAndReverse(list);&nbsp; <b><font color="#660000">// error</font></b></tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br>
<hr WIDTH="100%">
<br><tt>error: &lt;E,T>swapAndReverse(java.util.ArrayList&lt;T>) in Test
cannot be applied to (java.util.ArrayList&lt;Pair&lt;?>>)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List&lt;?> result = swapAndReverse(list);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt></blockquote>
On the other hand, the generic <tt>swapAndReverse</tt> method has the advantage
that it returns a concrete instantiation of <tt>ArrayList</tt>, that does
not suffer from the limitations that come with the wildcard instantiation
that is returned from the wildcard version of the <tt>swapAndReverse</tt>
method.&nbsp;</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ305">#FAQ305</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#How do I implement a method that takes a wildcard argument?">How
do I implement a method that takes a wildcard argument?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What do multilevel wildcards mean?">What
do multi-level wildcards mean?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#What is the capture of a wildcard?">What
is the capture of a wildcard?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedMethods.html#What is a parameterized (or generic) method?">What
is a parameterized or generic method?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeParameters.html#What is a bounded type parameter?">What
is a bounded type parameter?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeParameters.html#Which types are permitted as type parameter  bounds?">Which
types are permitted as type parameter&nbsp; bounds?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeParameters.html#Can I use a type parameter as part of its own bounds or in the declaration of other type parameters?">Can
I use a type parameter as part of its own bounds or in the declaration
of other type parameters?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#Can I use a wildcard instantiation like any other type?">Can
I use a wildcard parameterized type like any other type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#Can I create an object whose type is a wildcard instantiation of a parameterized type?">Can
I create an object whose type is a wildcard parameterized type?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ306"></a>
<p><a NAME="I want to pass a U and a X to a method.  How do I correctly declare that method?"></a><b><font face="Arial,Helvetica">I
want to pass a U and a X&lt;U> to a method.&nbsp; How do I correctly declare
that method?</font></b>
<br>&nbsp;
<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Using an upper bound wildcard parameterized
type instead of a concrete parameterized type as the argument type.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Example (has a bug):
<blockquote><tt>interface Acceptor&lt;V> {</tt>
<br><tt>&nbsp; void accept(<b>Task&lt;V></b> task, <b>V</b> v);</tt>
<br><tt>}</tt>
<br><tt>interface Task&lt;U> {</tt>
<br><tt>&nbsp; void go(Acceptor&lt;? super U> acceptor);</tt>
<br><tt>}</tt>
<br><tt>class AcceptingTask&lt;U> implements Task&lt;U> {</tt>
<br><tt>&nbsp; public void go(Acceptor&lt;? super U> acceptor) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; U result = null;&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ... produce result ...&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; acceptor.accept(this, result);&nbsp; <b><font color="#330000">//
error</font></b></tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br>
<hr WIDTH="100%">
<br><tt>error: accept(Task&lt;capture of ? super U>,capture of ? super
U)&nbsp;</tt>
<br><tt>in Acceptor&lt;capture of ? super U> cannot be applied to (AcceptingTask&lt;U>,U)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; acceptor.accept(this,
result);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt></blockquote>
This is the example of a callback interface <tt>Acceptor</tt> and its <tt>accept</tt>
method which takes&nbsp; result-producing task and the result. Note that
the <tt>accept</tt> method takes a result of type<tt> V </tt>and a corresponding
task of type <tt>Task&lt;V></tt>.
<p>The task is described by an interface <tt>Task</tt>.&nbsp; It has a
method <tt>go</tt> that is supposed to produce a result and takes an <tt>Acceptor</tt>,
to which it passes the result.
<p>The class <tt>AcceptingTask</tt> is an implementation of the <tt>Task</tt>
interface and in its implementation of the <tt>go</tt> method we see an
invocation of the <tt>accept</tt> method.&nbsp; This invocation fails.
<p>The problem with this invocation is that the <tt>accept</tt> method
is invoked on a wildcard instantiation of the <tt>Acceptor</tt>, namely
<tt>Acceptor&lt;?
super U></tt>.&nbsp; Access to methods through wildcard parameterized types
is restricted.&nbsp; The error message clearly indicates the problem.&nbsp;
Method <tt>accept</tt> in&nbsp; <tt>Acceptor&lt;? super U> </tt>expects
a <tt>Task&lt;capture of ? super U> </tt>and a <tt>capture of ? super U</tt>.
What we pass as arguments are a <tt>AcceptingTask&lt;U>
</tt>and a <tt>U</tt>.&nbsp;
The argument of type <tt>U</tt> is fine because the declared argument type
is an unknown supertype of <tt>U</tt>.&nbsp; But the argument of type <tt>AcceptingTask&lt;U>
</tt>is
a problem. The declared argument type is an instantiation of <tt>Task</tt>
for an unknown supertype of <tt>U</tt>. The compiler does not know which
supertype and therefor rejects all argument types.
<p>The crux is that the signature of the accept method is too restrictive.
If we would permit instantiations of <tt>Task</tt> for subtypes of <tt>U</tt>,
then it would work.&nbsp;
<p>Example (corrected):
<blockquote><tt>interface Acceptor&lt;V> {</tt>
<br><tt>&nbsp; void accept(<b>Task&lt;<font color="#3333FF">? extends</font>
V></b> task, <b>V</b> v);</tt>
<br><tt>}</tt>
<br><tt>interface Task&lt;U> {</tt>
<br><tt>&nbsp; void go(Acceptor&lt;? super U> acceptor);</tt>
<br><tt>}</tt>
<br><tt>class AcceptingTask&lt;U> implements Task&lt;U> {</tt>
<br><tt>&nbsp; public void go(Acceptor&lt;? super U> acceptor) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; U result = null;&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ... produce result ...&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; acceptor.accept(this, result);&nbsp; <b><font color="#003300">//
fine</font></b></tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
With this relaxed signature the <tt>accept</tt> method&nbsp; in&nbsp; <tt>Acceptor&lt;?
super U> </tt>expects a <tt>Task&lt;? extends capture of ? super U></tt>,
that is, an instantiation of <tt>Task</tt> for a subtype of a supertype
of <tt>U </tt>and <tt>Task&lt;U></tt> meets this requirement.
<p>The common misunderstanding here is that the signature <tt>accept(Task&lt;V>
task, V v) looks</tt> that I can pass a <tt>Task&lt;U></tt> whenever I
can pass a <tt>U</tt>.&nbsp; This is true for concrete instantiations of
the enclosing type, but not when wildcard instantiations are used.&nbsp;
The accessibility rules for methods that take the type parameter such as
<tt>V</tt>
as an argument and methods that take a parameterized type instantiated
on the type parameter such as <tt>Task&lt;V> </tt>are very different.
<p>The solution to the problem is relaxing the signature by using a wildcard
parameterized type as an argument type instead of a concrete parameterized
type.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ306">#FAQ306</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#Which methods and fields are accessible/inaccessible through a reference variable of a wildcard type?">Which
methods and fields are accessible/inaccessible through a reference variable
of a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#Which methods that use the type parameter in the argument or return type are accessible in an unbounded wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in an unbounded wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#Which methods that use the type parameter in the argument or return type are accessible in an upper bound wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in an upper bound wildcard parmeterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#Which methods that use the type parameter in the argument or return type are accessible in a lower bound wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in a lower bound wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#Which methods that use the type parameter as type argument of a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as type argument of a parameterized
argument or return type are accessible in a wildcard parameteriezed type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#Which methods that use the type parameter as upper wildcard bound in a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as upper wildcard bound in a parameterized
argument or return type are accessible in a wildcard instantiation?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#Which methods that use the type parameter as lower wildcard bound in a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as lower wildcard bound in a parameterized
argument or return type are accessible in a wildcard instantiation?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#In a wildcard instantiation, can I read and write fields whose type is the type parameter?">In
a wildcard instantiation, can I read and write fields whose type is the
type parameter?&nbsp;</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350>
<br>&nbsp;
<br>&nbsp;
<h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450></h3>

<h3>
<a NAME="Working With Parameterized Interfaces"></a>Working With Generic
Interfaces</h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450><a NAME="FAQ401"></a>
<p><a NAME="Can a class implement different instantiations of the same parameterized interface?"></a><b><font face="Arial,Helvetica"><font size=+0>Can
a class implement different instantiations of the same generic interface?</font></font></b>
<br>&nbsp;
<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>No, a type must not directly or indirectly
derive from two different instantiations of the same generic interface.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">The reason for this restriction is the translation by type
erasure. After type erasure the different instantiations of the same generic
interface collapse to the same raw type.&nbsp; At runtime there is no distinction
between the different instantiations any longer.&nbsp;
<p>Example (of illegal subtyping from two instantiations of the same generic
interface):
<blockquote><tt>class X implements <b><font color="#006600">Comparable&lt;X></font></b>,<b><font color="#006600">Comparable&lt;String></font></b>
{&nbsp; <b><font color="#330000">// error</font></b></tt>
<br><tt>&nbsp; public int compareTo(X arg)&nbsp;&nbsp;&nbsp;&nbsp; { ...
}</tt>
<br><tt>&nbsp; public int compareTo(String arg) { ... }</tt>
<br><tt>}</tt></blockquote>
During type erasure the compiler would not only remove the type arguments
of the two instantiations of <tt>Comparable</tt>, it would also try to
create the necessary bridge methods. Bridge methods are synthetic methods
generated by the compiler; they are needed when a class has a parameterized
supertype.
<p>Example (same as above, after a conceivable translation by type erasure):
<blockquote><tt>class X implements <b><font color="#660000">Comparable</font></b>,<b><font color="#660000">Comparable</font></b>
{&nbsp;</tt>
<br><tt>&nbsp; public int compareTo(X arg)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{ ... }</tt>
<br><tt>&nbsp; public int compareTo(String arg) { ... }</tt>
<br><tt>&nbsp; <b><font color="#660000">public int compareTo(Object arg)
{ return compareTo((X)arg); }</font></b></tt>
<br><b><tt><font color="#660000">&nbsp; public int compareTo(Object arg)
{ return compareTo((String)arg); }</font></tt></b>
<br><tt>}&nbsp;</tt></blockquote>
The bridge method generation mechanism cannot handle this.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ401">#FAQ401</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#What is type erasure?">What
is type erasure?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#What is a bridge method?">What
is a bridge method?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeParameters.html#Can I use different instantiations of a same parameterized type as bounds of a type parameter?">Can
I use different instantiations of a same generic type as bounds of a type
parameter?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Can a class implement different instantiations of the same parameterized interface?">Can
a subclass implement another instantiation of a generic interface than
any of its superclasses does?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#What happens if a class implements two parameterized interfaces that define the same method?">What
happens if a class implements two parameterized interfaces that define
the same method?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ402"></a>
<p><a NAME="Can a subclass implement another instantiation of a parameterized interface than any of its superclasses does?"></a><b><font face="Arial,Helvetica"><font size=+0>Can
a subclass implement a different instantiation of a generic interface than
any of its superclasses does?</font></font></b>
<br>&nbsp;
<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>No, the superclass determines which instantiation
of a generic interface the entire class hierarchy must implement.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Example:
<blockquote><tt>class Person implements Comparable&lt;Person> {</tt>
<br><tt>&nbsp; public int compareTo(Person arg) { ... }</tt>
<br><tt>}</tt>
<br><tt>class Student extends Person implements Comparable&lt;Student>
{&nbsp; // error</tt>
<br><tt>&nbsp; public int compareTo(Student arg) { ... }</tt>
<br><tt>}</tt>
<br>
<hr WIDTH="100%">
<br><tt>error: java.lang.Comparable cannot be inherited with different
arguments: &lt;Student> and &lt;Person></tt>
<br><tt>&nbsp;&nbsp;&nbsp; class Student extends Person implements Comparable&lt;Student>
{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ^</tt></blockquote>
The <tt>Student</tt> subclass would be implementing two different instantiations
of the generic <tt>Comparable</tt> interface, which is illegal.&nbsp; The
consequence is that a superclass that implement a certain instantiation
of a generic interface determines for all its subclasses which instantiation
of the interface they must implement.&nbsp; No subclass can ever implement
another instantiation of the generic interface.
<br>&nbsp;
<blockquote><img SRC="../Diagrams/paraminterfaces.jpg" NOSAVE height=151 width=250></blockquote>

<p><br>This consequence makes proper use of generic interfaces fairly challenging.&nbsp;
Here is another example of the effect, using the <tt>Delayed</tt> interface
from the
<tt><a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/package-summary.html">java.util.concurrent</a></tt>
package.
<p>Example (interface <tt>java.util.concurrcent.Delayed</tt>):
<blockquote><tt>public interface Delayed extends Comparable&lt;Delayed>
{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long getDelay(TimeUnit unit);</tt>
<br><tt>}</tt></blockquote>
The <tt>Delayed</tt> interface is a sub-interface of an instantiation of
the <tt>Comparable</tt> interface and thereby takes away the chance that
any implementing class can ever be comparable to anything else but a <tt>Delayed</tt>
object.
<p>Example:
<blockquote><tt>class SomeClass implements Delayed, Comparable&lt;SomeClass>
{&nbsp; // error&nbsp;</tt>
<br><tt>&nbsp; public long getDelay(TimeUnit unit)&nbsp;&nbsp; { ... }</tt>
<br><tt>&nbsp; public int compareTo(Delayed other)&nbsp;&nbsp; { ... }</tt>
<br><tt>&nbsp; public int compareTo(SomeClass other) { ... }</tt>
<br><tt>}</tt>
<br>
<hr WIDTH="100%"><tt>error: java.lang.Comparable cannot be inherited with
different arguments: &lt;java.util.concurrent.Delayed> and &lt;SomeClass></tt>
<br><tt>&nbsp;&nbsp;&nbsp; class SomeClass implements Delayed, Comparable&lt;SomeClass>
{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ^</tt></blockquote>
</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ402">#FAQ402</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#Can a class implement different instantiations of the same parameterized interface?">Can
a class implement different instantiations of the same generic interface?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ403"></a>
<p><a NAME="What happens if a class implements two parameterized interfaces that define the same method?"></a><b><font face="Arial,Helvetica"><font size=+0>What
happens if a class implements two parameterized interfaces that both define
a method with the same name?</font></font></b>
<br>&nbsp;
<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>If the two method have the same erasure
then the class is illegal and rejected with a compile-time error message.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">If, after type erasure, two inherited methods happen to
have the same erasure, then the compiler issues an error message.
<p>Example (of illegal class definition; before type erasure):
<blockquote><tt>interface Equivalent<b>&lt;T></b> {</tt>
<br><tt>&nbsp; <b><font color="#000099">boolean equalTo(T other);</font></b></tt>
<br><tt>}</tt>
<br><tt>interface EqualityComparable<b>&lt;T></b> {</tt>
<br><tt>&nbsp; <b><font color="#000099">boolean equalTo(T other);</font></b></tt>
<br><tt>}</tt>
<br><tt>class SomeClass implements Equivalent<b>&lt;Double>, </b>EqualityComparable<b>&lt;SomeClass></b>
{&nbsp; <font color="#660000">// <b>error</b></font></tt>
<br><tt>&nbsp; public boolean equalTo(Double other) { ... }</tt>
<br><tt>&nbsp; public boolean equalTo(SomeClass other) { ... }</tt>
<br><tt>}</tt>
<br>
<hr WIDTH="100%">
<br><tt>error: name clash: equalTo(T) in EqualityComparable&lt;SomeClass>
and equalTo(T) in Equivalent&lt;java.lang.String> have the same erasure,
yet neither overrides the other</tt>
<br><tt>&nbsp;&nbsp;&nbsp; class SomeClass implements EqualityComparable&lt;SomeClass>,
Equivalent&lt;Double> {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ^</tt></blockquote>
During type erasure the compiler does not only create the type erased versions
of the two colliding interfaces, it would also try to create the necessary
bridge methods.&nbsp; Bridge methods are synthetic methods generated by
the compiler when a class has a parameterized supertype.
<p>Example (after a conceivable translation by type erasure):
<blockquote><tt><font color="#000000">interface Equivalent {</font></tt>
<br><tt><font color="#000000">&nbsp; boolean equalTo(</font><b><font color="#330033">Object</font></b><font color="#000000">
other);</font></tt>
<br><tt><font color="#000000">}</font></tt>
<br><tt>int<font color="#000000">erface EqualityComparable {</font></tt>
<br><tt><font color="#000000">&nbsp; boolean equalTo(</font><b><font color="#330033">Object</font></b><font color="#000000">
other);</font></tt>
<br><tt><font color="#000000">}</font></tt>
<br><tt><font color="#000000">class SomeClass implements Equivalent, EqualityComparable
{</font></tt>
<br><tt><font color="#000000">&nbsp; public boolean equalTo(Double other)&nbsp;&nbsp;&nbsp;
{ ... }</font></tt>
<br><b><tt><font color="#660000">&nbsp; public boolean equalTo(Object other)&nbsp;&nbsp;&nbsp;
{ return equalTo((Double)other); }</font></tt></b>
<br><tt>&nbsp; public boolean equalTo(SomeClass other) { ... }</tt>
<br><b><tt><font color="#660000">&nbsp; public boolean equalTo(Object other)&nbsp;&nbsp;&nbsp;
{ return equalTo((SomeClass)other); }</font></tt></b>
<br><tt>}</tt></blockquote>
The bridge methods would have the same signature. Instead of resolving
the conflict the compiler reports an error.
<p>By the way, the problem is <i>not</i> that the class has several overloaded
versions of the <tt>equalTo</tt> method.&nbsp; The problem stems from the
fact that the interfaces are generic and the methods have the same type
erasure.&nbsp; No problem occurs when the two interfaces have no type parameter.
<p>Example (of legal class definition):
<blockquote><tt><font color="#000000">interface Equivalent {</font></tt>
<br><tt><font color="#000000">&nbsp; boolean equalTo(<b>Double</b> other);</font></tt>
<br><tt>}</tt>
<br><tt>interf<font color="#000000">ace EqualityComparable {</font></tt>
<br><tt><font color="#000000">&nbsp; boolean equalTo(<b>SomeClass</b> other);</font></tt>
<br><tt><font color="#000000">}</font></tt>
<br><tt>class SomeClass implements Equivalent, EqualityComparable {</tt>
<br><tt>&nbsp; public boolean equalTo(Double other) { ... }</tt>
<br><tt>&nbsp; public boolean equalTo(SomeClass other) { ... }</tt>
<br><tt>}</tt></blockquote>
In the example above the compiler need not generate any bridge methods
because the interfaces are not generic.
<p>Note, that there is no problem if the two interfaces are generic and
the conflicting methods have <i>different type erasures</i>.
<p>Example (of legal class definition):
<blockquote><tt>interface Equivalent<b>&lt;T extends Number></b> {</tt>
<br><tt>&nbsp; <b><font color="#000099">boolean equalTo(T other);</font></b></tt>
<br><tt>}</tt>
<br><tt>interface EqualityComparable<b>&lt;T></b> {</tt>
<br><tt>&nbsp; <b><font color="#000099">boolean equalTo(T other);</font></b></tt>
<br><tt>}</tt>
<br><tt>class SomeClass implements Equivalent<b>&lt;Double>, </b>EqualityComparable<b>&lt;SomeClass></b>
{</tt>
<br><tt>&nbsp; public boolean equalTo(Double other) { ... }</tt>
<br><tt>&nbsp; public boolean equalTo(SomeClass other) { ... }</tt>
<br><tt>}</tt></blockquote>
Example (after a conceivable translation by type erasure):
<blockquote><tt><font color="#000000">interface Equivalent {</font></tt>
<br><tt><font color="#000000">&nbsp; boolean equalTo(</font><b><font color="#330033">Number</font></b><font color="#000000">
other);</font></tt>
<br><tt><font color="#000000">}</font></tt>
<br><tt>int<font color="#000000">erface EqualityComparable {</font></tt>
<br><tt><font color="#000000">&nbsp; boolean equalTo(</font><b><font color="#330033">Object</font></b><font color="#000000">
other);</font></tt>
<br><tt><font color="#000000">}</font></tt>
<br><tt><font color="#000000">class SomeClass implements Equivalent, EqualityComparable
{</font></tt>
<br><tt><font color="#000000">&nbsp; public boolean equalTo(Double other)&nbsp;&nbsp;&nbsp;
{ ... }</font></tt>
<br><b><tt><font color="#660000">&nbsp; </font><font color="#330033">public
boolean equalTo(Number other)&nbsp;&nbsp;&nbsp; { return equalTo((Double)other);
}</font></tt></b>
<br><tt>&nbsp; public boolean equalTo(SomeClass other) { ... }</tt>
<br><b><tt><font color="#660000">&nbsp; </font><font color="#330033">public
boolean equalTo(Object other)&nbsp;&nbsp;&nbsp; { return equalTo((SomeClass)other);
}</font></tt></b>
<br><tt>}</tt></blockquote>
The two <tt>equalTo</tt> methods have different erasures and then the bridge
method generation mechanism create two bridge methods with different signatures
and no problem occurs.
<p>Effects similar to ones illustrated above can be observed with a parameterized
superclass and a parameterized interface if they have a method with the
same type erasure.
<p>Last but not least, a legal way of implementing two interfaces with
methods that have the same type erasure: as long as the colliding methods
are instantiated for the same type argument there is no problem at all.
<p>Example (of legal class definition):
<blockquote><tt>class SomeClass implements Equivalent<b>&lt;SomeClass>,
</b>EqualityComparable<b>&lt;SomeClass></b>
{</tt>
<br><tt>&nbsp; public boolean equalTo(SomeClass other) <font color="#000000">{
... }</font></tt>
<br><tt>}</tt></blockquote>
The class provide exactly one method, namely the matching one from both
interfaces and the compiler generates one synthetic bridge method.&nbsp;
No problem.
<p>Example (after type erasure):
<blockquote><tt>class SomeClass implements Equivalent<b>, </b>EqualityComparable
{</tt>
<br><tt>&nbsp; public boolean equalTo(SomeClass other) <font color="#000000">{
... }</font></tt>
<br><b><tt><font color="#660000">&nbsp; </font><font color="#330033">public
boolean equalTo(Object other)&nbsp;&nbsp;&nbsp; { return equalTo((SomeClass)other);
}</font></tt></b>
<br><tt>}</tt></blockquote>
</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ403">#FAQ403</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#What is type erasure?">What
is type erasure?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#What is a bridge method?">What
is a bridge method?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ404"></a>
<h2>
<a NAME="Can an interface type nested into a parameterized type use the enclosing type's type parameters?"></a><font face="Arial,Helvetica"><font size=+0>Can
an interface type nested into a generic type use the enclosing type's type
parameters?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>No, but as workaround you can generify
the nested interface itself.&nbsp;</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Nested interfaces are implicitly static. This is sometimes
overlooked because the interface looks like it were a non-static member
of its enclosing class, while in fact it is static. Since type parameters
must not be used in any static context of a generic type, a nested interface
cannot use its enclosing type's type parameters.
<p>Example (of a nested interface):
<blockquote><tt>interface Action {&nbsp;</tt>
<br><tt>&nbsp; void run();</tt>
<br><tt>}&nbsp;</tt>
<br><tt>final class SomeAction implements Action {</tt>
<br><tt>&nbsp; public void run() { … }</tt>
<br><tt>}</tt>
<br><tt>final class Controller<b><font color="#000000">&lt;A extends Action></font></b>{</tt>
<br><tt>&nbsp; public interface Command {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; void doIt(<b><font color="#330000">A</font></b>
action);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b><font color="#330000">// error</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; void undoIt(<b><font color="#330000">A</font></b>
action);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b><font color="#330000">// error</font></b></tt>
<br><tt>&nbsp; }&nbsp;</tt>
<br><tt>&nbsp; …&nbsp;</tt>
<br><tt>}</tt>
<br>
<hr WIDTH="100%"><tt>error: non-static class A cannot be referenced from
a static context</tt>
<br><tt>&nbsp;&nbsp; void doIt(A action);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>error: non-static class A cannot be referenced from a static context</tt>
<br><tt>&nbsp;&nbsp; void undoIt(A action);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt></blockquote>
The <tt>Command</tt> interface is nested into the generic <tt>Controller</tt>
class.&nbsp; Inside the nested interface we cannot refer to the&nbsp; type
parameter <tt>A</tt> of the enclosing class, because the nested interface
is implicitly static and type parameters must not appear in any static
context.&nbsp;
<p>So, how do we express that the <tt>Command</tt> interface mandates do/undo
methods for different types of actions?&nbsp; The solution is to generify
the interface itself independently of the generic enclosing class.
<p>Example (same as above, but corrected):
<blockquote><tt>interface Action {&nbsp;</tt>
<br><tt>&nbsp; void run();</tt>
<br><tt>}&nbsp;</tt>
<br><tt>final class SomeAction implements Action {</tt>
<br><tt>&nbsp; public void run() { … }</tt>
<br><tt>}</tt>
<br><tt>final class Controller<b><font color="#000000">&lt;A extends Action></font></b>
{</tt>
<br><tt>&nbsp; public interface Command<font color="#000099"><b>&lt;B extends
Action></b>&nbsp;</font> {&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; void doIt(B action);&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; void undoIt(B action);&nbsp;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; …&nbsp;</tt>
<br><tt>}</tt></blockquote>
</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ404">#FAQ404</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="TypeParameters.html#Why can't I use a type parameter in any static context of the parameterized class?">Why
can't I use a type parameter in any static context of the generic class?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#How do I refer to an interface type nested into a parameterized type?">How
do I refer to an interface type nested into a generic type?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350>
<h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450></h3>

<h3>
<a NAME="Implementing Infrastructure Methods"></a>Implementing Infrastructure
Methods</h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450><a NAME="FAQ501"></a>
<h2>
<a NAME="How do I best implement the equals method of a parameterized type?"></a><font face="Arial,Helvetica"><font size=+0>How
do I best implement the equals method of a generic type?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Override <tt>Object.equals(Object)</tt>as
usual and perform the type check using the unbounded wildcard instantiation.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">The recommended implementation of the <tt>equals</tt> method
of a generic type looks like the one shown in the example below.&nbsp;
Conceivable alternatives are discussed and evaluated later.
<p>Example (recommended implementation of <tt>equals</tt>):
<blockquote><tt>class Triple&lt;T> {</tt>
<br><tt>&nbsp; private T fst, <font color="#000000">snd, trd;</font></tt>
<br><tt><font color="#000000">&nbsp; public Triple(T t1, T t2, T t3) {fst
= t1; snd = t2; trd = t3;}</font></tt>
<br><tt><font color="#000000">&nbsp; ...</font></tt>
<br><tt><font color="#000000">&nbsp; public boolean equals(<b>Object</b>
other) {</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; if (this == other) return
true;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; if (other == null) return
false;&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; if (this.getClass() !=
other.getClass()) return false;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; </font><b><font color="#000066">Triple&lt;?></font></b><font color="#000000">
otherTriple = </font><b><font color="#000099">(Triple&lt;?>)</font></b><font color="#000000">other;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; return (this.fst.equals(otherTri</font>ple.fst)&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; this.snd.equals(otherTriple.snd)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; this.trd.equals(otherTriple.trd));</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
Perhaps the greatest difficulty is the downcast to the triple type, after
the check for type match has been passed successfully.&nbsp; The most natural
approach would be a cast to <tt>Triple&lt;T></tt>, because only objects
of the same type are comparable to each other.&nbsp;
<p>Example (not recommended):
<blockquote><tt>class Triple&lt;T> {</tt>
<br><tt>&nbsp; private T fst, <font color="#000000">snd, trd;</font></tt>
<br><tt><font color="#000000">&nbsp; public Triple(T t1, T t2, T t3) {fst
= t1; snd = t2; trd = t3;}</font></tt>
<br><tt>&nbsp; ...</tt>
<br><tt>&nbsp; public boolean equals<font color="#000000">(Object other)
{</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; if (this == other) return
true;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; if (other == null) return
false;&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; if (this.getClass() !=
other.getClass()) return false;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; </font><b><font color="#000066">Triple&lt;T></font></b><font color="#000000">otherTriple
= </font><b><font color="#000099">(Triple&lt;T>)</font></b>other;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<b><font color="#666600">// unchecked warning</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; return (this.fst.equals(otherTri</font>ple.fst)&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; this.snd.equals(otherTriple.snd)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; this.trd.equals(otherTriple.trd));</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
The cast to <tt>Triple&lt;T></tt> results in an "unchecked cast" warning,
because the target type of the cast is a parameterized type.&nbsp; Only
the cast to <tt>Triple&lt;?></tt> is accepted without a warning. Let us
try out a cast to <tt>Triple&lt;?></tt> instead of <tt>Triple&lt;T></tt>.&nbsp;
<p>Example (better, but does not compile):
<blockquote><tt>class Triple&lt;T> {</tt>
<br><tt>&nbsp; private T fst, <font color="#000000">snd, trd;</font></tt>
<br><tt><font color="#000000">&nbsp; public Triple(T t1, T t2, T t3) {fst
= t1; snd = t2; trd = t3;}</font></tt>
<br><tt>&nbsp; ...</tt>
<br><tt>&nbsp; public boolean equals<font color="#000000">(Object other)
{</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; if (this == other) return
true;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; if (other == null) return
false;&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; if (this.getClass() !=
other.getClass()) return false;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; </font><b><font color="#000066">Triple&lt;T></font></b><font color="#000000">
otherTriple =
</font><b><font color="#000099">(Triple&lt;?>)</font></b>other;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<b><font color="#330000">// error</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; return (this.fst.equals(otherTri</font>ple.fst)&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; this.snd.equals(otherTriple.snd)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; this.trd.equals(otherTriple.trd));</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br>
<hr WIDTH="100%">
<br><tt>error: incompatible types</tt>
<br><tt>found&nbsp;&nbsp; : Triple&lt;capture of ?></tt>
<br><tt>required: Triple&lt;T></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Triple&lt;T> otherTriple = (Triple&lt;?>)other;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt></blockquote>
This implementation avoids the"unchecked" cast, but does not compile because
the compiler refuses to assign a <tt>Triple&lt;?> </tt>to a <tt>Triple&lt;T></tt>.&nbsp;
This is because the compiler cannot ensure that the unbounded wildcard
parameterized type <tt>Triple&lt;?> </tt>matches the concrete parameterized
type
<tt>Triple&lt;T></tt>.&nbsp; To make it compile we have to change
the type of the local variable <tt>otherTriple</tt> from <tt>Triple&lt;T>&nbsp;</tt>
to <tt>Triple&lt;?></tt>. This change leads us to the first implementation
shown in this FAQ entry, which is the recommended way of implementing the
<tt>equals</tt>
method of a generic type.
<br>&nbsp;
<p><b>Evaluation of the alternative implementations.</b>
<p>How do the two alternative implementations, the recommended one casting
to <tt>Triple&lt;?> </tt>and the not recommended one casting to <tt>Triple&lt;T></tt>,
compare?&nbsp; The recommended implementation compiles without warnings,
which is clearly preferable when we strive for warning-free compilation
of our programs.&nbsp; Otherwise there is no difference in functionality
or behavior, despite of the different cast expressions in the source code.&nbsp;
At runtime both casts boils down to a cast to the raw type <tt>Triple</tt>.&nbsp;
<p>If there is no difference in functionality and behavior and one of the
implementations raises a warning, isn't there a type-safety problem? After
all, "unchecked" warnings are issued to alert the programmer to potentially
unsafe code.&nbsp; It turns out that in this particular cases all is fine.&nbsp;
Let us see why.
<p>With both implementations of <tt>equals</tt> it might happen that triples
of different member types, like a <tt>Triple&lt;String>
</tt>and a <tt>Triple&lt;Number></tt>,&nbsp;
pass the check for type match via <tt>getClass()</tt> and the cast to <tt>Triple&lt;?>
</tt>(or
<tt>Triple&lt;T></tt>).
We would then compare&nbsp; members of different type with each other.
For instance, if a <tt>Triple&lt;String>
</tt>and a <tt>Triple&lt;Number>
</tt>are
compared, they would pass the type check, because they are both triples
and we would eventually compare the <tt>Number</tt> members with the <tt>String
</tt>members.&nbsp;
Fortunately, the comparison of a <tt>String</tt> and a <tt>Number</tt>
always yields <tt>false</tt>, because both <tt>String.equals</tt> and <tt>Number.equals</tt>&nbsp;
return
<tt>false</tt> in case of comparison with an object of an imcompatible
type.
<p>In general, every implementation of an <tt>equals</tt> method is responsible
for performing a check for type match and to return <tt>false</tt> in case
of mismach.&nbsp; This rule is still valid, even in the presence of Java
generics, because the signature of <tt>equals</tt> is still the same as
in pre-generic Java: the <tt>equals</tt> method takes an <tt>Object</tt>
as an argument. Hence, the argument can be of any reference type and the
implementation of <tt>equals</tt> must check whether the argument is of
an acceptable type so that the actual comparison for equality makes sense
and can be performed.&nbsp;
<br>&nbsp;
<p><b>Yet another alternative.</b>
<p>It might seem natural to provide an <tt>equals</tt> method that has
a more specific signature, such as a version of<tt> equals</tt> in class
<tt>Triple</tt>
that takes a <tt>Triple&lt;T></tt> as an argument. This way we would not
need a type check in the first place.&nbsp; The crux is that a version
of<tt> equals</tt> that takes a <tt>Triple&lt;T></tt> as an argument would
not be an overriding version of <tt>Object.equals(Object)</tt>, because
the <tt>equals</tt> method in <tt>Object</tt> is not generic and the compiler
would not generate the necessary bridge methods.&nbsp; We would have to
provide the bridge method ourselves, which again would result in an "unchecked"
warning.
<p>Example (not recommended):
<blockquote><tt>class Triple&lt;T> {</tt>
<br><tt>&nbsp; private T fst, <font color="#000000">snd, trd;</font></tt>
<br><tt><font color="#000000">&nbsp; public Triple(T t1, T t2, T t3) {fst
= t1; snd = t2; trd = t3;}</font></tt>
<br><tt>&nbsp; ...</tt>
<br><tt>&nbsp; public boolean equals<font color="#000000">(<b>Triple&lt;T></b>
other) {</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; if (this == other) return
true;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; if (other == null) return
false;&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; return (this.fst.equals(other</font>.fst)&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; this.snd.equals(other.snd)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; this.trd.equals(other.trd));</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; <b><font color="#000000">public boolean equals(Object other)
{</font></b></tt>
<br><tt><font color="#000000"><b>&nbsp;&nbsp;&nbsp; return equals((Triple&lt;?>)
other);</b>&nbsp;</font>&nbsp;&nbsp; <b><font color="#666600">// unchecked
warning</font></b></tt>
<br><tt>&nbsp;<font color="#000000"> <b>}</b></font></tt>
<br><tt>}</tt></blockquote>
This implementation has the flaw of raising an "unchecked" warning and
offers no advantage of the recommended implementation to make up for this
flaw.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ501">#FAQ501</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#What is a bridge method?">What
is a bridge method?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#What is an unchecked warning?">What
is an "unchecked" warning?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#What is the capture of a wildcard?">What
is the capture of a wildcard?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#What is a wildcard capture assignment-compatible to?">What
is a wildcard capture assignment-compatible to?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ502"></a>
<h2>
<a NAME="How do I best implement the clone method of a parameterized type"></a><font face="Arial,Helvetica"><font size=+0>How
do I best implement the clone method of a generic type?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Override <tt>Object.clone()</tt> as usual
and ignore the inevitable unchecked warnings.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">The recommended implementation of the <tt>clone</tt> method
of a generic type looks like the one shown in the example below.&nbsp;
<p>Example (implementation of <tt>clone</tt>):
<blockquote><tt><nobr>class Triple&lt;T> implements Cloneable {</nobr></tt>
<br><tt><nobr>&nbsp; private T fst, <font color="#000000">snd, trd;</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp; public Triple(T t1, T t2, T
t3) {fst = t1; snd = t2; trd = t3;}</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp; ...</font></nobr></tt>
<br><tt><nobr>&nbsp; public <b><font color="#000099">Triple&lt;T></font></b>
clone() {</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; Triple&lt;T> clon = null;</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; try {&nbsp;</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clon = <b><font color="#660000">(Triple&lt;T>)</font></b>super.clone();
</nobr><b><font color="#666600">//
unchecked warning</font></b></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; } catch (CloneNotSupportedException
e) {&nbsp;</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new InternalError();&nbsp;</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; }</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; try {&nbsp;</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class&lt;?> clzz = this.fst.getClass();</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Method&nbsp;&nbsp; meth
= clzz.getMethod("clone", new Class[0]);</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object&nbsp;&nbsp; dupl
= meth.invoke(this.fst, new Object[0]);</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clon.fst = <b><font color="#660000">(T)</font></b>dupl;
</nobr><b><font color="#666600">//
unchecked warning</font></b></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; } catch (Exception e) {</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; }</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; try {</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class&lt;?> clzz = this.snd.getClass();</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Method&nbsp;&nbsp; meth
= clzz.getMethod("clone", new Class[0]);</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object&nbsp;&nbsp; dupl
= meth.invoke(this.snd, new Object[0]);</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clon.snd = <b><font color="#660000">(T)</font></b>dupl;
</nobr><b><font color="#666600">//
unchecked warning</font></b></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; } catch (Exception e) {</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; }</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; try {</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class&lt;?> clzz = this.trd.getClass();</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Method&nbsp;&nbsp; meth
= clzz.getMethod("clone", new Class[0]);</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object&nbsp;&nbsp; dupl
= meth.invoke(this.trd, new Object[0]);</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clon.trd = <b><font color="#660000">(T)</font></b>dupl;
</nobr><b><font color="#666600">//
unchecked warning</font></b></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; } catch (Exception e) {</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; }</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; return clon;</nobr></tt>
<br><tt><nobr>&nbsp; }</nobr></tt>
<br><tt><nobr>}</nobr></tt></blockquote>
<i>Return type.</i>
<p>In our implementation we declared the return type of the <tt>clone</tt>
method not as type <tt>Object</tt>, but of the more specific generic type.&nbsp;
This is possible, since the overriding rules have been relaxed and an overriding
method in a subclass need no longer have the exact same signature as the
superclass's method that it overrides.&nbsp; Since Java 5.0 it is permitted
that the subclass version of a method returns a type that is a subtype
of the return type of the superclass's method. In our example, the method
<tt>clone</tt> in class <tt>Triple&lt;T></tt> returns a <tt>Triple&lt;T></tt>
and overrides the <tt>clone</tt> method in class
<tt>Object</tt>, which
returns an <tt>Object</tt>.
<p>The more specific return type is largely a matter of taste.&nbsp; One
might equally well stick to the traditional technique of declaring the
return type of all <tt>clone</tt> methods as type <tt>Object</tt>.&nbsp;
The more specific return type is beneficial for the users of our triple
class, because it saves them a cast from <tt>Object</tt> down to <tt>Triple&lt;T></tt>
after a call to <tt>Triple&lt;T>.clone</tt>.
<p><i>"unchecked cast" warnings.</i>
<p>The most annoying aspect of implementing <tt>clone</tt> for a generic
type are the inevitable "unchecked" warnings. The warning stem from two
categories of casts that are needed.
<ul>
<li>
Casting the result of <tt>super.clone</tt> to the generic type.</li>

<li>
Casting the result of cloning any fields to the type that the type parameter
stands for.</li>
</ul>
<i>Casting the result of super.clone to the generic type.</i>
<p>Part of every implementation of <tt>clone</tt> is the invocation of
the superclass's <tt>clone</tt> method.&nbsp; The result of <tt>super.clone</tt>
is either of the supertype itself or of type <tt>Object</tt>. In our example
<tt>super.clone</tt>
is <tt>Object.clone</tt>, whose return type is <tt>Object</tt>.&nbsp; In
order to access the fields of the clone returned from <tt>super.clone</tt>
a cast to own type is needed. In our example this is a cast to the type
<tt>Triple&lt;T></tt>.
The target type of this cast is the generic type itself and the compiler
issues the usual "unchecked cast" warning.&nbsp;
<p>In some cases the cast is not needed at all, namely when the clone produced
by <tt>super.clone</tt> is already deep enough so that the fields of the
clone need not be accessed.&nbsp; This would be the case if all fields
are either of primitive type or of an immutable reference type.
<p>In all other cases, there is no way to avoid the unchecked warning.
A cast to <tt>Triple&lt;?></tt> instead of <tt>Triple&lt;T></tt> would
eliminate the unchecked warning, but does not give the required access
to the fields. The two fields in our example would be of type "capture
of ?" to which we cannot assign the result of&nbsp; cloning the individual
fields. Alternatively we might consider a cast to the raw type <tt>Triple
</tt>instead
of <tt>Triple&lt;T></tt>, but that would give us "unchecked assignment"
warnings instead of "unchecked cast" warnings.&nbsp; The compiler would
issue the warnings when we access the fields of our raw triple class.&nbsp;
No matter how we put it, we cannot avoid the unchecked warnings the cast
after <tt>super.clone</tt>.&nbsp; The warnings are harmless and hence best
suppressed by means of the standard annotation <tt>@annotation.SuppressWarnings</tt>.
<p><i>Cloning the individual fields.</i>
<p>We must invoke the fields' clone method via reflection because we do
not know whether the respective field has an accessible <tt>clone</tt>
method.&nbsp; Two factor play a role:
<ul>
<li>
Every class inherits a <tt>clone</tt> method from class <tt>Object</tt>,
but <tt>Object.clone</tt> is a <tt>protected</tt> method and for this reason
not part of the <tt>public</tt> interface of a class. In essence, all classes
have a <tt>clone</tt> method, but only a private one, unless they explicitly
provide a public <tt>clone</tt> method.&nbsp;</li>

<li>
Most classes that have a <tt>clone</tt> method also implement the <tt>Cloneable</tt>
interface.&nbsp; The <tt>Cloneable</tt> interface is an empty marker interface
and does not mandate that a <tt>Cloneable</tt> class must have a public
<tt>clone</tt>
method.&nbsp; Even if we could sucessfully cast down to
<tt>Cloneable</tt>
we would not have access to a <tt>clone</tt> method.&nbsp; Hence, for purposes
of invoking a <tt>clone</tt> method the <tt>Cloneable</tt> interface is
totally irrelevant.</li>
</ul>
In the example we use reflection to find out whether the field has a public
<tt>clone</tt>
method. If it has a <tt>clone</tt> method, we invoke it.
<p><i>Casting the result of cloning any fields to the type that the type
parameter stands for.</i>
<p>If individual fields must be cloned, the <tt>clone</tt> method of the
respective fields' type must be invoked.&nbsp; The result of this invocation
of the <tt>clone</tt> method is often type <tt>Object</tt>, so that another
cast is necessary.&nbsp; If the field in question has the type that the
enclosing class's type parameter stands for then the target of this cast
is the type variable and the compiler issues the usual "unchecked cast"
warning.&nbsp; In our example we must clone the two fields of the unknown
type <tt>T</tt>, which requires that we invoke the field's <tt>clone</tt>
method via reflection.&nbsp; The result of the reflective call is of type
<tt>Object</tt>
and we must cast from <tt>Object</tt> to the type parameter
<tt>T</tt>.&nbsp;
Again, there is no way to avoid the unchecked casts after cloning the fields
and&nbsp; the warnings are best suppressed by means of the standard annotation
<tt>@annotation.SuppressWarnings</tt>.
<p><i>More "unchecked" warnings.</i>
<p>If a class has fields that are of a parameterized type and these fields
must be cloned then a cast from <tt>Object</tt> to the parameterized type
might be necessary and the compiler issues the usual "unchecked cast" warning.&nbsp;
<p>Example:
<blockquote><tt>class Store {</tt>
<br><tt>&nbsp; private ArrayList&lt;String> store = new ArrayList&lt;String>();</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>&nbsp; public Store clone() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Store clon = (Store)super.clone();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; clon.store = <b><font color="#660000">(ArrayList&lt;String>)</font></b>this.store.clone();
<b><font color="#666600">//
unchecked warning</font></b></tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
Again there is no chance to avoid the "unchecked cast" warnings and they
are best suppressed by means of the standard annotation <tt>@annotation.SuppressWarnings</tt>.
<p>The reason for the undesired unchecked warnings in conjunction with
the <tt>clone</tt> method stem from the fact that the <tt>clone</tt> method
is a non-generic legacy method.&nbsp; In situations where generic and non-generic
code is mixed, unchecked warnings cannot&nbsp; be avoided.
<p><i>Exception Handling.</i>
<p>In the example, we left open how the exceptions from reflective invocation
of the members' <tt>clone</tt> methods should be handled.&nbsp; Should
we suppress the exceptions, or should we map them to a <tt>CloneNotSupportedException</tt>,
or perhaps simply propagate the exceptions to the caller?
<p>Example (excerpt from implementation of <tt>clone</tt>):
<blockquote><tt><nobr>public<font color="#000000"> Triple&lt;T> clone(</font>)
{</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; ...</nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp; try {&nbsp;</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Class&lt;?> clzz = this.fst.getClass();</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Method&nbsp;&nbsp; meth = clzz.<b>getMethod</b>(<b>"clone"</b>, new Class[0]);</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Object&nbsp;&nbsp; dupl = meth.<b>invoke</b>(this.fst, new Object[0]);</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
clon.fst = (T)dupl;&nbsp;</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp; } catch (Exception
e) {</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><b><font color="#660000">...&nbsp;
???&nbsp; what should be done here ??? ...</font></b></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp; }</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp; ...</font></nobr></tt>
<br><tt><nobr>}</nobr></tt></blockquote>
Usually, a <tt>clone</tt> method does not throw any exceptions; at least
is does not through a <tt>CloneNotSupportedException</tt>.&nbsp; The point
in implementing a <tt>clone</tt> method is to support cloning.&nbsp; Why
should a <tt>clone</tt> method throw a <tt>CloneNotSupportedException </tt>then?&nbsp;
It is equally unusual that a <tt>clone</tt> method would throw any other
exception, because a class knows its fields and their types well enough
to successfully produce a clone of each field.
<p>For a generic class the situation is more complex.&nbsp; We do not know
anything about those fields of the class whose type is a type parameter.&nbsp;
In particular, we do not know whether those fields are
<tt>Cloneable</tt>
and/or have a <tt>clone</tt> method, as was explained above.&nbsp; The
attempted invocation of the members' <tt>clone</tt> method via reflection
bears the risk of failure, indicated by a number of exceptions raised by
<tt>Class.getMethod</tt>
and <tt>Method.invoke</tt> such as <tt>NoSuchMethodException</tt>,
<tt>IllegalArgumentException</tt>,
etc.&nbsp; In this situation the <tt>clone</tt> method might in fact fail
to produce a clone and it might make sense to indicate this failure by
mapping all (or some) exceptions to a <tt>CloneNotSupportedException</tt>.&nbsp;
<p>Example (throwing a <tt>CloneNotSupportedException</tt>):
<blockquote><tt><nobr>public<font color="#000000"> Triple&lt;T> clone(</font>)
<b><font color="#000099">throws
CloneNotSupportedException</font></b>{</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; ...</nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp; try {</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Class&lt;?> clzz = this.fst.getClass();</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Method&nbsp;&nbsp; meth = clzz.<b>getMethod</b>(<b>"clone"</b>, new Class[0]);</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Object&nbsp;&nbsp; dupl = meth.<b>invoke</b>(this.fst, new Object[0]);</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
clon.fst = (T)dupl;&nbsp;</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp; } catch (Exception
e) {</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><b><font color="#000099">throw
</font></b><font color="#000000">new</font><b><font color="#000099">
CloneNotSupportedException</font></b><font color="#000000">(e.toString());</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp; }</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp; ...</font></nobr></tt>
<br><tt><nobr>}</nobr></tt></blockquote>
On the other hand, one might argue that a type that does not have a clone
method probably needs no cloning because objects of the type can safely
be referenced from many other objects at the same time.&nbsp; Class <tt>String</tt>
is an example.&nbsp; Class <tt>String</tt> is neither <tt>Cloneable</tt>
nor has it a <tt>clone</tt> method.&nbsp; Class <tt>String</tt> does not
support the cloning feature, because <tt>String</tt> objects are immutable,
that is, they cannot be modified.&nbsp; An immutable object is never copied,
but simply shared among all objects that hold a reference to it.&nbsp;
With our exception handling above the <tt>clone </tt>method of a <tt>Triple&lt;String>
</tt>would
throw a <tt>CloneNotSupportedException</tt>, which is not quite appropriate.&nbsp;
It would be preferable to let the original triple and its clone hold references
to the shared string members.
<p>Example (suppressing the <tt><nobr><font color="#000000">NoSuchMethodException</font></nobr></tt>):
<blockquote><tt><nobr>public<font color="#000000"> Triple&lt;T> clone(</font>)
{</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; ...</nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp; try {&nbsp;</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Class&lt;?> clzz = this.fst.getClass();</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Method&nbsp;&nbsp; meth = clzz.<b>getMethod</b>(<b>"clone"</b>, new Class[0]);</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Object&nbsp;&nbsp; dupl = meth.<b>invoke</b>(this.fst, new Object[0]);</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
clon.fst = (T)dupl;&nbsp;</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp; } catch (</font><b><font color="#000099">NoSuchMethodException</font></b><font color="#000000">
e) {</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // exception
<b>suppressed</b></font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp; } catch (</font><b><font color="#000099">Exception</font></b><font color="#000000">
e) {&nbsp;</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
throw new <b>InternalError</b>(e.toString());&nbsp;</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp; }</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp; ...</font></nobr></tt>
<br><tt><nobr>}</nobr></tt></blockquote>
In the exception handling suggested above we suppress the <tt><nobr><font color="#000000">NoSuchMethodException
</font></nobr></tt>under
the assumption that an object without a <tt>clone</tt> method need not
be cloned, but can be shared.
<p>Note, that we cannot ascertain statically by means of type argument
bounds, that the members of a triple have a <tt>clone</tt> method.&nbsp;
We could define the type parameter with <tt>Cloneable</tt> as a bound,
that is, as <tt>class Triple&lt;T extends Cloneable></tt>, but that would
not avoid any of the issues discussed above.&nbsp; The <tt>Cloneable</tt>
interface is an empty tagging interface and does not demand that a cloneable
type has a <tt>clone</tt> method.&nbsp; We would still have to invoke the
<tt>clone</tt>
method via reflection and face the exception handling issues as before.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ502">#FAQ502</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#What is an unchecked warning?">What
is an "unchecked" warning?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#What is the SuppressWarnings annotation?">What
is the SuppressWarnings annotation?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350>
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450></h3>

<h3>
<a NAME="Using Runtime Type Information"></a>Using Runtime Type Information</h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450><a NAME="FAQ601"></a>
<h2>
<a NAME="What does the type parameter of class java.lang.Class mean?"></a><font face="Arial,Helvetica"><font size=+0>What
does the type parameter of class java.lang.Class mean?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>The type parameter is type that the <tt>Class</tt>
object represents, e.g. <tt>Class&lt;String></tt> represents <tt>String</tt>.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">An object of type <tt>java.lang.Class</tt> represents the
runtime type of an object.&nbsp; Such a <tt>Class</tt> object is usually
obtained via the <tt>getClass</tt> method defined in class <tt>Object</tt>.
Alternative ways of obtaining a <tt>Class</tt> object representing a certain
type are use of a class literal or the static method <tt>forName</tt> defined
in class <tt>Class</tt>.
<p>Since Java 5.0 class <tt>java.lang.Class</tt> is a generic class with
one unbounded type parameter. The type parameter is the type that the <tt>Class</tt>
object represents.&nbsp; For instance, type <tt>Number</tt> is represented
by a <tt>Class</tt> object of type <tt>Class&lt;Number></tt>,&nbsp; type
<tt>String</tt> by a <tt>Class</tt> object of type <tt>Class&lt;String></tt>,
and so forth.
<p>Parameterized types share the same runtime type and as a result they
are represented by&nbsp; the same <tt>Class</tt> object, namely the&nbsp;
<tt>Class</tt> object that represents the raw type.&nbsp; For instance,
all instantiations of <tt>List</tt>, such as <tt>List&lt;Long></tt>,
<tt>List&lt;String></tt>,
<tt>List&lt;?></tt>,
and the raw type <tt>List</tt> itself are represented by the same <tt>Class</tt>
object; this <tt>Class</tt> object is of type
<tt>Class&lt;List></tt>.&nbsp;
<p>In general, the type argument of a <tt>Class</tt> object's type is the
erasure of the type that the <tt>Class</tt> object represents.
<p>Note that the methods <tt>Object.getClass</tt> and <tt>Class.forName</tt>
return references of a wildcard type. A side effect is that they cannot
be assigned to a <tt>Class</tt> object of the actual type.
<p>Example (using <tt>Class</tt> objects):&nbsp;
<blockquote><tt>Number n = new Long(0L);</tt>
<br><tt>Class&lt;Number> c1 = Number.class;</tt>
<br><tt>Class&lt;Number> c2 = Class.forName("java.lang.Number"); <b><font color="#660000">//
error</font></b></tt>
<br><tt>Class&lt;Number> c3 = n.getClass();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b><font color="#660000">// error</font></b></tt></blockquote>
The <tt>forName</tt> method returns a reference of type <tt>Class&lt;?></tt>,
not of type <tt>Class&lt;Number></tt>. Returning an object of any <tt>Class</tt>
type makes sense because the method can return a <tt>Class</tt> object
representing any type.
<p>The <tt>getClass</tt> method returns a reference of type <tt>Class&lt;?
extends X></tt>, where <tt>X</tt> is the erasure of the static type of
the expression on which <tt>getClass</tt> is called.&nbsp; Returning <tt>Class&lt;?
extends X></tt>&nbsp; makes sense because the type <tt>X</tt> might be
a supertype referring to a subtype object.&nbsp; The <tt>getClass</tt>
method would then return the runtime type representation of the subclass
and not the representation of the supertype. In the example above the reference
of type <tt>Number</tt> refers to an object of type <tt>Long</tt>, so that
the <tt>getClass</tt> method returns a <tt>Class</tt> object of type <tt>Class&lt;Long></tt>
instead of <tt>Class&lt;Number></tt>.
<p>Example (corrected):&nbsp;
<blockquote><tt>Number n = new Long(0L);</tt>
<br><tt>Class&lt;Number>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
c1 = Number.class;</tt>
<br><tt>Class&lt;?>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
c2 = Class.forName("java.lang.Number");&nbsp;</tt>
<br><tt>Class&lt;? extends Number>&nbsp; c3 = n.getClass();&nbsp;</tt></blockquote>
The easiest way of passing around type representations is via a reference
of type <tt>Class&lt;?></tt>.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ601">#FAQ601</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#What is type erasure?">What
is type erasure?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#How do I pass type information to a method?">How
do I pass type information to a method so that it can be used at runtime?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ602"></a>
<h2>
<a NAME="How do I pass type information to a method?"></a><b><font face="Arial,Helvetica"><font size=+0>How
do I pass type information to a method so that it can be used at runtime?</font></font></b></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>By means of a <tt>Class</tt> object.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">The type information that is provided by a type parameter
is static type information that is no longer available at runtime.&nbsp;
When we need type information that is available at runtime we must explicitly
supply the runtime time information to the method.&nbsp; Below are a couple
of situations where the static type information provided by a type parameter
does not suffice.
<p>Example (of illegal or pointless use of type parameter):
<blockquote><tt>public static &lt;T> void someMethod() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ... <b><font color="#660000">new T() </font></b>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<b><font color="#660000">// error</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; ... <b><font color="#660000">new T[</font></b><font color="#000000">SIZE</font><b><font color="#660000">]
</font></b>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<b><font color="#660000">// error</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; ... ref <b><font color="#660000">instanceof
T </font></b>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#660000">//
error</font></b></tt>
<br><tt><b><font color="#660000">&nbsp;&nbsp;&nbsp; ... (T) </font></b><font color="#000000">ref
..</font><b><font color="#660000">.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// unchecked warning</font></b></tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br>
<hr WIDTH="100%">
<br><tt>Utilities.<b><font color="#000099">&lt;String></font></b>someMethod();</tt></blockquote>
The type parameter <tt>T</tt> of the method does not provide any type information
that would still be accessible at runtime.&nbsp; At runtime the type parameter
is represented by the raw type of it leftmost bound or type <tt>Object</tt>,
if no bound was specified.&nbsp; For this reason, the compiler refuses
the accept type parameters in <tt>new</tt> expressions, and type checks
based on the type parameter are either illegal or nonsensical.
<p>If we really need runtime type information we must pass it to the method
explicitly.&nbsp; There are 3 techniques for supplying runtime type information
to a method:
<ul>
<li>
supply an object&nbsp;</li>

<li>
supply an array&nbsp;</li>

<li>
supply a <tt>Class</tt> object</li>
</ul>
The 3 alternative implementations of the method above would look like this:
<p>Example (of passing runtime type information):
<blockquote><tt>public static &lt;T> void someMethod(<b><font color="#000099">T</font></b>
dummy) {&nbsp;</tt>
<br><tt>&nbsp; <font color="#000000">Class&lt;T> type</font> = dummy.getClass();</tt>
<br><tt>&nbsp; </tt>...&nbsp; use type reflectively ...
<br><tt>}</tt>
<br><tt>public static &lt;T> void someMethod(<b><font color="#000099">T[]</font></b>
dummy) {&nbsp;</tt>
<br><tt>&nbsp; </tt>...&nbsp; use type reflectively ...
<br><tt>&nbsp; <font color="#000000">Class&lt;T> type</font> = dummy.getClass().getComponentType();</tt>
<br><tt>}</tt>
<br><tt>public static &lt;T> void someMethod(<b><font color="#000099">Class&lt;T></font></b>
type) {&nbsp;</tt>
<br><tt>&nbsp; </tt>...&nbsp; use type reflectively ...
<br><tt>&nbsp; ... (T)type.newInstance() ...</tt>
<br><tt>&nbsp; ... (T[])Array.newInstance(type,SIZE) ...</tt>
<br><tt>&nbsp; ... type.isInstance(ref) ...</tt>
<br><tt>&nbsp; ... type.cast(tmp) ...</tt>
<br><tt>}</tt>
<br>
<hr WIDTH="100%">
<br><tt>Utilities.someMethod(<b><font color="#000099">new String()</font></b>);&nbsp;</tt>
<br><tt>Utilities.someMethod(<b><font color="#000099">new String[0]</font></b>);&nbsp;</tt>
<br><tt>Utilities.someMethod(<b><font color="#000099">String.class</font></b>);&nbsp;</tt></blockquote>
The first two alternatives are wasteful, because dummy objects must be
created for the sole purpose of supplying their type information. In addition,
the first approach does not work when an abstract class or an interface
must be represented, because no objects of these types can be created.&nbsp;
<br>The second technique is the classic approach; it is the one taken by
the <tt>toArray</tt> methods of the collection classes in package <tt>java.util
</tt>(see
<tt><a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Collection.html#toArray(T[])">java.util.Collection.toArray(T[])</a></tt>).&nbsp;
<br>The third alternative is the recommended technique.&nbsp; It provides
runtime type information by means of a <tt>Class</tt> object.&nbsp;
<p>Here are the corresponding operations based on the runtime type information
from the example above, this time performed using reflection.
<p>Example (of reflective use of runtime type information):
<blockquote><tt>public static &lt;T> void som<font color="#000000">eMethod(Class&lt;T>
ty</font>pe) {&nbsp;</tt>
<br><tt>&nbsp; ... <b><font color="#000099">(T)type.newInstance()</font></b>
...</tt>
<br><tt>&nbsp; ... <b><font color="#000099">(T[])Array.newInstance(type,</font></b><font color="#000000">SIZE</font><b><font color="#000099">)</font></b>
...</tt>
<br><tt>&nbsp; ... <b><font color="#000099">type.isInstance(</font></b><font color="#000000">ref</font><b><font color="#000099">)</font></b>
...</tt>
<br><tt>&nbsp; ... <b><font color="#000099">type.cast(</font></b><font color="#000000">tmp</font><b><font color="#000099">)</font></b>
...</tt>
<br><tt>}</tt></blockquote>

<p><br>Examples using class <tt>Class</tt> to provide type information
can be found in the subsequent two FAQ entries (see <font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font>
or click <a href="#How do I generically create objects and arrays?">here</a>
and <a href="#How do I perform a runtime type check whose target type is a type parameter?">here</a>).</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ602">#FAQ602</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#What does the type parameter of class java.lang.Class mean?">What
does the type parameter of class java.lang.Class mean?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#How do I generically create objects and arrays?">How
do I generically create objects and arrays?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#How do I perform a runtime type check whose target type is a type parameter?">How
do I perform a runtime type check whose target type is a type parameter?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ603"></a>
<p><a NAME="How do I generically create objects and arrays?"></a><b><font face="Arial,Helvetica"><font size=+0>How
do I generically create objects and arrays?</font></font></b>
<br>&nbsp;
<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Using reflection.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">The type information that is provided by a type parameter
is static type information that is no longer available at runtime.&nbsp;
It does not permit generic creation of objects or arrays.
<p>Example (of failed generic array creation based on static type information):
<blockquote><tt>class Utilities {</tt>
<br><tt>&nbsp; private static final int SIZE = 1024;</tt>
<p><tt>&nbsp; public static <b><font color="#000099">&lt;T></font></b>
T[] createBuffer() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return <b><font color="#660000">new T[SIZE]</font></b>;
<b><font color="#660000">//
error</font></b></tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br><tt>public static void main(String[] args) {</tt>
<br><tt>&nbsp; String[] buffer = Utilities.<b><font color="#000099">&lt;String></font></b>createBuffer();</tt>
<br><tt>}</tt></blockquote>
The type parameter <tt>T</tt> of method <tt>createBuffer</tt> does not
provide any type information that would still be accessible at runtime.&nbsp;
At runtime the type parameter is represented by the raw type of it leftmost
bound or type <tt>Object</tt>, if no bound was specified.&nbsp; For this
reason, the compiler refuses the accept type parameters in <tt>new</tt>
expressions.
<p>If we need to generically create an object or array, then we must pass
type information to the <tt>createBuffer </tt>method that persists until
runtime. This runtime type information can then be used to perform the
generic object of array creation via reflection. The type information is
best supplied by means of a <tt>Class</tt> object.
<p>Example (of generic array creation based on runtime type information):
<blockquote><tt>public static <b><font color="#000099">&lt;T></font></b>
T[] createBuffer(<b><font color="#000099">Class&lt;T></font></b> type)
{&nbsp;</tt>
<br><tt>&nbsp; return (T[])Array.newInstance(type,SIZE);</tt>
<br><tt>}</tt>
<br><tt>public static void main(String[] args) {&nbsp;</tt>
<br><tt>&nbsp; String[] buffer = Utilities.createBuffer(<font color="#000099">String.class</font>);</tt>
<br><tt>}&nbsp;</tt></blockquote>
Note that the parameterization of class <tt>Class</tt> allows to ensure
at compile time that no arbitrary types of <tt>Class</tt> objects are passed
to the <tt>createBuffer</tt> method. Only a <tt>Class</tt> object that
represents a runtime type that matches the desired component type of the
created array is permitted.
<p>Example:
<blockquote><tt><b><font color="#006600">String[]</font></b> buffer = Utilities.createBuffer(<b><font color="#006600">String.class</font></b>);</tt>
<br><tt><b><font color="#660000">String[]</font></b> buffer = Utilities.createBuffer(<b><font color="#660000">Long.class</font></b>);
<b><font color="#660000">//
error</font></b></tt>
<br><tt><b><font color="#006600">Number[]</font></b> buffer = Utilities.createBuffer(<b><font color="#006600">Long.class</font></b>);</tt></blockquote>
</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ603">#FAQ603</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#What does the type parameter of class java.lang.Class mean?">What
does the type parameter of class java.lang.Class mean?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#How do I pass type information to a method?">How
do I pass type information to a method so that it can be used at runtime?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ604"></a>
<p><a NAME="How do I perform a runtime type check whose target type is a type parameter?"></a><b><font face="Arial,Helvetica"><font size=+0>How
do I perform a runtime type check whose target type is a type parameter?</font></font></b>
<br>&nbsp;
<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Using reflection.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">The type information that is provided by a type parameter
is static type information that is no longer available at runtime.&nbsp;
It does not permit any generic type checks.&nbsp;
<p>Consider a method that is supposed to extract from a sequence of objects
of arbitrary types all elements of a particular type. Such a method must
at runtime check for a match between the type of each element in the sequence
and the specific type that it is looking for.&nbsp; This type check cannot
be performed by means on the type parameter.
<p>Example (of failed generic type check based on static type information):
<blockquote><tt>class Utilities {</tt>
<br><tt>&nbsp; public static <b><font color="#000099">&lt;T></font></b>
Collection&lt;T> extract(Collection&lt;?> src) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; HashSet&lt;T> dest = new HashSet&lt;T>();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for (Object o : src)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (o <b><font color="#660000">instanceof
T</font></b>)&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#660000">// error</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dest.add(<b><font color="#660000">(T)</font></b>o);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><font color="#660000">
// unchecked warning</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; return dest;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br><tt>public static void test(Collection&lt;?> coll) {</tt>
<br><tt>&nbsp; Collection&lt;Integer> coll = Utilities.<b><font color="#000099">&lt;Integer></font></b>extract(coll);</tt>
<br><tt>}</tt></blockquote>
Type parameters are not permitted in <tt>instanceof</tt> expressions and
the cast to the type parameter is nonsensical, because it is a cast to
type <tt>Object</tt> after type erasure.
<p>For a type check at runtime we must explicitly provide runtime type
information so that we can perform the type check and cast by means of
reflection.&nbsp; The type information is best supplied by means of a <tt>Class</tt>
object.
<p>Example (of generic type check based on runtime type information):
<blockquote><tt>class Utilities {</tt>
<br><tt>&nbsp; public static <b><font color="#000099">&lt;T></font></b>
Collection&lt;T> extract(Collection&lt;?> src, <b><font color="#000099">Class&lt;T></font></b>
type) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; HashSet&lt;T> dest = new HashSet&lt;T>();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for (Object o : src)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (<b><font color="#000099">type.isInstance(o)</font></b>)&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dest.add(<b><font color="#000099">type.cast(o)</font></b>);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return dest;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br><tt>public static void test(Collection&lt;?> coll) {</tt>
<br><tt>&nbsp; Collection&lt;Integer> coll = Utilities.extract(coll,<b><font color="#000099">Integer.class</font></b>);</tt>
<br><tt>}</tt></blockquote>
</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ604">#FAQ604</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#What does the type parameter of class java.lang.Class mean?">What
does the type parameter of class java.lang.Class mean?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#How do I pass type information to a method?">How
do I pass type information to a method so that it can be used at runtime?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350>
<br>
<hr WIDTH="100%">
<br><font face="Arial,Helvetica"><font size=-2><a href="../JavaGenericsFAQ.html#TOC">CONTENT<img SRC="../../Images/bluebullet.gif" NOSAVE height=6 width=4></a>&nbsp;
<font color="#666666"><a href="TypeArguments.html">PREVIOUS<img SRC="../../Images/bluebullet.gif" NOSAVE height=6 width=4></a></font>&nbsp;
<a href="TechnicalDetails.html">NEXT<img SRC="../../Images/bluebullet.gif" NOSAVE height=6 width=4></a>&nbsp;
<a href="Index.html#IDX">INDEX</a></font></font>
</body>
</html>
