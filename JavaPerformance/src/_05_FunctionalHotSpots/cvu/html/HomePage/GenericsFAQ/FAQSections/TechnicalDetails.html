<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.79 [en] (Windows NT 5.0; U) [Netscape]">
   <meta name="Author" content="Angelika Langer">
   <meta name="KeyWords" content="Java Generics parameterized type parameterized methodwildcard">
   <title>Java Generics FAQs - Under The Hood Of The Compiler</title>
</head>
<body text="#000000" bgcolor="#FFFFFF" link="#113E79" vlink="#677DAD" alink="#008080">

<h1>
<a NAME="Top"></a><a NAME="FAQTechnicalDetails"></a><a NAME="Technicalities - Under The Hood Of The Compiler"></a>Technicalities
- Under The Hood Of The Compiler</h1>
<font size=-2>&copy; Copyright 2003-2005 by Angelika Langer.&nbsp; All
Rights Reserved.</font>
<table CELLPADDING=10 WIDTH="100%" >
<tr>
<td COLSPAN="2"><font size=+0><a href="#Compiler Messages">Compiler Messages</a></font>
<ul>
<li>
<font size=+0><a href="#What is an unchecked warning?">What is an "unchecked"
warning?</a></font></li>

<li>
<a href="#How can I disable or enable unchecked warnings?">How can I disable
or enable unchecked warnings?</a></li>

<li>
<font size=+0><a href="#What is the -Xlint:unchecked compiler option?">What
is the -Xlint:unchecked compiler option?</a></font></li>

<li>
<font size=+0><a href="#What is the SuppressWarnings annotation?">What
is the <tt>SuppressWarnings</tt> annotation?</a></font></li>

<li>
<font size=+0><a href="#How can I avoid unchecked cast warnings?">How can
I avoid "unchecked cast" warnings?</a></font></li>

<li>
<font size=+0><a href="#Is it possible to eliminate all unchecked warnings?">Is
it possible to eliminate all "unchecked" warnings?</a></font></li>
</ul>
<a href="#Type Erasure">Type Erasure</a>
<ul>
<li>
<a href="#How does the compiler translate Java generics?">How does the
compiler translate Java generics?</a></li>

<li>
<font size=+0><a href="#What is type erasure?">What is type erasure?</a></font></li>

<li>
<font size=+0><a href="#What is a bridge method?">What is a bridge method?</a></font></li>

<li>
<font size=+0><a href="#Under which circumstances is a bridge method generated?">Under
which circumstances is a bridge method generated?</a></font></li>

<li>
<font size=+0><a href="#Why does the compiler add casts when it translates generics?">Why
does the compiler add casts when it translates generics?</a></font></li>

<li>
<font size=+0><a href="#How does type erasure work when a type parameter has several bounds?">How
does type erasure work when a type parameter has several bounds?</a></font></li>

<li>
<font size=+0><a href="#What is a reifiable type?">What is a reifiable
type?</a></font></li>

<li>
<font size=+0><a href="#What is the type erasure of a parameterized type?">What
is the type erasure of a parameterized type?</a></font></li>

<li>
<font size=+0><a href="#What is the type erasure of a type parameter?">What
is the type erasure of a type parameter?</a></font></li>

<li>
<font size=+0><a href="#What is the type erasure of a parameterized method?">What
is the type erasure of a generic method?</a></font></li>

<li>
<font size=+0><a href="#Is generic code faster or slower than non-generic code?">Is
generic code faster or slower than non-generic code?</a></font></li>

<li>
<font size=+0><a href="#How do I compile generics for use with JDK <= 1.4?">How
do I compile generics for use with JDK &lt;= 1.4?</a></font></li>
</ul>
<font size=+0><a href="#Type System">Type System</a></font>
<ul>
<li>
<font size=+0><a href="#How do parameterized types fit into the Java type system?">How
do parameterized types fit into the Java type system?</a></font></li>

<li>
<a href="#How does the raw type relate to instantiations of the corresponding parameterized type?">How
does the raw type relate to instantiations of the corresponding generic
type?</a></li>

<li>
<font size=+0><a href="#How do instantiations of a parameterized type relate to  instantiations of other parameterized types?">How
do instantiations of a generic type relate to&nbsp; instantiations of other
generic types that have the same type argument?</a></font></li>

<li>
<font size=+0><a href="#How do unbounded wildcard instantiations of a parameterized type relate to other instantiations of the same type?">How
do unbounded wildcard instantiations of a generic type relate to other
instantiations of the same generic type?</a></font></li>

<li>
<font size=+0><a href="#How do wildcard instantiations with an upper bound relate to other instantiations of the same type?How do wildcard instantiations with an upper bound relate to other instantiations of the same type?">How
do wildcard instantiations with an upper bound relate to other instantiations
of the same generic type?</a></font></li>

<li>
<font size=+0><a href="#How do wildcard instantiations with a lower bound relate to other instantiations of the same type?">How
do wildcard instantiations with a lower bound relate to other instantiations
of the same generic type?</a></font></li>

<li>
<font size=+0><a href="#Which super-subtype relationships exist among instantiations of parameterized types?">Which
super-subtype relationships exist among instantiations of generic types?</a></font></li>

<li>
<font size=+0><a href="#Which super-subset relationships exist among wildcards?">Which
super-subset relationships exist among wildcards?</a></font></li>

<li>
<font size=+0><a href="#Does extends always mean inheritance?">Does "extends"
always mean "inheritance"?</a></font></li>
</ul>
<font size=+0><a href="#Exception Handling">Exception Handling</a></font>
<ul>
<li>
<font size=+0><a href="#Can I use parameterized types in exception handling?">Can
I use parameterized types in exception handling?</a></font></li>

<li>
<font size=+0><a href="#Why are parameterized exception and error types illegal?">Why
are generic exception and error types illegal?</a></font></li>

<li>
<font size=+0><a href="#Can I use a type parameter in exception handling?">Can
I use a type parameter in exception handling?</a></font></li>

<li>
<font size=+0><a href="#Can I use a type parameter in a catch clause?">Can
I use a type parameter in a catch clause?</a></font></li>

<li>
<font size=+0><a href="#Can I use a type parameter in in a throws clause?">Can
I use a type parameter in in a throws clause?</a></font></li>

<li>
<font size=+0><a href="#Can I throw an object whose type is a type parameter?">Can
I throw an object whose type is a type parameter?</a></font></li>
</ul>
<font size=+0><a href="#Static Context">Static Context</a></font>
<ul>
<li>
<font size=+0><a href="#How do I refer to static members of a parameterized type?">How
do I refer to static members of a parameterized type?</a></font></li>

<li>
<font size=+0><a href="#How do I refer to a (non-static) inner class of a parameterized type?">How
do I refer to a (non-static) inner class of a parameterized type?</a></font></li>

<li>
<font size=+0><a href="#How do I refer to an interface type nested into a parameterized type?">How
do I refer to an interface type nested into a parameterized type?</a></font></li>

<li>
<font size=+0><a href="#How do I refer to an enum type nested into a parameterized type?">How
do I refer to an enum type nested into a parameterized type?</a></font></li>

<li>
<font size=+0><a href="#Can I import a particular instantiation of parameterized type?">Can
I import a particular instantiations of a generic type?</a></font></li>

<li>
<font size=+0><a href="#Why are parameterized enum types illegal?">Why
are generic enum types illegal?</a></font></li>
</ul>
<font size=+0><a href="#Type Argument Inference">Type Argument Inference</a></font>
<ul>
<li>
<font size=+0><a href="#What is type argument inference?">What is type
argument inference?</a></font></li>

<li>
<font size=+0>What are the exact rules for type argument inference?</font></li>

<li>
<font size=+0><a href="#What explicit type argument specification?">What
is explicit type argument specification?</a></font></li>

<li>
<font size=+0><a href="#What happens if a type parameter does appear in the method parameter list?">What
happens if a type parameter does not appear in the method parameter list?</a></font></li>

<li>
<font size=+0><a href="#Why doesn't type argument inference fail when I provide inconsistent method">Why
doesn't type argument inference fail when I provide inconsistent method
arguments?</a></font></li>

<li>
<font size=+0><a href="#Why do temporary variables matter in case of invocation of parameterized methods?">Why
do temporary variables matter in case of invocation of generic methods?</a></font></li>
</ul>
<font size=+0><a href="#Wildcard Capture">Wilcard Capture</a></font>
<ul>
<li>
<font size=+0><a href="#What is the capture of a wildcard?">What is the
capture of a wildcard?</a></font></li>

<li>
<font size=+0><a href="#What is a wildcard capture assignment-compatible to?">What
is a wildcard capture assignment-compatible to?</a></font></li>

<li>
<font size=+0><a href="#Is the capture of a bounded wildcard compatible to the bound?">Is
the capture of a bounded wildcard compatible to the bound?</a></font></li>
</ul>
<font size=+0><a href="#Wildcard Instantiations">Wildcard Instantiations</a></font>
<ul>
<li>
<font size=+0><a href="#Which methods and fields are accessible/inaccessible through a reference variable of a wildcard type?">Which
methods and fields are accessible/inaccessible through a reference variable
of a wildcard parameterized type?</a></font></li>

<li>
<font size=+0><a href="#Which methods that use the type parameter in the argument or return type are accessible in an unbounded wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in an unbounded wildcard parameterized type?</a></font></li>

<li>
<font size=+0><a href="#Which methods that use the type parameter in the argument or return type are accessible in an upper bound wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in an upper bound wildcard parmeterized type?</a></font></li>

<li>
<font size=+0><a href="#Which methods that use the type parameter in the argument or return type are accessible in a lower bound wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in a lower bound wildcard parmeterized type?</a></font></li>

<li>
<font size=+0><a href="#Which methods that use the type parameter as type argument of a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as type argument of a parameterized
argument or return type are accessible in a wildcard parameterized type?</a></font></li>

<li>
<font size=+0><a href="#Which methods that use the type parameter as upper wildcard bound in a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as upper wildcard bound in a parameterized
argument or return type are accessible in a wildcard parameterized type?</a></font></li>

<li>
<font size=+0><a href="#Which methods that use the type parameter as lower wildcard bound in a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as lower wildcard bound in a parameterized
argument or return type are accessible in a wildcard parameterized type?</a></font></li>

<li>
<font size=+0><a href="#In a wildcard instantiation, can I read and write fields whose type is the type parameter?">In
a wildcard parameterized type, can I read and write fields whose type is
the type parameter?</a></font></li>
</ul>
<font size=+0><a href="#Cast and instanceof">Cast and instanceof</a></font>
<ul>
<li>
<font size=+0><a href="#Which types can or must not appear as target type in an instanceof expression?">Which
types can or must not appear as target type in an instanceof expression?</a></font></li>

<li>
<font size=+0>Which casts are permitted?</font></li>

<li>
<font size=+0>Which casts are prohibited?</font></li>
</ul>
<font size=+0>Overload Resolution</font>
<ul>
<li>
<font size=+0>Can a generic method override a non-generic method, or vice
versa?</font></li>
</ul>
</td>
</tr>

<tr>
<td></td>
</tr>
</table>

<h1>
<img SRC="../../Images/bar.gif" NOSAVE height=5 width=600></h1>

<h2>
<a NAME="Under The Hood"></a>Under The Hood Of The Compiler</h2>
<img SRC="../../Images/bar.gif" NOSAVE height=5 width=600>
<br>&nbsp;
<h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450></h3>

<h3>
<a NAME="Compiler Messages"></a>Compiler Messages</h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450><a NAME="FAQ001"></a>
<h2>
<a NAME="What is an unchecked warning?"></a><font face="Arial,Helvetica"><font size=+0>What
is an "unchecked" warning?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>A warning by which the compiler indicates
that it cannot ensure type safety.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">The term "unchecked" warning is misleading.&nbsp; It does
not mean that the warning is unchecked in any way.&nbsp; The term "unchecked"
refers to the fact that the compiler and the runtime system do not have
enough type information to perform all type checks that would be necessary
to ensure type safety. In this sense, certain operations are "unchecked".&nbsp;
<p>The most common source of "unchecked" warnings is the use of raw types.&nbsp;
"unchecked" warnings are issued when an object is accessed through a raw
type variable, because the raw type does not provide enough type information
to perform all necessary type checks.
<p>Example (of unchecked warning in conjunction with raw types):
<blockquote><tt><b><font color="#000099">TreeSet</font></b><font color="#000000">
se</font>t = new TreeSet();</tt>
<br><tt>set.add("abc");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#666600">//
unchecked warning</font></b></tt>
<br><tt>set.remove("abc");</tt>
<br>
<hr WIDTH="100%">
<br><tt>warning: [unchecked] unchecked call to add(E) as a member of the
raw type java.util.TreeSet</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
set.add("abc");&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt></blockquote>
When the <tt>add</tt> method is invoked the compiler does not know whether
it is safe to add a <tt>String</tt> object to the collection.&nbsp; If
the <tt>TreeSet</tt> is a collection that contains <tt>String</tt>s (or
a supertype thereof), then it would be safe.&nbsp; But from the type information
provided by the raw type <tt>TreeSet</tt> the compiler cannot tell.&nbsp;
Hence the call is potentially unsafe and an "unchecked" warning is issued.
<br>&nbsp;
<p>"unchecked" warnings are also reported when the compiler finds a cast
whose target type is either a parameterized type or a type parameter.
<p>Example (of an unchecked warning in conjunction with a cast to a parameterized
type or type variable):
<blockquote><tt><nobr>class Wrapper&lt;T> {</nobr></tt>
<br><tt><nobr>&nbsp; private T wrapped<font color="#000000">;</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp; public </font>Wrapper<font color="#000000">(T
arg) {wrapped = arg;}</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp; ...</font></nobr></tt>
<br><tt><nobr>&nbsp; p<font color="#000000">ublic </font>Wrapper<font color="#000000">&lt;T>
</font>clone()
{</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp; Wrapper&lt;T> clon = null;</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; try {&nbsp;</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clon = <b><font color="#660000">(Wrapper&lt;T>)</font></b>super.clone();
</nobr><b><font color="#666600">//
unchecked warning</font></b></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; } catch (CloneNotSupportedException
e) {&nbsp;</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new InternalError();&nbsp;</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; }</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; try {&nbsp;</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class&lt;?> clzz = this.wrapped.getClass();</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Method&nbsp;&nbsp; meth
= clzz.getMethod("clone", new Class[0]);</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object&nbsp;&nbsp; dupl
= meth.invoke(this.wrapped, new Object[0]);</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clon.wrapped = <b><font color="#660000">(T)</font></b>dupl;
</nobr><b><font color="#666600">//
unchecked warning</font></b></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; } catch (Exception e) {}</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; return clon;</nobr></tt>
<br><tt><nobr>&nbsp; }</nobr></tt>
<br><tt><nobr>}</nobr></tt>
<br>
<hr WIDTH="100%">
<br><tt>warning: [unchecked] unchecked cast</tt>
<br><tt>found&nbsp;&nbsp; : java.lang.Object</tt>
<br><tt>required: <nobr>Wrapper</nobr>&lt;T></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
clon = (<nobr>Wrapper</nobr>&lt;T>)super.clone();&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>warning: [unchecked] unchecked cast</tt>
<br><tt>found&nbsp;&nbsp; : java.lang.Object</tt>
<br><tt>required: T</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
clon.<nobr>wrapped</nobr> = (T)dupl;&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt></blockquote>
A cast whose target type is either a (concrete or bounded wildcard) parameterized
type or a type parameter is unsafe, if a dynamic type check at runtime
is involved.&nbsp; At runtime, only the type erasure is available, not
the exact static type that is visible in the source code.&nbsp; As a result,
the runtime part of the cast is performed based on the type erasure, not
on the exact static type.
<p>In the example, the cast to <tt>Wrapper&lt;T></tt> would check whether
the object returned from <tt>super.clone</tt> is a <tt>Wrapper</tt>, not
whether it is a wrapper with a particular type of members.&nbsp; Similarly,
the casts to the type parameter <tt>T </tt>are cast to type <tt>Object</tt>
at runtime, and probably optimized away altogether.&nbsp; Due to type erasure,
the runtime system is unable to perform more useful type checks at runtime.&nbsp;
<p>In a way, the source code is misleading, because it suggests that a
cast to the respective target type is performed, while in fact the dynamic
part of the cast only checks against the type erasure of the target type.&nbsp;
The "unchecked" warning is issued to draw the programmer's attention to
this mismatch between the static and dynamic aspect of the cast.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ001">#FAQ001</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="Fundamentals.html#What does type-safety mean?">What
does type-safety mean?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#How can I disable or enable unchecked warnings?">How
can I disable or enable unchecked warnings?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is the raw type?">What
is the raw type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#Can I use a raw type like any other type?">Can
I use a raw type like any other type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#Can I cast to a parameterized type?">Can
I cast to a parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeParameters.html#Can I cast to the type that the type parameter stands for?">Can
I cast to the type that the type parameter stands for?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ002"></a>
<p><a NAME="How can I disable or enable unchecked warnings?"></a><b><font face="Arial,Helvetica"><font size=+0>How
can I disable or enable "unchecked" warnings?</font></font></b>
<br>&nbsp;
<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Via the compiler options <tt>-Xlint:unchecked</tt>
and <tt>-Xlint:-unchecked</tt> and via the standard annotation <tt>@SuppressWarnings("unchecked")</tt>.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">The compiler option <tt>-Xlint:-unchecked</tt> disables
<i>all</i>
unchecked warnings that would occur in a compilation.
<p>The annotation <tt>@SuppressWarnings("unchecked") </tt>suppresses all
warnings for the annotated part of the program.
<p>Note, in the first release of Java 5.0 the <tt>SuppressWarnings</tt>
annotation is not yet supported.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ002">#FAQ002</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#What is the -Xlint:unchecked compiler option?">What
is the -Xlint:unchecked compiler option?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#What is the SuppressWarnings annotation?">What
is the SuppressWarnings annotation?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ003"></a>
<h2>
<a NAME="What is the -Xlint:unchecked compiler option?"></a><font face="Arial,Helvetica"><font size=+0>What
is the -Xlint:unchecked compiler option?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>The compiler option -Xlint:unchecked
enables "unchecked" warnings, the option -Xlint:-unchecked disables all
unchecked warnings.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">"unchecked" warnings are by default disabled.&nbsp; If
you compile a program with no particular compiler options then the compiler
will not report any "unchecked" warnings. If the compiler finds source
code for which it would want to report an "unchecked" warning it only gives
a general hint.&nbsp; You will find the following note at the end of the
list of all other errors and warnings:
<blockquote><tt>Note: util/Wrapper.java uses unchecked or unsafe operations.</tt>
<br><tt>Note: Recompile with -Xlint:unchecked for details.</tt></blockquote>
If you want to see the "unchecked" warnings you must start the compiler
with the <tt>-Xlint:unchecked </tt>option.
<p>Example (of globally enabling unchecked warnings):
<blockquote><tt>javac <b><font color="#000099">-Xlint:unchecked</font></b>
util/Wrapper.java</tt></blockquote>
The option <tt>-Xlint:unchecked en</tt>ables the "unchecked" warnings.&nbsp;
The "unchecked" warnings are also enabled when you use the <tt><font color="#000000">-Xlint:all
</font></tt>option.
<p>The option <tt>-Xlint:-unchecked </tt>disables the "unchecked" warnings.&nbsp;
This is useful to suppress all&nbsp; "unchecked" warnings, while other
types of warnings remain enabled.
<p>Example (of globally disabling unchecked warnings):
<blockquote><tt>javac -g -source 1.5 <b><font color="#000099">-Xlint:all
-Xlint:-unchecked</font></b> util/Wrapper.java</tt></blockquote>
In this example, using <tt>-Xlint:all</tt> all warnings (such as "unchecked",
"deprecated", "fallthrough", etc.) are enabled and subsequently the "unchecked"
warnings are disabled using <tt>-Xlint:-unchecked</tt>. As a result all
warnings except "unchecked" warnings will be reported.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ003">#FAQ003</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#What is an unchecked warning?">What
is an "unchecked" warning?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#What is the SuppressWarnings annotation?">What
is the SuppressWarnings annotation?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ004"></a>
<h2>
<a NAME="What is the SuppressWarnings annotation?"></a><font face="Arial,Helvetica"><font size=+0>What
is the SuppressWarnings annotation?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>A standard annotation that suppresses
warnings for the annotated part of the program.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">The compiler supports a number of standard annotations
(see package <tt><a href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/annotation/package-summary.html">java.lang.annotation</a></tt>).
Among them is the <tt>SuppressWarnings </tt>annotation. It contains a list
of warning labels.&nbsp; If a definition in the source code is annotated
with the
<tt>SuppressWarnings
</tt>annotation, then all warnings, whose
labels appear in the annotation's list of warning labels, are suppressed
for the annotated definition or any of its parts.&nbsp;
<p>The <tt>SuppressWarnings </tt>annotation can be used to suppress any
type of labelled warning.&nbsp; In particular we can use the annotation
to suppress "unchecked" warnings.
<p>Example (of suppressing unchecked warnings):
<blockquote><b><tt><nobr><font color="#000099">@SuppressWarnings("unchecked")</font></nobr></tt></b>
<br><tt><nobr>class Wrapper&lt;T> {</nobr></tt>
<br><tt><nobr>&nbsp; private T wrapped<font color="#000000">;</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp; public </font>Wrapper<font color="#000000">(T
arg) {wrapped = arg;}</font></nobr></tt>
<br><tt><nobr><font color="#000000">&nbsp; ...</font></nobr></tt>
<br><tt><nobr>&nbsp; p<font color="#000000">ublic </font>Wrapper<font color="#000000">&lt;T>
</font>clone()
{</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp; Wrapper&lt;T> clon = null;</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; try {&nbsp;</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clon = <b><font color="#660000">(Wrapper&lt;T>)</font></b>super.clone();
</nobr><b><font color="#660000">//
unchecked warning supressed</font></b></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; } catch (CloneNotSupportedException
e) {&nbsp;</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new InternalError();&nbsp;</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; }</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; try {&nbsp;</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class&lt;?> clzz = this.wrapped.getClass();</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Method&nbsp;&nbsp; meth
= clzz.getMethod("clone", new Class[0]);</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object&nbsp;&nbsp; dupl
= meth.invoke(this.wrapped, new Object[0]);</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clon.wrapped = <b><font color="#660000">(T)</font></b>dupl;
</nobr><b><font color="#660000">//
unchecked warning supressed</font></b></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; } catch (Exception e) {}</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp;&nbsp; return clon;</nobr></tt>
<br><tt><nobr>&nbsp; }</nobr></tt>
<br><tt><nobr>}</nobr></tt></blockquote>
This example would usually raise 2 "unchecked" warnings.&nbsp; Since we
annotated the entire class, all unchecked warnings raised anywhere in the
class implementation are suppressed.
<p>We can suppress several types of annotations at a time.&nbsp; In this
case we must specify a list of warning labels.
<p>Example (of suppressing several types of warnings):
<blockquote><b><tt><nobr><font color="#000099">@SuppressWarnings(value={"unchecked","deprecation"})</font></nobr></tt></b>
<br><tt><font color="#000000">public static void someMethod() {</font></tt>
<br><tt><font color="#000000">&nbsp; ...</font></tt>
<br><tt><font color="#000000">&nbsp; TreeSet se</font>t = new TreeSet();</tt>
<br><tt>&nbsp; set.add(new Date(104,8,11));&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#660000">//
unchecked and deprecation warning suppressed</font></b></tt>
<br><tt><b><font color="#660000">&nbsp;</font></b><font color="#000000">
...</font></tt>
<br><tt><font color="#000000">}</font></tt></blockquote>
This example would usually raise 2 warnings when the call to method <tt>add</tt>
is compiled:
<blockquote><tt>warning: [deprecation] Date(int,int,int) in java.util.Date
has been deprecated</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set.add(new Date(104,8,11));</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>warning: [unchecked] unchecked call to add(E) as a member of the
raw type java.util.TreeSet</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set.add(new Date(104,8,11));</tt></blockquote>
&nbsp;The annotation preceding the enclosing method suppresses all unchecked
and deprecation warnings anywhere in the method implementation.
<p>Annotations can <i>not</i> be attached to statements, expressions, or
blocks, only to program entities with a definition like types, variables,
etc.&nbsp;
<p>Example (of illegal placement of annotation):
<blockquote><tt><font color="#000000">public static void someMethod() {</font></tt>
<br><tt><font color="#000000">&nbsp; ...</font></tt>
<br><tt><font color="#000000">&nbsp; TreeSet se</font>t = new TreeSet();&nbsp;</tt>
<br><b><tt><nobr><font color="#000099">&nbsp; @SuppressWarnings(value={"unchecked"})
</font></nobr><font color="#660000">//
error</font></tt></b>
<br><tt>&nbsp; set.add(new Date(104,8,11));&nbsp;</tt>
<br><tt><b><font color="#660000">&nbsp;</font></b><font color="#000000">
...</font></tt>
<br><tt><font color="#000000">}</font></tt></blockquote>
Annotations can be attached to the definition of packages, classes, interfaces,
fields, methods, parameters, constructors, local variables, enum types,
enum constants, and&nbsp; annotation types. An annotated package declaration
must go into a file named <tt>package-info.java</tt> in the directory that
represents the package.
<p>Note, in the first release of Java 5.0 the <tt>SuppressWarnings</tt>
annotation is not yet supported.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ004">#FAQ004</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#What is an unchecked warning?">What
is an "unchecked" warning?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#How can I disable or enable unchecked warnings?">How
can I disable or enable unchecked warnings?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ005"></a>
<h2>
<a NAME="How can I avoid unchecked cast warnings?"></a><font face="Arial,Helvetica"><font size=+0>How
can I avoid "unchecked cast" warnings?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>By using an unbounded wildcard parmeterized
type as target type of a cast expression.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Occasionally, we would like to cast to a parameterized
type, just to discover that the compiler flags it with an "unchecked" warning.
As we are interested in warning-free compilation of our source code, we
would like to avoid this warning.&nbsp; Use of an unbounded wildcard parameterized
type instead of a concrete or a bounded wildcard parameterized type would
help avoid the warning.
<p>A typical example is the implementation of methods such as the <tt>equals</tt>
method, that take <tt>Object</tt> reference and where a cast down to the
actual type must be performed.
<p>Example (not recommended):
<blockquote><tt>class Wrapper&lt;T> {</tt>
<br><tt>&nbsp; private T wrapped;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp; public boolean equals<font color="#000000">(Object other)
{</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; ...</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; </font>Wrapper<font color="#000000">&lt;T>
other</font>Wrapper<font color="#000000"> = </font><b><font color="#000099">(Wrapper&lt;T>)</font></b>other;
<b><font color="#660000">//
warning; unchecked cast</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; return (this.wrapped.equals(<font color="#000000">other</font>Wrapper.wrapped));</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
When we replace the cast to <tt>Wrapper&lt;T></tt> by a cast to <tt>Wrapper&lt;?></tt>
the warning disappears, because unbounded wildcard parameterized types
are permitted as target type of a cast without any warnings.
<p>Example (implementation of <tt>equals</tt>):
<blockquote><tt>class Wrapper&lt;T> {</tt>
<br><tt>&nbsp; private T wrapped;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp; public boolean equals<font color="#000000">(Object other)
{</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; ...</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; </font>Wrapper<font color="#000000">&lt;?>
other</font>Wrapper<font color="#000000"> = </font><b><font color="#000099">(Wrapper&lt;?>)</font></b><font color="#000000">other;</font></tt>
<br><tt>&nbsp;&nbsp;&nbsp; return (this.wrapped.equals(<font color="#000000">other</font>Wrapper.wrapped));</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
Note, this technique works in this example only because we need no write
access to the fields of the object refered to through the wildcard parameterized
type and we need not invoke any methods.&nbsp; Remember, use of the object
that a wildcard reference variable refers to is restricted.&nbsp; In other
situations use of a wildcard parameterized type might not be a viable solution,
because full access to the referenced object is needed.&nbsp;</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ005">#FAQ005</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#Can I cast to a parameterized type?">Can
I cast to a parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#What is an unchecked warning?">What
is an "unchecked" warning?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#How can I disable or enable unchecked warnings?">How
can I disable or enable unchecked warnings?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ProgrammingIdioms.html#How do I best implement the equals method of a parameterized type?">How
do I best implement the equals method of a generic type?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ006"></a>
<h2>
<a NAME="Is it possible to eliminate all unchecked warnings?"></a><font face="Arial,Helvetica"><font size=+0>Is
it possible to eliminate all "unchecked" warnings?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Almost.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">"Unchecked" warnings stem either from using generic types
in their raw form or from casts whose target type is a type parameter or
a concrete or bounded wildcard parameterized type. If you refrain from
both using raw types and the critical casts you can theoretically eliminate
all "unchecked" warnings.&nbsp; Whether this is doable in practice depends
on the circumstances.
<p><b>Raw types.</b>
<p>When source code is compiled for use in Java 5.0 that was developed
before Java 5.0 and uses classes that are generic in Java 5.0, then "unchecked"
warnings are inevitable.&nbsp; For instance, if "legacy" code uses types
such as <tt>List</tt>, which used to be a regular (non-generic) types before
Java 5.0, but are generic in Java 5.0, all these uses of <tt>List </tt>are
considered uses of a raw type in Java 5.0.&nbsp; Use of the raw types will
lead to "unchecked" warnings.&nbsp; If you want to eliminate the "unchecked"
warnings you must re-engineer the "legacy" code and replace all raw uses
of <tt>List</tt> with appropriate instantiations of <tt>List</tt> such
as <tt>List&lt;String></tt>, <tt>List&lt;Object></tt>,
<tt>List&lt;?></tt>,
etc.&nbsp; All "unchecked" warnings can be eliminated this way.
<p>In source code developed for Java 5.0 you can prevent "unchecked" warnings
in the first place by never using raw types.&nbsp; Always provide type
arguments when you use a generic type.&nbsp; There are no situations in
which you are forced to use a raw type.&nbsp; In case of doubt, when you
feel you have no idea which type argument would be appropriate, try the
unbounded wildcard "<tt>?</tt>".
<p>In essence, "unchecked" warnings due to use of raw types can be eliminated
if you have access to legacy code and are willing to re-engineer it.
<p><b>Casts.</b>
<p>"Unchecked" warnings as a result of cast expressions can be eliminated
by eliminating the offensive casts.&nbsp; Eliminating such casts is almost
always possible.&nbsp; There are, however, a few situations where a cast
to a type parameter or a concrete or bounded wildcard parameterized type
cannot be avoided.&nbsp;
<p>These are typically situations where a method returns a supertype reference
to an object of a more specific type. The classic example is the <tt>clone</tt>
method; it returns an <tt>Object</tt> reference to an object of the type
on which it was invoked. In order to recover the returned object's actual
type a cast in necessary.&nbsp; If the cloned object is of a parameterized
type, then the target type of the cast is an instantiation of that parameterized
type, and an "unchecked" warning is inevitable.&nbsp; The <tt>clone</tt>
method is just one example that leads to unavoidable "unchecked" warnings.
Invocation of methods via reflection has similar effects because the return
value of a reflectively invoked method is returned via an <tt>Object</tt>
reference.&nbsp; It is likely that you will find further examples of unavoidable
"unchecked" casts in practice. For a detailed discussion of an example
see <font face="Arial,Helvetica"><font size=-2><a href="ProgrammingIdioms.html#How do I best implement the clone method of a parameterized type">#FAQ502</a></font></font>,
which explains the implementation of a <tt>clone</tt> method for a generic
class.
<p>In sum, there are situations in which you cannot eliminate "unchecked"
warnings due to a cast expression.
<br>&nbsp;</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ006">#FAQ006</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="TechnicalDetails.html#What is an unchecked warning?">What
is an "unchecked" warning?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ProgrammingIdioms.html#How do I best implement the clone method of a parameterized type">How
do I best implement the clone method of a generic type?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350>
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450></h3>

<h3>
<a NAME="Type Erasure"></a>Type Erasure</h3>

<h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450><a NAME="FAQ100"></a></h3>
<a NAME="How does the compiler translate Java generics?"></a><b><font face="Arial,Helvetica">How
does the compiler translate Java generics?</font></b>
<br>&nbsp;
<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>By creating one unique byte code representation
of each generic type (or method) and mapping all instantiations of the
generic type (or method) to this unique representation.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">The Java compiler is responsible for translating Java source
code that contains definitions and usages of generic types and methods
into Java byte code that the virtual machine can interpret. How does that
translation work?&nbsp;
<p>A compiler that must translate a generic type or method (in any language,
not just Java) has in principle two choices:
<br>&nbsp;
<li>
<i>Code specialization. </i>The compiler generates a new representation
for every instantiation of a generic type or method. For instance, the
compiler would generate code for a list of integers and additional, different
code for a list of strings, a list of dates, a list of buffers, and so
on.&nbsp;</li>

<li>
<i>Code sharing.</i> The compiler generates code for only one representation
of a generic type or method and maps all the instantiations of the generic
type or method to the unique representation, performing type checks and
type conversions where needed.</li>

<p><br>Code specialization is the approach that C++ takes for its templates:
<br>The C++ compiler generates executable code for every instantiation
of a template. The downside of code specialization of generic types is
its potential for code bloat.&nbsp; A list of integers and a list of strings
would be represented in the executable code as two different types. Note
that code bloat is not inevitable in C++ and can generally be avoided by
an experienced programmer.
<p>Code specialization is particularly wasteful in cases where the elements
in a collection are references (or pointers), because all references (or
pointers) are of the same size and internally have the same representation.
There is no need for generation of mostly identical code for a list of
references to integers and a list of references to strings.&nbsp; Both
lists could internally be represented by a list of references to any type
of object. The compiler just has to add a couple of casts whenever these
references are passed in and out of the generic type or method. Since in
Java most types are reference types, it deems natural that Java chooses
code sharing as its technique for translation of generic types and methods.&nbsp;
<p>The Java compiler applies the code sharing technique and creates one
unique byte code representation of each generic type (or method).&nbsp;
The various instantiations of the generic type (or method) are mapped onto
this unique representation by a technique that is called <i>type erasure</i>.
<br>&nbsp;</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ100">#FAQ100</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#What is type erasure?">What
is type erasure?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ101"></a>
<h2>
<a NAME="What is type erasure?"></a><font face="Arial,Helvetica"><font size=+0>What
is type erasure?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>A process that maps a parameterized type
(or method) to its unique byte code representation by eliding type parameters
and arguments.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">The compiler generates only one byte code representation
of a generic type or method and maps all the instantiations of the generic
type or method to the unique representation. This mapping is performed
by type erasure.&nbsp; The essence of type erasure is the removal of all
information that is related to type parameters and type arguments. In addition,
the compiler adds type checks and type conversions where needed and inserts
synthetic bridge methods if necessary. It is important to understand type
erasure because certain effects related to Java generics are difficult
to understand without a proper understanding of the translation process.
<p>The type erasure process can be imagined as a translation from generic
Java source code back into regular Java code.&nbsp; In reality the compiler
is more efficient and translates directly to Java byte code.&nbsp; But
the byte code created is equivalent to the non-generic Java code you will
be seeing in the subsequent examples.
<p>The steps performed during type erasure include:
<p><i>Eliding type parameters.</i>
<br>When the compiler finds the definition of a generic type or method,
it removes all occurrences of the type parameters and replaces them by
their leftmost bound, or type <tt>Object</tt> if no bound had been specified.&nbsp;
<p><i>Eliding type arguments.</i>
<br>When the compiler finds a paramterized type, i.e. an instantiation
of a generic type, then it removes the type arguments. For instance, the
types <tt>List&lt;String></tt>,
<tt>Set&lt;Long></tt>, and <tt>Map&lt;String,?></tt>
are translated to
<tt>List</tt>,
<tt>Set</tt> and <tt>Map</tt> respectively.&nbsp;
<p>Example (before type erasure):
<blockquote><tt>interface Comparable<font color="#006600">&lt;A></font>
{</tt>
<br><tt>&nbsp; public int compareTo(<font color="#006600">A</font> that);</tt>
<br><tt>}</tt>
<br><tt>final class NumericValue implements Comparable<font color="#000099">&lt;NumericValue></font>
{</tt>
<br><tt>&nbsp; priva<font color="#000000">te byte value;&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp; public&nbsp; </font>NumericValue<font color="#000000">(byte
value) { this.value = value; }&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp; public&nbsp; byte getValue() { return
value; }&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp; public&nbsp; int compareTo(</font>NumericValue<font color="#000000">
t</font>hat) { return this.value - that.value; }</tt>
<br><tt>}</tt>
<br><tt>class Collections {&nbsp;</tt>
<br><tt>&nbsp; public static <font color="#006600">&lt;A extends Comparable&lt;A>>A</font>
max(Collection<font color="#000099">&lt;A></font> xs) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Iterator<font color="#000099">&lt;A></font>
xi = xs.iterator();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; <font color="#006600">A</font> w = xi.next();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while (xi.hasNext()) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#006600">A</font> x
= xi.next();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (w.compareTo(x) &lt; 0) w = x;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return w;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br><tt>final class Test {</tt>
<br><tt>&nbsp; public static void main (String[ ] args) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; LinkedList<font color="#000099">&lt;NumericValue>
</font><font color="#000000">numberList</font>
= new LinkedList<font color="#000099">&lt;NumericValue></font>();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; <font color="#000000">numberList</font>.add(new
NumericValue((byte)0));&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; <font color="#000000">numberList</font>.add(new
NumericValue((byte)1));&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; NumericValue y = Collections.max(<font color="#000000">numberList</font>);&nbsp;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
Type parameters are <font color="#003300">green</font> and type arguments
are <font color="#000099">blue</font>.&nbsp; During type erasure the type
arguments are discarded and the type paramters are replaced by their leftmost
bound.
<p>Example (after type erasure):
<blockquote><tt>interface Comparable {</tt>
<br><tt>&nbsp; public int compareTo(<b><font color="#330033">Object</font></b>
that);</tt>
<br><tt>}</tt>
<br><tt>final class NumericValue implements Comparable {</tt>
<br><tt>&nbsp; priva<font color="#000000">te byte value;&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp; public&nbsp; </font>NumericValue<font color="#000000">(byte
value) { this.value = value; }&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp; public&nbsp; byte getValue() { return
value; }&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp; public&nbsp; int compareTo(</font>NumericValue<font color="#000000">
t</font>hat)&nbsp;&nbsp; { return this.value - that.value; }</tt>
<br><tt>&nbsp; <b><font color="#330033">public&nbsp; int compareTo(Object
that) { return this.compareTo((NumericValue)that);&nbsp; }</font></b></tt>
<br><tt>}</tt>
<br><tt>class Collections {&nbsp;</tt>
<br><tt>&nbsp; public static <b><font color="#330033">Comparable</font></b>
max(Collection xs) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Iterator xi = xs.iterator();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; <b><font color="#330033">Comparable</font></b>
w = <b><font color="#330033">(Comparable) </font></b>xi.next();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while (xi.hasNext()) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#330033">Comparable</font></b>
x = <b><font color="#330033">(Comparable) </font></b>xi.next();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (w.compareTo(x) &lt; 0) w = x;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return w;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br><tt>final class Test {</tt>
<br><tt>&nbsp; public static void main (String[ ] args) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; LinkedList<font color="#000099"> </font><font color="#000000">numberList</font>
= new LinkedList();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; <font color="#000000">numberList</font>.add(new
NumericValue((byte)0));&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; <font color="#000000">numberList</font>.add(new
NumericValue((byte)1));&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; NumericValue y = <b><font color="#330033">(NumericValue)</font></b>
Collections.max(<font color="#000000">numberList</font>);&nbsp;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
The generic <tt>Comparable</tt> interface is translated to a non-generic
interface and the unbounded type parameter <tt>A</tt> is replaced by type
<tt>Object</tt>.
<p>The <tt>NumericValue</tt> class implements the non-generic <tt>Comparable</tt>
interface after type erasure, and the compiler adds a so-called <i>bridge
method</i>. The bridge method is needed so that class <tt>NumericValue</tt>
remains a class that implements the <tt>Comparable</tt> interface after
type erasure.
<p>The generic method <tt>max</tt> is translated to a non-generic method
and the bounded type parameter <tt>A</tt> is replaced by its leftmost bound,
namely <tt>Comparable</tt>.&nbsp; The parameterized interface <tt>Iterator&lt;A>
</tt>
is translated to the raw type <tt>Iterator</tt> and the compiler adds a
cast whenever an element is retrieved from the raw type
<tt>Iterator</tt>.
<p>The uses of the parameterized type<tt> LinkedList&lt;NumericValue></tt>
and the generic <tt>max</tt> method in the <tt>main</tt> method are translated
to uses of the non-generic type and method and, again, the compiler must
add a cast.
<br>&nbsp;</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ101">#FAQ101</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#What is a bridge method?">What
is a bridge method?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Why does the compiler add casts when it translates generics?">Why
does the compiler add casts when it translates generics?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#How does type erasure work when a type parameter has several bounds?">How
does type erasure work when a type parameter has several bounds?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ102"></a>
<h2>
<a NAME="What is a bridge method?"></a><font face="Arial,Helvetica"><font size=+0>What
is a bridge method?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>A synthetic method that the compiler
generates in the course of type erasure.&nbsp; It is sometimes needed when
a type extends or implements a parameterized class or interface.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">The compiler insert bridge methods in subtypes of parameterized
supertypes to ensure that subtyping works as expected.&nbsp;
<p>Example (before type erasure):
<blockquote><tt>interface Comparable<b><font color="#006600">&lt;A></font></b>
{</tt>
<br><tt>&nbsp; public int compareTo(<b><font color="#006600">A</font> </b>that);</tt>
<br><tt>}</tt>
<br><tt>final class NumericValue implements Comparable<b><font color="#000099">&lt;NumericValue></font></b>
{</tt>
<br><tt>&nbsp; priva<font color="#000000">te byte value;&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp; public&nbsp; </font>NumericValue<font color="#000000">(byte
value) { this.value = value; }</font></tt>
<br><tt><font color="#000000">&nbsp; public&nbsp; byte getValue() { return
value; }&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp; public&nbsp; int compareTo(</font><b><font color="#000099">NumericValue</font></b><font color="#000000">
t</font>hat) { return this.value - that.value; }</tt>
<br><tt>}</tt></blockquote>
In the example, class <tt>NumericValue</tt> implements interface <tt>Comparable&lt;NumericValue></tt>
and must therefore override the superinterfaces <tt>compareTo</tt> method.&nbsp;
The method takes a <tt>NumericValue</tt> as an argument. In the process
of type erasure, the compiler translates the parameterized <tt>Comparable&lt;A></tt>
interface to its type erased counterpart <tt>Comparable</tt>.&nbsp; The
type erasure changes the signature of the interface's <tt>compareTo</tt>
method.&nbsp; After type erasure the method takes an <tt>Object</tt> as
an argument.
<p>Example (after type erasure):
<blockquote><tt>interface Comparable {</tt>
<br><tt>&nbsp; public int compareTo(<b><font color="#330033">Object</font></b>
that);</tt>
<br><tt>}</tt>
<br><tt>final class NumericValue implements Comparable {</tt>
<br><tt>&nbsp; priva<font color="#000000">te byte value;&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp; public&nbsp; </font>NumericValue<font color="#000000">(byte
value) { this.value = value; }&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp; public&nbsp; byte getValue() { return
value; }&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp; public&nbsp; int compareTo(</font>NumericValue<font color="#000000">
t</font>hat)&nbsp;&nbsp; { return this.value - that.value; }</tt>
<br><tt>&nbsp; <b><font color="#330033">public&nbsp; int compareTo(Object
that) { return this.compareTo((NumericValue)that);&nbsp; }</font></b></tt>
<br><tt>}</tt></blockquote>
After this translation, method&nbsp; <tt>NumericValue.compareTo(NumericValue)</tt>
is no longer an implementation of the interface's <tt>compareTo </tt>method.&nbsp;
The type erased <tt>Comparable </tt>interface requires a <tt>compareTo
</tt>method
with argument type <tt>Object</tt>, not <tt>NumericValue</tt>. This is
a side effect of type erasure: the two methods (in the interface and the
implementing class) have identical signatures before type erasure and different
signatures after type erasure.&nbsp;
<p>In order to achieve that class <tt>NumericValue</tt> remains a class
that correctly implements the <tt>Comparable</tt> interface, the compiler
adds a bridge method to the class.&nbsp; The bridge method has the same
signature as the interfaces method after type erasure, because that's
the method that must be implemented. The bridge method delegates to the
orignal methods in the&nbsp; implementing class.
<p>
<hr WIDTH="100%">
<p>The existence of the bridge method does not mean that objects of arbitrary
types can be passed as arguments to the <tt>compareTo</tt> method in <tt>NumericValue</tt>.&nbsp;
The bridge method is an implementation detail and the compiler makes sure
that it normally cannot be invoked.
<p>Example (illegal attempt to invoke bridge method):
<blockquote><tt>NumericValue value = new NumericValue((byte)0);</tt>
<br><tt>value.compareTo(value);&nbsp; <b><font color="#003300">// fine</font></b></tt>
<br><tt>value.compareTo("abc");&nbsp; <b><font color="#330000">// error</font></b></tt></blockquote>
The compiler does not invoke the bridge method when an object of a type
other than <tt>NumericValue</tt> is passed to the <tt>compareTo</tt> method.
Instead it rejects the call with an error message, saying that the <tt>compareTo</tt>
method expects a <tt>NumericValue</tt> as an argument and other types of
arguments are not permitted.&nbsp;
<p>You can, however, invoke the synthetic bridge message using reflection.&nbsp;
But, if you provide an argument of a type other than <tt>NumericValue</tt>,
the method will fail with a <tt>ClassCastException</tt> thanks of the cast
in the implementation of the bridge method.
<p>Example (failed attempt to invoke bridge method via reflection):
<blockquote><tt>int reflectiveCompareTo(NumericValue value, Object other)</tt>
<br><tt>&nbsp; throws NoSuchMethodException, IllegalAccessException, InvocationTargetException</tt>
<br><tt>{</tt>
<br><tt>&nbsp; Method meth = NumericValue.class.getMethod("compareTo",
new Class[]{Object.class});</tt>
<br><tt>&nbsp; return (Integer)meth.invoke(value, new Object[]{other});&nbsp;</tt>
<br><tt>}</tt>
<br><tt>NumericValue value = new NumericValue((byte)0);</tt>
<br><tt>reflectiveCompareTo(value, value);&nbsp; <b><font color="#003300">//
fine</font></b></tt>
<br><tt>reflectiveCompareTo(value,"abc");&nbsp;&nbsp; <b><font color="#330000">//
ClassCastException</font></b></tt></blockquote>
<font color="#000000">The cast to type <tt>NumericValue</tt> in the bridge
method fails with a <tt>ClassCastException</tt>&nbsp; when </font>an argument
of a type other than <tt>NumericValue</tt> is passed to the bridge method.&nbsp;
This was it is guaranteed that a bridge method, even when it is called,
will fail for unexpected argument types.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ102">#FAQ102</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#What is type erasure?">What
is type erasure?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Under which circumstances is a bridge method generated?">Under
which circumstances is a bridge method generated?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ103"></a>
<h2>
<a NAME="Under which circumstances is a bridge method generated?"></a><font face="Arial,Helvetica"><font size=+0>Under
which circumstances is a bridge method generated?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>When a type extends or implements a parameterized
class or interface and type erasure changes the signature of any inherited
method.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Bridge methods are necessary when a class implements a
parameterized interface or extends a parameterized superclass and type
ersure changes the argument type of any of the inherited non-static methods.
<p>Below is an example of a class that extends a parameterized superclass.
<p>Example (before type erasure):
<blockquote><tt>class Superclass<b><font color="#006600">&lt;T extends
Bound></font></b> {</tt>
<br><tt>&nbsp; public void m1(<b><font color="#006600">T</font></b> arg)
{ ... }</tt>
<br><tt>&nbsp; public <b><font color="#006600">T</font> </b>m2() { ...
}</tt>
<br><tt>}</tt>
<br><tt>class Subclass extends Superclass<b><font color="#000099">&lt;SubTypeOfBound></font></b>
{</tt>
<br><tt>&nbsp;&nbsp; public void<font color="#000000"> m1(</font><b><font color="#000099">SubTypeOfBound</font></b><font color="#000000">
arg) { ... }</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp; public </font><b><font color="#000099">SubTypeOfBound</font></b><font color="#000000">
m</font>2() { ... }</tt>
<br><tt>}&nbsp;</tt></blockquote>
Example (after type erasure):
<blockquote><tt>class Superclass {</tt>
<br><tt>&nbsp; void m1(<b><font color="#330033">Bound</font></b> arg) {
... }</tt>
<br><tt>&nbsp; <b><font color="#330033">Bound</font></b> m2() { ... }</tt>
<br><tt>}&nbsp;</tt>
<br><tt>class Subclass extends Superclass {</tt>
<br><tt>&nbsp; public void m1(SubTypeOfBound arg) { ... }</tt>
<br><tt>&nbsp; <b><font color="#330033">public void m1(Bound arg) { m1((SubTypeOfBound)arg);
}</font></b></tt>
<br><tt>&nbsp; public SubTypeOfBound m2() { ... }</tt>
<br><tt>&nbsp; <b><font color="#330033">public Bound&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
m2() { return m2(); }</font></b></tt>
<br><tt>}&nbsp;</tt></blockquote>
Type erasure changes the signature of the superclass's methods.&nbsp; The
subclass's methods are no longer overriding versions of the superclass's
method after type erasure. In order to make overriding work the compiler
adds bridge methods.
<p>The compiler must add bridge methods even if the subclass does not override
the inherited methods.
<p>Example (before type erasure):
<blockquote><tt>class Superclass<b><font color="#006600">&lt;T extends
Bound></font></b> {</tt>
<br><tt>&nbsp; public void m1(<b><font color="#006600">T</font></b> arg)
{ ... }</tt>
<br><tt>&nbsp; public <b><font color="#006600">T</font> </b>m2() { ...
}</tt>
<br><tt>}</tt>
<br><tt>class AnotherSubclass extends Superclass<b><font color="#000099">&lt;SubTypeOfBound></font></b>
{</tt>
<br><tt>}</tt></blockquote>
Example (after type erasure):
<blockquote><tt>class Superclass {</tt>
<br><tt>&nbsp; void m1(<b><font color="#330033">Bound</font></b> arg) {
... }</tt>
<br><tt>&nbsp; <b><font color="#330033">Bound</font></b> m2() { ... }</tt>
<br><tt>}</tt>
<br><tt>class AnotherSubclass extends Superclass {</tt>
<br><tt>&nbsp; <b><font color="#330033">public void&nbsp; m1(Bound arg)
{ super.m1((SubTypeOfBound)arg); }</font></b></tt>
<br><b><tt><font color="#330033">&nbsp; public Bound m2() { return super.m2();
}</font></tt></b>
<br><tt>}</tt></blockquote>
The subclass is derived from a particular instantiation of the superclass
and therefore inherits the methods with a particular signature.&nbsp; After
type erasure the signature of the superclass's methods are different from
the signatures that the subclass is supposed to have inherited.&nbsp; The
compiler adds bridge methods, so that the subclass has the expected inherited
methods.
<p>No bridge method is needed when type erasure does not change the signature
of any of the methods of the parameterized supertype.&nbsp; Also, no bridge
method is needed if the signatures of methods in the sub- and supertype
change in the same way.&nbsp; This can occur when the subtype is generic
itself.
<p>Example (before type erasure):
<blockquote><tt>interface Callable<b><font color="#006600">&lt;V></font></b>
{</tt>
<br><tt>&nbsp; public <b><font color="#006600">V</font></b> call();</tt>
<br><tt>}</tt>
<br><tt>class Task<b><font color="#000066">&lt;T></font></b> implements
Callable<b><font color="#000066">&lt;T></font></b> {</tt>
<br><tt>&nbsp; public <b><font color="#000066">T</font></b> call() { ...
}</tt>
<br><tt>}</tt></blockquote>
Example (after type erasure):
<blockquote><tt>interface Callable {</tt>
<br><tt>&nbsp; public <b><font color="#330033">Object </font></b>call();</tt>
<br><tt>}</tt>
<br><tt>class Task implements Callable {</tt>
<br><tt>&nbsp; public <b><font color="#330033">Object</font></b> call()
{ ... }</tt>
<br><tt>}</tt></blockquote>
The return type of the <tt>call</tt> method changes during type erasure
in the interface and the implementing class.&nbsp; After type erasure the
two methods have the same signature so that the subclass's method implements
the interface's method without a brdige method.
<p>However, it does not suffice that the subclass is generic.&nbsp; The
key is that the method signatures must not match after type erasure.&nbsp;
Otherwise, we again need a bridge method.
<p>Example (before type erasure):
<blockquote><tt>interface Copyable<b><font color="#006600">&lt;V></font></b>
extends Cloneable {</tt>
<br><tt>&nbsp; public <b><font color="#006600">V</font></b> copy();</tt>
<br><tt>}</tt>
<br><tt>class Triple<b><font color="#000066">&lt;T extends Copyable&lt;T>></font></b>
implements Copyable<b><font color="#000066">&lt;Triple&lt;T>></font></b>
{</tt>
<br><tt>&nbsp; public <b><font color="#000066">T</font></b> copy() { ...
}</tt>
<br><tt>}</tt></blockquote>
Example (after type erasure):
<blockquote><tt>interface Copyable extends Cloneable {</tt>
<br><tt>&nbsp; public <b><font color="#330033">Object </font></b>copy();</tt>
<br><tt>}</tt>
<br><tt>class Triple implements Copyable {</tt>
<br><tt>&nbsp; public <b><font color="#330033">Copyable</font></b> copy()
{ ... }</tt>
<br><tt>&nbsp; <b><font color="#330033">public Object&nbsp;&nbsp; copy()
{ return copy(); }</font></b></tt>
<br><tt>}</tt></blockquote>
The method signatures change to <tt>Object copy() </tt>in the interface
and <tt>Copyable copy()</tt> in the subclass (because of the type parameter
bound). As a result, the compiler adds a bridge method.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ103">#FAQ103</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#What is type erasure?">What
is type erasure?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ104"></a>
<h2>
<a NAME="Why does the compiler add casts when it translates generics?"></a><font face="Arial,Helvetica"><font size=+0>Why
does the compiler add casts when it translates generics?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Because the return type of methods of
a parameterized type might change as a side effect of type erasure.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">During type erasure the compiler replaces type parameters
by the leftmost bound, or type <tt>Object</tt> if no bound was specified.
This means that methods whose return type is the type parameter would return
a reference that is either the leftmost bound or <tt>Object</tt>, instead
of the more specific type that was specified in the parameterized type
and that the caller expects.&nbsp; A cast is need from the leftmost bound
or <tt>Object</tt> down to the more specific type..
<p>Example (before type erasure):
<blockquote><tt>public class Pair&lt;X,Y> {</tt>
<br><tt>&nbsp; private X first;</tt>
<br><tt>&nbsp; private Y second;</tt>
<br><tt>&nbsp; public Pair(X x, Y y) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; first = x;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; second = y;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; public X getFirst() { return first; }</tt>
<br><tt>&nbsp; public Y getSecond() { return second; }</tt>
<br><tt>&nbsp; public void setFirst(X x) { first = x; }</tt>
<br><tt>&nbsp; public void setSecond(Y y) { second = y; }</tt>
<br><tt>}</tt>
<p><tt>final class Test {</tt>
<br><tt>&nbsp; public static void main(String[] args) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Pair&lt;String,Long> pair = new Pair&lt;String,Long>("limit",
10000L);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; String s = pair.getFirst();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Long&nbsp;&nbsp; l = pair.getSecond();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Object o = pair.getSecond();</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
Example (after type erasure):
<blockquote><tt>public class Pair {</tt>
<br><tt>&nbsp; private <b><font color="#330033">Object</font></b> first;</tt>
<br><tt>&nbsp; private <b><font color="#330033">Object</font></b> second;</tt>
<br><tt>&nbsp; public Pair(<b><font color="#330033">Object</font></b> x,
<b><font color="#330033">Object</font></b>
y) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; first = x;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; second = y;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; public <b><font color="#330033">Object</font></b> getFirst()
{ return first; }</tt>
<br><tt>&nbsp; public <b><font color="#330033">Object</font></b> getSecond()
{ return second; }</tt>
<br><tt>&nbsp; public void setFirst(<b><font color="#330033">Object</font></b>
x) { first = x; }</tt>
<br><tt>&nbsp; public void setSecond(<b><font color="#330033">Object</font></b>
y) { second = y; }</tt>
<br><tt>}</tt>
<p><tt>final class Test {</tt>
<br><tt>&nbsp; public static void main(String[] args) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Pair pair = new Pair("limit", 10000L);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; String s = <b><font color="#330033">(String)
</font></b>pair.getFirst();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Long&nbsp;&nbsp; l = <b><font color="#330033">(Long)</font></b>&nbsp;&nbsp;
pair.getSeond();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Object o =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
pair.getSecond();</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
After type erasure the methods <tt>getFirst</tt> and <tt>getSecond </tt>of
type <tt>Pair</tt> both have the return type <tt>Object</tt>.&nbsp; Since
the declared static type of the pair in our test case is <tt>Pair&lt;String,Long></tt>
the caller of <tt>getFirst</tt> and <tt>getSecond</tt> expects a <tt>String</tt>
and a
<tt>Long</tt> as the return value.&nbsp; Without a cast this would
not work and in order to make it work the compiler adds the necessary casts
from <tt>Object</tt> to <tt>String</tt> and
<tt>Long </tt>respectively.
<p>The inserted casts cannot fail at runtime with a <tt>ClassCastException</tt>
because the compiler already made sure at compile-time that both fields
are references to objects of the expected type.&nbsp; The compiler would
issue an error method if arguments of types other than <tt>String</tt>
or <tt>Long</tt> had been passed to the constructor or the <tt>set</tt>
methods.&nbsp; Hence it is guarantees that these casts cannot fail.
<p>In general, casts silently added by the compiler are guaranteed not
to raise a <tt>ClassCastException</tt> if the program was compiled without
warnings.&nbsp; This is the type-safety guarantee.
<p>Implicit casts are inserted when methods are invoked whose <i>return
type</i> changed during type erasure. Invocation of methods whose <i>argument
type</i> changed during type erasure do not require insertion of any casts.&nbsp;
For instance, after type erasure the <tt>setFirst</tt> and <tt>setSecond&nbsp;</tt>
methods of class <tt>Pair</tt> take <tt>Object</tt> arguments. Invoking
them with arguments of a more specific type such as <tt>String</tt> and
<tt>Long</tt>
is possible without the need for any casts.&nbsp;</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ104">#FAQ104</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#What is type erasure?">What
is type erasure?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="Fundamentals.html#What does type-safety mean?">What
does type-safety mean?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ105"></a>
<h2>
<a NAME="How does type erasure work when a type parameter has several bounds?"></a><font face="Arial,Helvetica"><font size=+0>How
does type erasure work when a type parameter has several bounds?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>The compiler adds casts as needed.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">In the process of type erasure the compiler replaces type
parameters by their leftmost bound, or type <tt>Object</tt> if no bound
was specified. How does that work if a type parameter has several bounds?
<p>Example (before type erasure):
<blockquote><tt>interface Runnable {&nbsp;</tt>
<br><tt>&nbsp; void run();</tt>
<br><tt>}</tt>
<br><tt>interface Callable&lt;V> {</tt>
<br><tt>&nbsp; V call();</tt>
<br><tt>}</tt>
<br><tt>class X&lt;T extends Callable&lt;Long> &amp; Runnable> {</tt>
<br><tt>&nbsp; private T task1, task2;</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>&nbsp; public void do() {&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; task1.run();&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Long result = task2.call();</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}&nbsp;</tt></blockquote>
Example (after type erasure):
<blockquote><tt>interface Runnable {&nbsp;</tt>
<br><tt>&nbsp; void run();</tt>
<br><tt>}</tt>
<br><tt>interface Callable {</tt>
<br><tt>&nbsp; <b><font color="#330033">Object</font></b> call();</tt>
<br><tt>}</tt>
<br><tt>class X {</tt>
<br><tt>&nbsp; private <b><font color="#330033">Callable</font></b> task1,
task2;</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>&nbsp; public void do() {&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; (<b><font color="#330033">(Runnable)</font></b>task1).run();&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Long result = <b><font color="#330033">(Long)</font></b>
task2.call();</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
The type parameter <tt>T</tt> is replaced by the bound <tt>Callable</tt>,
which means that both fields are held as references of type <tt>Callable</tt>.&nbsp;
Methods of the leftmost bound (which is <tt>Callable</tt> in our example)
can be called directly.&nbsp; For invocation of methods of the other bounds
(<tt>Runnable</tt> in our example) the compiler adds a cast to the respective
bound type, so that the methods are accessible. The inserted cast cannot
fail at runtime with a <tt>ClassCastException</tt> because the compiler
already made sure at compile-time that both fields are references to objects
of a type that is within both bounds.
<p>&nbsp;In general, casts silently added by the compiler are guaranteed
not to raise a <tt>ClassCastException</tt> if the program was compiled
without warnings.&nbsp; This is the type-safety guarantee.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ105">#FAQ105</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="Fundamentals.html#What does type-safety mean?">What
does type-safety mean?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ106"></a>
<h2>
<a NAME="What is a reifiable type?"></a><font face="Arial,Helvetica"><font size=+0>What
is a reifiable type?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>A type that does not lose information
in the course of type erasure.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">As a side effect of type erasure, some type information
that is present in the source code is no longer available at runtime.&nbsp;
For instance, parameterized types are translated to their corresponding
raw type in a process called <i>type erasure</i> and lose the information
regarding their type arguments.&nbsp;
<p>For example, types such as <tt>List&lt;String></tt> or <tt>Pair&lt;?
extends Number, ? extends Number></tt> are available to and used by the
compiler in their exact form, including the type argument information.&nbsp;
After type erasure, the virtual machine has only the raw types <tt>List</tt>
and <tt>Pair</tt> available, which means that part of the type information
is lost.&nbsp;
<p>In contrast, non-parameterized types such as <tt>java.util.Date</tt>
or <tt>java.lang.Thread.State</tt> are not affected by type erasure.&nbsp;
Their type information remains exact, because they do not have type arguments.&nbsp;
<p>Among the instantiations of a generic type only the unbounded wildcard
instantiations, such as <tt>Map&lt;?,?> </tt>or <tt>Pair&lt;?,?></tt>,
are unaffected by type erasure.&nbsp; They do lose their type arguments,
but since all type arguments are unbounded wildcards, no information is
lost.
<p>Types that do NOT lose any information during type erasure are called
<i>reifiable
types</i>. The following types are reifiable:
<ul>
<li>
primitive types</li>

<li>
non-generic (or non-parameterized) reference types</li>

<li>
unbounded wildcard instantiations</li>

<li>
raw types</li>

<li>
arrays of any of the above</li>
</ul>
The non-reifiable types, which lose type information as a side effect of
type erasure, are:
<ul>
<li>
instantiations of a generic type with at least one concrete type argument</li>

<li>
instantiations of a generic type with at least one bounded wildcard as
type argument</li>
</ul>
Reifiable types are permitted in some places where non-reifiable types
are disallowed.&nbsp; Reifiable types are permitted (and non-reifiable
types are prohibited):
<ul>
<li>
as type in an <tt>instanceof</tt> expression</li>

<li>
as component type of an array</li>
</ul>
</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ106">#FAQ106</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#What is type erasure?">What
is type erasure?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is an unbounded wildcard instantiation?">What
is an unbounded wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is the raw type?">What
is the raw type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which types can or must not appear as target type in an instanceof expression?">Which
types can or must not appear as target type in an instanceof expression?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#Can I create an array whose component type is a concrete instantiation of a parameterized type?">Can
I create an array whose component type is a concrete parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#Can I create an array whose component type is a wildcard instantiation of a parameterized type?">Can
I create an array whose component type is a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#Why is it allowed to create an array whose component type is an unbounded wildcard instantiation?">Why
is it allowed to create an array whose component type is an unbounded wildcard
parameterized type?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ107"></a>
<h2>
<a NAME="What is the type erasure of a parameterized type?"></a><font face="Arial,Helvetica"><font size=+0>What
is the type erasure of a parameterized type?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>The type without any type arguments.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">The erasure of a parameterized type is the type without
any type arguments (i.e. the raw type). This definition extends to arrays
and nested types.
<p>Examples:
<blockquote>&nbsp;
<table BORDER=0 CELLSPACING=5 >
<tr BGCOLOR="#CCCCCC">
<td><i>parameterized type</i></td>

<td><i>type erasure</i></td>
</tr>

<tr>
<td><tt>List&lt;String></tt></td>

<td><tt>List</tt></td>
</tr>

<tr>
<td><tt>Map.Entry&lt;String,Long></tt></td>

<td><tt>Map.Entry</tt></td>
</tr>

<tr>
<td><tt>Pair&lt;Long,Long>[]</tt></td>

<td><tt>Pair[]</tt></td>
</tr>

<tr>
<td><tt>Comparable&lt;? super Number></tt></td>

<td><tt>Comparable</tt></td>
</tr>
</table>
</blockquote>
The type erasure of a non-parameterized type is the type itself.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ107">#FAQ107</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is the raw type?">What
is the raw type?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ108"></a>
<h2>
<a NAME="What is the type erasure of a type parameter?"></a><font face="Arial,Helvetica"><font size=+0>What
is the type erasure of a type parameter?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>The type erasure of its leftmost bound,
or type <tt>Object</tt> if no bound was specified.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">The type erasure of a type parameter is the erasure of
its leftmost bound. The type erasure of an unbounded type parameter is
type <tt>Object</tt>.
<p>Examples:
<blockquote>&nbsp;
<table BORDER=0 CELLSPACING=5 >
<tr BGCOLOR="#CCCCCC">
<td><i>type parameters</i></td>

<td><i>type erasure</i></td>
</tr>

<tr>
<td><tt>&lt;T></tt></td>

<td><tt>Object</tt></td>
</tr>

<tr>
<td><tt>&lt;T extends Number></tt></td>

<td><tt>Number</tt></td>
</tr>

<tr>
<td><tt>&lt;T extends Comparable&lt;T>></tt></td>

<td><tt>Comparable</tt></td>
</tr>

<tr>
<td><tt>&lt;T extends Cloneable &amp; Comparable&lt;T>></tt></td>

<td><tt>Cloneable</tt></td>
</tr>

<tr>
<td><tt>&lt;T extends Object &amp; Comparable&lt;T>></tt></td>

<td><tt>Object</tt></td>
</tr>

<tr>
<td><tt>&lt;S, T extends S></tt></td>

<td><tt>Object,Object</tt></td>
</tr>
</table>
</blockquote>
</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ108">#FAQ108</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="TypeParameters.html#What is a bounded type parameter?">What
is a bounded type parameter?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ109"></a>
<h2>
<a NAME="What is the type erasure of a parameterized method?"></a><font face="Arial,Helvetica"><font size=+0>What
is the type erasure of a generic method?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>A method with the same name and the types
of all method parameters replaced by their respective type erasures.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">The erasure of a method signature is a signature consisting
of the same name and the erasures of all the formal method parameter types.
<p>Examples:
<blockquote>&nbsp;
<table BORDER=0 CELLSPACING=5 >
<tr BGCOLOR="#CCCCCC">
<td><i>parameterized method</i></td>

<td><i>type erasure</i></td>
</tr>

<tr>
<td><tt>Iterator&lt;E> iterator()</tt></td>

<td><tt>Iterator iterator()</tt></td>
</tr>

<tr>
<td><tt>&lt;T> T[] toArray(T[] a)&nbsp;</tt></td>

<td><tt>Object[] toArray(Object[] a)</tt></td>
</tr>

<tr>
<td><tt>&lt;U> AtomicLongFieldUpdater&lt;U>&nbsp;</tt>
<br><tt>newUpdater(Class&lt;U> tclass, String fieldName)</tt></td>

<td><tt>AtomicLongFieldUpdater</tt>
<br><tt>newUpdater(Class tclass,String fieldName)</tt></td>
</tr>
</table>
</blockquote>
</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ109">#FAQ109</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#What is type erasure?">What
is type erasure?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#What is the type erasure of a parameterized type?">What
is the type erasure of a parameterized type?&nbsp;</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#What is the type erasure of a parameterized type?">What
is the type erasure of a type parameter?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ110"></a>
<h2>
<a NAME="Is generic code faster or slower than non-generic code?"></a><font face="Arial,Helvetica"><font size=+0>Is
generic code faster or slower than non-generic code?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>There is no perceivable difference.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Some programmers, especially those with a C++ background,
expect that generic code should perform much faster than non-generic code,
because this is one observable benefit of using templates in C++.&nbsp;
Other programmers assume that the synthetic bridge methods and implicit
casts inserted by the compiler in the process of type erasure would degrade
the runtime performance of generic code.&nbsp; Which one is true?
<p>The short answer is: it is likely that one will find neither a substantial
difference in runtime performance nor any consistent trend.&nbsp; However,
this has not yet been verified by any benchmarks I know of.&nbsp; Nevertheless,
let us take a look at the various overlapping effects that might explain
such a statement.
<br>&nbsp;
<p><i>Implicit casts.</i>
<p>The casts added by the compiler are exactly the casts that would appear
in non-generic code.&nbsp; Hence the implicit casts do not add any overhead.
<br>&nbsp;
<table BORDER=0 COLS=2 >
<tr VALIGN=TOP>
<td>Example (generic code):
<blockquote><tt>List<b>&lt;String></b> list = new List<b>&lt;String></b>();</tt>
<br><tt>list.add("abc");</tt>
<br><tt>String s = list.get(0);</tt></blockquote>
Example (after type erasure):
<blockquote><tt>List list = new LinkedList();</tt>
<br><tt>list.add("abc");</tt>
<br><tt>String s = <b>(String)</b>list.get(0);</tt></blockquote>
</td>

<td>Example (non-generic code):
<blockquote><tt>List list = new LinkedList();</tt>
<br><tt>list.add("abc");</tt>
<br><tt>String s = <b>(String)</b>list.get(0);</tt></blockquote>
</td>
</tr>
</table>

<p>The non-generic code is exactly what the compiler generates in the process
of type erasure, hence there is no difference in performance.
<br>&nbsp;
<p><i>Bridge methods.</i>
<p>The compiler adds bridge methods. These synthetic methods cause an additional
method invocation at runtime, they are represented in the byte code and
increase its volume, and they add to the memory footprint of the program.
<br>&nbsp;
<table BORDER=0 COLS=2 >
<tr VALIGN=TOP>
<td>Example (generic code):
<blockquote><tt>final class Byte implements Comparable<b><font color="#000000">&lt;Byte></font></b>
{</tt>
<br><tt>&nbsp; priva<font color="#000000">te byte value;&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp; public&nbsp; Byte(byte value) {&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; this.value = value;&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp; }</font></tt>
<br><tt><font color="#000000">&nbsp; public&nbsp; byte byteValue() { return
value; }&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp; public&nbsp; int compareTo(<b>Byte</b>
t</font>hat) {&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return this.value - that.value;&nbsp;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
Example (after type erasure):
<blockquote><tt>final class Byte implements Comparable {</tt>
<br><tt>&nbsp; priva<font color="#000000">te byte value;&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp; public&nbsp; Byte(byte value) {&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; this.value = value;&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp; }&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp; public&nbsp; byte byteValue() { return
value; }&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp; public&nbsp; int compareTo(Byte t</font>hat)&nbsp;&nbsp;
{&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return this.value - that.value;&nbsp;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; <b><font color="#000000">public&nbsp; int compareTo(Object
that) {&nbsp;</font></b></tt>
<br><b><tt><font color="#000000">&nbsp;&nbsp;&nbsp; return this.compareTo((Byte)that);&nbsp;</font></tt></b>
<br><b><tt><font color="#000000">&nbsp; }</font></tt></b>
<br><tt>}</tt></blockquote>
</td>

<td>Example (non-generic code):
<blockquote><tt>final class Byte implements Comparable {</tt>
<br><tt>&nbsp; priva<font color="#000000">te byte value;&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp; public&nbsp; Byte(byte value) {&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; this.value = value;&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp; }&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp; public&nbsp; byte byteValue() { return
value; }&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp; public&nbsp; int compareTo(<b>Object</b>
that) {&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; return this.value - (<b>(Byte)</b>that).value;&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp; }</font></tt>
<br><tt>}</tt></blockquote>
</td>
</tr>
</table>

<p>It is likely that there is a slight performance penalty for the bridge
method that affects runtime execution and class loading.&nbsp; However,
only new (i.e. 5.0) source code is affected.&nbsp; If we compile legacy
(i.e. 1.4-compatible) source code, there are no additional bridge methods
and the byte code should be identical, more or less, to the way it was
before. Most likely the slight performance penalty is compensated for by
improvements in Hotspot.
<br>&nbsp;
<p><i>Runtime type information.</i>
<p>Static information about type parameters and their bounds is made available
via reflection.&nbsp; This runtime type information adds to the size of
the byte code and the memory footprint, because the information must be
loaded into memory at runtime.&nbsp; Again, this only affects new (i.e.
5.0) source code.&nbsp; On the other hand, there are some enhancements
to reflection that apply even to existing language features, and those
do require slightly larger class files, too. At the same time, the representation
of runtime type information has been improved. For example, there is now
an access bit for "synthetic" rather than a class file attribute, and class
literals now generate only a single instruction. These things often balance
out.&nbsp; For any particular program you might notice a very slight degradation
in startup time due to slightly larger class files, or you might find improved
running time because of shorter code sequences.&nbsp; Yet it is unlikely
that one will find any large or consistent trends.&nbsp;
<br>&nbsp;
<p><i>Compilation time.</i>
<p>Compiler performance might decrease because translating generic source
code is more work than translating non-generic source code.&nbsp; Just
think of all the static type checks the compiler must perform for generic
types and methods.&nbsp; On the other hand, the performance of a compiler
is often more dominated by its implementation techniques rather than the
features of the language being compiled.&nbsp; Again,&nbsp; it is unlikely
that one will find any perceivable or measurable trends.&nbsp;</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ110">#FAQ110</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#How does the compiler translate Java generics?">How
does the compiler translate Java generics?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#What is type erasure?">What
is type erasure?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#What is a bridge method?">What
is a bridge method?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Why does the compiler add casts when it translates generics?">Why
does the compiler add casts when it translates generics?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ111"></a>
<h2>
<a NAME="How do I compile generics for use with JDK <= 1.4?"></a><font face="Arial,Helvetica"><font size=+0>How
do I compile generics for use with JDK &lt;= 1.4?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Use a tool like Retroweaver.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Retroweaver is a Java bytecode weaver that enables you
to take advantage of the new 1.5 language features in your source code,
while still retaining compability with 1.4 virtual machines. Retroweaver
rewrites class files so that they are compatible with older virtual machines.
Check out <a href="http://sourceforge.net/projects/retroweaver">http://sourceforge.net/projects/retroweaver</a>.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ111">#FAQ111</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#How does the compiler translate Java generics?">How
does the compiler translate Java generics?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="http://sourceforge.net/projects/retroweaver">Retroweaver
Download Page</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350>
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450></h3>

<h3>
<a NAME="Type System"></a>Type System</h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450><a NAME="FAQ201"></a>
<h2>
<a NAME="How do parameterized types fit into the Java type system?"></a><font face="Arial,Helvetica"><font size=+0>How
do parameterized types fit into the Java type system?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Instantiations of generic types have
certain super-subtype relationship among each other and have a type relationship
to their respective raw type.&nbsp; These type relationships are relevant
for method invocation, assignment and casts.</i></b></td>
</tr>

<tr>
<td COLSPAN="2"><i>Relevance of type relationships and type converstion
rules in practice.</i>
<p>The type system of a programming language determines which types are
convertible to which other types.&nbsp; These conversion rules have an
impact on various areas of a programming language.&nbsp; One area where
conversion rules and type relationships play role is casts and <tt>instanceof</tt>
expressions.&nbsp; Other area is assignment compatibility and method invocation,
where argument and return value passing relies on convertibility of the
involved types.
<p>The type conversion rules determine which casts are accepted and which
ones are rejected.&nbsp; For example, the types <tt>String</tt> and <tt>Integer</tt>
have no relationship and for this reason the compiler rejects the attempt
of a cast from <tt>String</tt> to <tt>Integer</tt>, or vice versa.&nbsp;
In contrast, the types <tt>Number</tt> and <tt>Integer</tt> have a super-subtype
relationship; <tt>Integer</tt> is a subtype of <tt>Number</tt> and <tt>Number</tt>
is a supertype of <tt>Integer</tt>. Thanks to this relationship, the compiler
accepts the cast from <tt>Number</tt> to <tt>Integer</tt>, or vice versa.&nbsp;
The cast from <tt>Integer</tt> to <tt>Number </tt>is not even necessary,
because the conversion from a subtype to a supertype is considered an implicit
type conversion, which need not be expressed explicitly in terms of a cast;
this conversion is automatically performed by the compiler whenever necessary.&nbsp;
The same rules apply to&nbsp; <tt>instanceof</tt> expressions.
<p>The conversion rules define which types are assignment compatible.&nbsp;
Using the examples from above, we see that a <tt>String</tt> cannot be
assigned to an <tt>Integer</tt> variable, or vice versa, due to the lack
of a type relationship.&nbsp; In contrast, an <tt>Integer</tt> can be assigned
to a <tt>Number</tt> variable, but not vice versa.&nbsp; A side effect
of the super-subtype relationship is that we can assign a subtype object
to a supertype variable, without an explicit cast anywhere.&nbsp; This
is the so-called <i>widening reference conversion</i>; it is an implicit
conversion that the compiler performs automatically whenever it is needed.&nbsp;
The converse, namely assignment of a supertype object to a subtype variable,
is not permitted.&nbsp; This is because the so-called <i>narrowing reference
conversion </i>is not an implicit conversion.&nbsp; It can only be triggered
by an explicit cast.
<p>The rules for assignment compatibility also define which objects can
be passed to which method.&nbsp; An argument can be passed to a method
if its type is assignment compatible to the declared type of the method
parameter. For instance, we cannot pass an <tt>Integer</tt>&nbsp; to a
method that asks for <tt>String</tt>, but we can pass an <tt>Integer</tt>
to a method that asks for a <tt>Number</tt>.&nbsp; The same rules apply
to the return value of a method.
<br>&nbsp;
<p><i>Super-subtype relationships of parameterized types.</i>
<p>In order to understand how objects of parameterized types can be used
in assignments, method invocations and casts, we need an understanding
of the relationship that parameterized types have among each other and
with non-parameterized types. And we need to know the related conversion
rules.
<p>We already mentioned <i>super-subtype relationships </i>and the related
<i>narrowing</i>
and&nbsp; <i>widening reference conversions</i>.&nbsp; They exist since
Java was invented, that is, among non-generic types.&nbsp; The super-subtype
relationship has been extended to include parameterized types.&nbsp; In
the Java 5.0 type system super-subtype relationships and the related narrowing/widening
reference conversions exist among parameterized types, too.&nbsp; We will
explain the details in separate FAQ entries.&nbsp; Here are some initial
examples to get a first impression of the impact that type relationships
and conversion rules have on method invocation.
<p>Consider a method whose declared parameter type is a wildcard parameterized
type.&nbsp; A wildcard parameterized type acts as supertype of all members
of the type family that the wildcard type denotes.
<p>Example (of widening reference conversion from concrete instantiation
to wildcard instantiation):
<blockquote><tt>void printAll(<b><font color="#000099">LinkedList&lt;?
extends Number></font></b> c) { ... }</tt>
<p><tt><b><font color="#000099">LinkedList&lt;Long></font></b> l = new
LinkedList&lt;Long>();</tt>
<br><tt>...</tt>
<br><tt>printAll(l);&nbsp; <b>// </b></tt><b><i>widening reference conversion</i></b></blockquote>
We can pass a <tt>List&lt;Long></tt> as an argument to the <tt>printAll</tt>
method that asks for a <tt>LinkedList&lt;? extends Number></tt>.&nbsp;
This is permitted thanks to the super-subtype relationship between a wildcard
instantiation and a concrete instantiation.&nbsp; <tt>LinkedList&lt;Long></tt>
is a member of the type family denoted by <tt>LinkedList&lt;? extends Number></tt>,
and as such a <tt>LinkedList&lt;Long></tt> is a subtype of <tt>LinkedList&lt;?
extends Number></tt>.&nbsp; The compiler automatically performs a widening
conversion from subtype to supertype and thus allows that a <tt>LinkedList&lt;Long></tt>
can be supplied as argument to the <tt>printAll</tt> method that asks for
a <tt>LinkedList&lt;? extends Number></tt>.
<p>Note that this super-subtype relationship between a wildcard instantiation
and a member of the type family that the wildcard denotes is different
from inheritance. Inheritance implies a super-subtype relationship as well,
but it is a special case of the more general super-subtype relationship
that involves wildcard instantiations.
<p>We know inheritance relationships from non-generic Java.&nbsp; It is
the relationship between a superclass and its derived subclasses, or a
super-interface and its sub-interfaces, or the relationship between an
interface and its implementing classes.&nbsp; Equivalent inheritance relationships
exists among instantiations of different generic types.&nbsp; The prerequisite
is that the instantiations must have the same type arguments.&nbsp; Note
that this situation differs from the super-subtype relationship mentioned
above, where we discussed the relationship between wildcard instantiations
and concrete instantiations of the <i>same</i> generic type, whereas we
now talk of the relationship between instantiations of <i>different</i>
generic types with identical type arguments.&nbsp;
<p>Example (of widening reference conversion from one concrete parameterized
type to another concrete parameterized type):
<blockquote><tt>void printAll(<b><font color="#000099">Collection&lt;Long></font></b>
c) { ... }</tt>
<p><tt><b><font color="#000099">LinkedList&lt;Long></font></b> l = new
LinkedList&lt;Long>();</tt>
<br><tt>...</tt>
<br><tt>printAll(l);&nbsp; <b>// </b></tt><b><i>widening reference conversion</i></b></blockquote>
The raw types <tt>Collection</tt> and <tt>LinkedList</tt> have a super-subtype
relationship; <tt>Collection</tt> is a supertype of <tt>LinkedList</tt>.&nbsp;
This super-subtype relationship among the raw types is extended to the
parameterized types, provided the type arguments are identical:
<tt>Collection&lt;Long></tt>
is a supertype of <tt>LinkedList&lt;Long></tt>, <tt>Collection&lt;String></tt>
is a supertype of <tt>LinkedList&lt;String></tt>, and so on.
<p>It is common that programmers believe that the super-subtype relationship
among type arguments would&nbsp; extend into the respective parameterized
type.&nbsp; This is not true. Concrete instantiations of the same generic
type for different type arguments have no type relationship. For instance,
<tt>Number</tt> is a supertype of <tt>Integer</tt>, but <tt>List&lt;Number></tt>
is not a supertype of<tt> List&lt;Integer></tt>.&nbsp; A type relationship
among different instantiations of the same generic type exists only among
wildcard instantiations and concrete instantiations, but never among concrete
instantiations.
<p>Example (of illegal attempt to convert between different concrete instantiations
of the same generic type):
<blockquote><tt>void printAll(<b><font color="#000099">LinkedList&lt;Number></font></b>
c) { ... }</tt>
<p><tt><b><font color="#000099">LinkedList&lt;Long></font></b> l = new
LinkedList&lt;Long>();</tt>
<br><tt>...</tt>
<br><tt>printAll(l);&nbsp; <b>//</b></tt><b> <i>error; no conversion</i></b></blockquote>
Due to the lack of a type relationship between <tt>LinkedList&lt;Number></tt>
and <tt>LinkedList&lt;Long></tt> the compiler cannot convert the <tt>LinkedList&lt;Long></tt>
to a <tt>LinkedList&lt;Number></tt> and the method call is rejected with
an error message.
<br>&nbsp;
<p><i>Unchecked conversion of parameterized types.</i>
<p>With the advent of parameterized types a novel category of type relationship
was added to the Java type system: the relationship between a parameterized
type and the corresponding raw type. The conversion from a parameterized
type to the corresponding raw type is a widening reference conversion like
the conversion from a subtype to the supertype. It is an implicit conversion.&nbsp;
An example of such a conversion is the conversion from a parameterized
type such as <tt>List&lt;String></tt> or <tt>List&lt;? extends Number></tt>
to the raw type <tt>List</tt>.&nbsp; The counterpart, namely the conversion
from the raw type to an instantiation of the respective generic type, is
the so-called&nbsp; <i>unchecked conversion</i>. It is an automatic conversion,
too, but the compiler reports an "unchecked conversion" warning.&nbsp;&nbsp;
Details are explained in separate FAQ entries.&nbsp; Here are some initial
examples to get a first impression of usefulness of unchecked conversions.&nbsp;
They are mainly permitted for compatibility between generic and non-generic
source code.&nbsp;
<p>Below is an example of a method whose declared parameter type is a raw
type. The method might be a pre-Java-5.0 method that was defined before
generic and parameterized types had been available in Java.&nbsp; For this
reason it declares <tt>List</tt> as the argument type.&nbsp; Now, in Java
5.0, <tt>List</tt> is a raw type.
<p>Example (of a widening reference conversion from parameterized type
to raw type):
<blockquote><tt>void printAll(<b><font color="#000099">List</font></b>
c) { ... }</tt>
<p><tt><b><font color="#000099">List&lt;String></font></b> l = new LinkedList&lt;String>();</tt>
<br><tt>...</tt>
<br><tt>printAll(l);&nbsp; <b>// </b></tt><b><i>widening reference conversion</i></b></blockquote>
Source code such as the one above is an example of a fairly common situation,
where non-generic legacy code meets generic Java 5.0 code.&nbsp; The <tt>printAll</tt>
method is an example of legacy code that was developed before Java 5.0
and uses raw types.&nbsp; If more recently developed parts of the program
use instantiations of the generic type <tt>List</tt>, then we end up passing
an instantiation such as <tt>List&lt;String></tt> to the <tt>printAll </tt>method
that declared the raw type <tt>List </tt>as its parameter type.&nbsp; Thanks
to the type relationship between the raw type and the parameterized type,
the method call is permitted. It involves an automatic widening reference
conversion from the parameterized type to the raw type.
<p>Below is an example of the conversion in the opposite direction.&nbsp;
We consider a method has a declared parameter type that is a parameterized
type.&nbsp; We pass a raw type argument to the method and rely on an unchecked
conversion to make it work.
<p>Example (of an unchecked conversion from raw type to parameterized type):
<blockquote><tt>void printAll(<b><font color="#000099">List&lt;Long></font></b>
c) { ... }</tt>
<p><tt><b><font color="#000099">List</font></b> l = new LinkedList();</tt>
<br><tt>...</tt>
<br><tt>printAll(l);&nbsp; <b>// </b></tt><b><i>unchecked conversion</i></b></blockquote>
Like the previous example, this kind of code is common in situation where
generic and non-generic code are mixed.
<p>The subsequent FAQ entries discuss details of the various type relationships
and conversions among raw types, concrete parameterized types, bounded
and unbounded wildcard parameterized types.
<br>&nbsp;</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ201">#FAQ201</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is the raw type?">What
is the raw type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a wildcard instantiation?">What
is a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which super-subtype relationships exist among instantiations of parameterized types?">Which
super-subtype relationships exist among instantiations of generic types?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#How does the raw type relate to instantiations of the corresponding parameterized type?">How
does the raw type relate to instantiations of the corresponding generic
type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#How do instantiations of a parameterized type relate to  instantiations of other parameterized types?">How
do instantiations of a generic type relate to&nbsp; instantiations of other
generic types that have the same type argument?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#How do unbounded wildcard instantiations of a parameterized type relate to other instantiations of the same type?">How
do unbounded wildcard instantiations of a generic type relate to other
instantiations of the same generic type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#How do wildcard instantiations with an upper bound relate to other instantiations of the same type?How do wildcard instantiations with an upper bound relate to other instantiations of the same type?">How
do wildcard instantiations with an upper bound relate to other instantiations
of the same generic type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#How do wildcard instantiations with a lower bound relate to other instantiations of the same type?">How
do wildcard instantiations with a lower bound relate to other instantiations
of the same generic type?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ202"></a>
<p><a NAME="How does the raw type relate to instantiations of the corresponding parameterized type?"></a><b><font face="Arial,Helvetica">How
does the raw type relate to instantiations of the corresponding generic
type?</font></b>
<br>&nbsp;
<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>The raw type is the supertype of all
instantiations of the corresponding generic type.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">The raw types have the regular supertype-subtype relationship
with other raw types. For illustration we use the collection classes and
interfaces from the JDK (see package <tt><a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/package-summary.html">java.util</a></tt>).
<p><img SRC="../Diagrams/rawtypes.jpg" NOSAVE height=195 width=400>
<p>In addition, the raw types are supertypes of all concrete and all wildcard
instantiations of the generic type. For instance, the raw type <tt>Collection</tt>
is a supertype of all instantiations of the generic type <tt>Collection</tt>.
<br><img SRC="../Diagrams/rawtypes.3.jpg" NOSAVE height=351 width=500>
<br>&nbsp;
<p>With both properties combined a raw type is the supertype of all instantiations
of all its generic and non-generic subtypes.&nbsp;&nbsp; For instance,
the raw type <tt>Collection</tt> is a supertype of all instantiations of
all generic collection classes.
<p><img SRC="../Diagrams/rawtypes.2.jpg" NOSAVE height=341 width=600>
<br>&nbsp;
<p>Regarding conversions, the usual reference widening conversion from
subtype to supertype is allowed. That is, every instantiation of a generic
type can be converted to the corresponding raw type.&nbsp; The reverse
is permitted, too, for reasons of compatibility between generic and non-generic
types.&nbsp; It is the so-called unchecked conversion and is accompanied
by an "unchecked" warning. In detail, the conversion from a raw type to
a concrete or bounded wildcard instantiation of the corresponding generic
type leads to a warning.&nbsp; The conversion from the raw type to the
unbounded wildcard instantiation is warning-free.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ202">#FAQ202</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#How do parameterized types fit into the Java type system?">How
do parameterized types fit into the Java type system?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is the raw type?">What
is the raw type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a concrete instantiation?">What
is a concrete paramterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a wildcard instantiation?">What
is a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is an unbounded wildcard instantiation?">What
is the unbounded wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which super-subtype relationships exist among instantiations of parameterized types?">Which
super-subtype relationships exist among instantiations of generic types?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ203"></a>
<h2>
<a NAME="How do instantiations of a parameterized type relate to  instantiations of other parameterized types?"></a><font face="Arial,Helvetica"><font size=+0>How
do instantiations of a generic type relate to&nbsp; instantiations of other
generic types that have the same type argument?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>An instantiation of a generic type is
the supertype of all instantiations of generic subtypes that have the same
type argument.&nbsp;</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Instantiations of the generic types have supertype-subtype
relationships with concrete instantiations of generic subtypes provided
they all have the exact same type arguments. The example below uses the
JDK collection types (see package <tt><a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/package-summary.html">java.util</a></tt>)
for illustration.&nbsp;
<br>&nbsp;
<table BORDER=0 WIDTH="100%" >
<tr>
<td><img SRC="../Diagrams/concrete.2.jpg" NOSAVE height=235 width=370></td>

<td><img SRC="../Diagrams/bounds.2.jpg" NOSAVE height=239 width=550></td>
</tr>
</table>

<p>The diagram illustrates the super-subtype relationship among instantiations
that have the same type argument.&nbsp; The type argument can be a concrete
type, but also a bounded or unbounded wildcard.&nbsp; For instance, <tt>Collection&lt;Number></tt>
is the supertype of <tt>List&lt;Number></tt> and <tt>LinkedList&lt;Number></tt>,
<tt>Collection&lt;?
extends Number></tt> is the supertype of <tt>List&lt;? extends Number></tt>
and
<tt>LinkedList&lt;? extends Number></tt>, <tt>Collection&lt;?></tt>
is the supertype of <tt>List&lt;?></tt> and <tt>LinkedList&lt;?></tt>,
and so on.
<p>Type relationships to other concrete instantiations do not exist.&nbsp;
In particular, the supertype-subtype relationship among the type arguments
does not extend to the instantiations.&nbsp; For example, <tt>Collection&lt;Number></tt>
is NOT a supertype of <tt>Collection&lt;Long></tt>.&nbsp;
<p><img SRC="../Diagrams/concrete.3.jpg" NOSAVE height=172 width=270>
<p>Regarding conversions, the usual reference widening conversion from
subtype to supertype is allowed. The reverse is not permitted.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ203">#FAQ203</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#How do parameterized types fit into the Java type system?">How
do parameterized types fit into the Java type system?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is the raw type?">What
is the raw type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a concrete instantiation?">What
is a concrete parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a wildcard instantiation?">What
is a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is an unbounded wildcard instantiation?">What
is the unbounded wildcard parmeterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which super-subtype relationships exist among instantiations of parameterized types?">Which
super-subtype relationships exist among instantiations of generic types?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ204"></a>
<h2>
<a NAME="How do unbounded wildcard instantiations of a parameterized type relate to other instantiations of the same type?"></a><font face="Arial,Helvetica"><font size=+0>How
do unbounded wildcard instantiations of a generic type relate to other
instantiations of the same generic type?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>An unbounded wildcard instantiation is
the supertype of all instantiations of the generic type.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">The unbounded wildcard instantiation of a generic type
is supertype of all concrete and all wildcard instantiations of the same
generic type.&nbsp;
<br>For instance, the unbounded wildcard instantiation
<tt>Collection&lt;?></tt>
is supertype of all instantiations of the generic type <tt>Collection</tt>.&nbsp;
The example below uses the JDK collection types (see package <tt><a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/package-summary.html">java.util</a></tt>)
for illustration.&nbsp;
<p><img SRC="../Diagrams/unbounded.2.jpg" NOSAVE height=297 width=500>
<p>At the same, an unbounded wildcard instantiation is supertype of all
unbounded instantiations of any generic subtypes.&nbsp; For instance, the
unbounded wildcard instantiation<tt>Collection&lt;?></tt> is supertype
of <tt>List&lt;?></tt>, <tt>LinkedList&lt;?></tt>, and so on. Both type
relationships combined, an unbounded wildcard instantiation is supertype
of all instantiations of the same generic type and of all instantiations
of all its generic subtypes.
<p><img SRC="../Diagrams/unbounded.jpg" NOSAVE height=344 width=600>
<br>&nbsp;
<p>Regarding conversions, the usual reference widening conversion from
subtype to supertype is allowed. The reverse is not permitted.
<p>There is one special rules for unbounded wildcard instantiations: the
conversion from a raw type to the unbounded wildcard instantiation is not
an "unchecked" conversion, that is, the conversion from <tt>Collection</tt>&nbsp;
to <tt>Collection&lt;?></tt> does not lead to an "unchecked" warning.&nbsp;
This is different for concrete and bounded instantiations, where the conversion
from the raw type to the concrete and bounded wildcard instantiation leads
to an "unchecked" warning.&nbsp;</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ204">#FAQ204</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#How do parameterized types fit into the Java type system?">How
do parameterized types fit into the Java type system?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which super-subtype relationships exist among instantiations of parameterized types?">Which
super-subtype relationships exist among instantiations of parameterized
types?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is the raw type?">What
is the raw type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a concrete instantiation?">What
is a concrete parmeterizd type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a wildcard instantiation?">What
is a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is an unbounded wildcard instantiation?">What
is the unbounded wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What is a wildcard?">What
is a wildcard?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What is an unbounded wildcard?">What
is an unbounded wildcard?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What is a bounded wildcard?">What
is a bounded wildcard?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ205"></a>
<h2>
<a NAME="How do wildcard instantiations with an upper bound relate to other instantiations of the same type?How do wildcard instantiations with an upper bound relate to other instantiations of the same type?"></a><font face="Arial,Helvetica"><font size=+0>How
do wildcard instantiations with an upper bound relate to other instantiations
of the same generic type?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>A wildcard instantiation wild an upper
bound is supertype of all instantiations of the same generic type where
the type argument is a subtype of the upper bound.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">An upper bound wildcard instantiation is supertype of all
concrete instantiations with type arguments that are subtypes of the upper
bound, the upper bound itself being included. For instance, <tt>Collection&lt;?
extends Number></tt> is supertype of <tt>Collection&lt;Number></tt>, <tt>Collection&lt;Long></tt>,
<tt>Collection&lt;Short></tt>,
etc., because <tt>Number</tt>,
<tt>Long</tt>, and <tt>Short</tt> are subtypes
(or same type) of <tt>Number</tt>. The underlying idea is: a subtype of
the upper bound (e.g. <tt>Long</tt>) belongs to the family of types that
the wildcard (e.g. <tt>? extends Number</tt>) stands for and in this case
the wildcard instantiation (e.g. <tt>Collection&lt;? extends Number></tt>)
is a supertype of the concrete instantiation on the subtype of the upper
bound (e.g. <tt>Collection&lt;Long></tt>).
<p><img SRC="../Diagrams/upperbound.2.jpg" NOSAVE height=110 width=450>
<p>At the same time, a wildcard instantiation with an upper bound is supertype
of all generic subtypes that are instantiated on the same upper bound wildcard.&nbsp;
For instance, <tt>Collection&lt;? extends Number></tt> is supertype of
<tt>Set&lt;?
extends Number> </tt>and <tt>ArrayList&lt;? extends Number></tt>.&nbsp;
<p><img SRC="../Diagrams/bounds.2.jpg" NOSAVE height=239 width=550>
<p>The upper bound wildcard instantiation is also supertype of other upper
bound wildcard instantiation with an upper bound that is a subtype of the
own upper bound.&nbsp; For instance, <tt>Collection&lt;? extends Number></tt>
is supertype of <tt>Collection&lt;? extends Long></tt> and<tt> Collection&lt;?
extend Short></tt>, because <tt>Long</tt> and <tt>Short</tt> are subtypes
of <tt>Number</tt>.&nbsp;
<p><img SRC="../Diagrams/upperbound.3.jpg" NOSAVE height=110 width=430>
<p>Similarly, <tt>Collection&lt;? extends Comparable&lt;?>></tt> is supertype
of <tt>Collection&lt;? extends Number></tt> and<tt> Collection&lt;? extends
Delayed></tt>, because <tt>Number</tt> is a subtype of <tt>Comparable&lt;Number></tt>,
which is a subtype of <tt>Comparable&lt;?></tt>, and <tt>Delayed</tt>&nbsp;
(see <tt><a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/Delayed.">java.util.concurrent.Delayed</a></tt>)
is a subtype of <tt>Comparable&lt;Delayed></tt>, which is a subtype of
<tt>Comparable&lt;?></tt>.
The idea is that if the upper bound of one wildcard is a supertype of the
upper bound of another wildcard then the type family with the supertype
bound includes the type family with the subtype bound.&nbsp; If one family
of types (e.g. <tt>? extends Comparable&lt;?>) </tt>includes the other
(e.g.
<tt>? extends Number></tt> and<tt> ? extends Delayed</tt>) then the
wildcard instantiation on the larger family (e.g. <tt>Collection&lt;? extends
Comparable&lt;?>></tt>) is supertype of the wildcard instantiation of the
included family (e.g.
<tt>Collection&lt;? extends Number></tt>).&nbsp;
<p>All these type relationships combined make a bounded wildcard instantiation
supertype of a quite a number of instantiations of the same generic type
and subtypes thereof.
<p><img SRC="../Diagrams/upperbound.4.jpg" NOSAVE height=269 width=550>
<p>Regarding conversions, the usual reference widening conversion from
subtype to supertype is allowed. The reverse is not permitted.&nbsp;</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ205">#FAQ205</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#How do parameterized types fit into the Java type system?">How
do parameterized types fit into the Java type system?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which super-subtype relationships exist among instantiations of parameterized types?">Which
super-subtype relationships exist among instantiations of parameterized
types?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is the raw type?">What
is the raw type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a concrete instantiation?">What
is a concrete parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a wildcard instantiation?">What
is a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is an unbounded wildcard instantiation?">What
is the unbounded wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What is a wildcard?">What
is a wildcard?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What is an unbounded wildcard?">What
is an unbounded wildcard?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What is a bounded wildcard?">What
is a bounded wildcard?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ206"></a>
<h2>
<a NAME="How do wildcard instantiations with a lower bound relate to other instantiations of the same type?"></a><font face="Arial,Helvetica"><font size=+0>How
do wildcard instantiations with a lower bound relate to other instantiations
of the same generic type?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>A wildcard instantiation wild a lower
bound is supertype of all instantiations of the generic type where the
type argument is a supertype of the lower bound.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">A wildcard instantiation with a lower bound is supertype
of all concrete instantiation with type arguments that are supertypes of
the lower bound, the lower bound itself included. For instance, <tt>Collection&lt;?
super Number></tt> is supertype of <tt>Collection&lt;Number></tt>, <tt>Collection&lt;Serializable></tt>,
and<tt> Collection&lt;Object></tt>, because
<tt>Number</tt>, <tt>Serializable</tt>
and <tt>Object</tt> are supertypes (or same type) of <tt>Number</tt>. The
underlying idea is: a supertype of the lower bound (e.g. <tt>Object</tt>)
belongs to the family of types that the wildcard (e.g. <tt>? super Number</tt>)
stands for and in this case the wildcard instantiation (e.g. <tt>Collection&lt;?
super Number></tt>) is a supertype of the concrete instantiation on the
supertype of the lower bound (e.g. <tt>Collection&lt;Object></tt>).
<p><img SRC="../Diagrams/lowerbound.2.jpg" NOSAVE height=110 width=500>
<p>At the same time, a wildcard instantiation with a lower bound is supertype
of parameterized subtypes that are instantiated on the same lower bound
wildcard.&nbsp; For instance, <tt>Collection&lt;? super Number></tt> is
supertype of
<tt>Set&lt;? super Number> </tt>and <tt>ArrayList&lt;? super
Number></tt>.&nbsp;
<p><img SRC="../Diagrams/lowerbound.3.jpg" NOSAVE height=229 width=530>
<p>The lower bound wildcard instantiation is also supertype of other lower
bound wildcard instantiation with a lower bound bound that is a supertype
of the own lower bound.&nbsp; For instance, <tt>Collection&lt;? super Number></tt>
is supertype of <tt>Collection&lt;? super Serializable></tt>, because <tt>Serializable</tt>
is a supertype of <tt>Number</tt>.&nbsp;&nbsp; The idea is that if the
lower bound of one wildcard is a subtype of the lower bound of another
wildcard then the type family with the subtype bound includes the type
family with the supertype bound.&nbsp; If one family of types (e.g. <tt>?
super Number)
</tt>includes the other (e.g. <tt>? super Serializable</tt>)
then the wildcard instantiation on the larger family (e.g. <tt>Collection&lt;?
super Number></tt>) is supertype of the wildcard instantiation of the included
family (e.g. <tt>Collection&lt;? super Serializable></tt>).
<p><img SRC="../Diagrams/lowerbound.4.jpg" NOSAVE height=128 width=250>
<p>Regarding conversions, the usual reference widening conversion from
subtype to supertype is allowed. The reverse is not permitted.&nbsp;</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ206">#FAQ206</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#How do parameterized types fit into the Java type system?">How
do parameterized types fit into the Java type system?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which super-subtype relationships exist among instantiations of parameterized types?">Which
super-subtype relationships exist among instantiations of parameterized
types?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is the raw type?">What
is the raw type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a concrete instantiation?">What
is a concrete parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a wildcard instantiation?">What
is a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is an unbounded wildcard instantiation?">What
is the unbounded wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What is a wildcard?">What
is a wildcard?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What is an unbounded wildcard?">What
is an unbounded wildcard?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What is a bounded wildcard?">What
is a bounded wildcard?</a></font></font></td>
</tr>
</table>

<h3>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ207"></a></h3>

<h2>
<a NAME="Which super-subtype relationships exist among instantiations of parameterized types?"></a><font face="Arial,Helvetica"><font size=+0>Which
super-subtype relationships exist among instantiations of generic types?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>This is fairly complicated and the type
relationships are best determined setting up tables as explained in this
FAQ entry.&nbsp;</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Super-subtype relationships among instantiations of generic
types are determined by two orthogonal aspects.
<p>On the one hand, there is the inheritance relationship between a supertype
and a subtype. This is the usual notion of inheritance as we know it from
non-generic Java.&nbsp; For instance, the interface <tt>Collection</tt>
is a supertype of the interface <tt>List</tt>.&nbsp; This inheritance relationship
is extended in analogy to instantiations of generic types, i.e. to parameterized
types.&nbsp; The prerequisite is that the instantiations must have identical
type arguments.&nbsp; An example is the supertype <tt>Collection&lt;Long></tt>
and its subtype
<tt>List&lt;Long></tt>. The rule is: as long as the type
arguments are identical, the inheritance relationship among generic types
leads to a super-subtype relationship among corresponding parameterized
types.
<p>On the other hand, there is a relationship based on the type arguments.
The prerequisite is that at least one of the involved type arguments is
a wildcard. For example, <tt>Collection&lt;? extends Number></tt> is a
supertype of <tt>Collection&lt;Long></tt>, because the type <tt>Long</tt>
is a member of the type family that the wildcard "<tt>? extends Number</tt>"
denotes.&nbsp;
<p>This kind of type relationship also exists between two wildcard instantiations
of the same generic type with different wildcards as type arguments. The
prerequisite is that the type family denoted by one wildcard is a superset
of the type family denoted by the other wildcard. For example, <tt>Collection&lt;?></tt>
is a supertype of <tt>Collection&lt;? extends Number></tt>, because the
family of types denoted by the wildcard "<tt>?</tt>" is a superset of the
family of types denoted by the wildcard "<tt>? extends Number</tt>".&nbsp;
The super-sub<u>set</u> relationship among the type arguments leads to
a super-sub<u>type</u> relationship among corresponding instantiations
of the same parameterized type.&nbsp; The type relationship mentioned above,
between a wildcard instantiation and a concrete instantiation of the same
generic type, is a special case of this rule; you just interpret the concrete
type argument as a type family with only one member, namely the concrete
type itself.
<p>Both effects - the super-subtype relationship due to inheritance and
the super-subtype relationship due to type arguments - are combined and
lead to a two-dimensional super-subtype relationship table.&nbsp; The tables
below use examples for illustration.
<p>The vertical axis of the table lists parameterized types according to
their inheritance relationship, starting with the supertype on the top
to a subtype on the bottom. The horizontal axis lists type arguments according
to their super-subset relationship of the type families they denote, starting
with the largest type set on the lefthand side to the smallest type set
on the righthand side.&nbsp;
<br>&nbsp;
<table BORDER=0 CELLSPACING=3 CELLPADDING=3 >
<tr BGCOLOR="#FFFFFF">
<td></td>

<td COLSPAN="5" BGCOLOR="#FFFFFF"><img SRC="../Diagrams/SuperSubSet-horizontal.jpg" NOSAVE height=30 width=180></td>

<td BGCOLOR="#FFFFFF"></td>

<td BGCOLOR="#FFFFFF"></td>

<td BGCOLOR="#FFFFFF"></td>
</tr>

<tr BGCOLOR="#C6CCDD">
<td ROWSPAN="4" BGCOLOR="#FFFFFF"><img SRC="../Diagrams/SuperSubType.jpg" NOSAVE height=157 width=20></td>

<td></td>

<td><b><tt>?</tt></b></td>

<td><b><tt>? extends Serializable</tt></b></td>

<td><b><tt>? extends Number</tt></b></td>

<td><b><tt>Long</tt></b></td>
</tr>

<tr>
<td BGCOLOR="#C6CCDD"><b><tt>Collection</tt></b></td>

<td><tt><nobr>Collection&lt;?></nobr></tt></td>

<td><tt>Collection&lt;? extends Serializable></tt></td>

<td><tt><nobr>Collection&lt;? extends Number></nobr></tt></td>

<td><tt><nobr>Collection&lt;Long></nobr></tt></td>
</tr>

<tr>
<td BGCOLOR="#C6CCDD"><b><tt>List</tt></b></td>

<td><tt>List&lt;?></tt></td>

<td BGCOLOR="#E3E388"><b><tt><font color="#000066">List&lt;? extends Serializable></font></tt></b></td>

<td BGCOLOR="#FFFF99"><tt><font color="#000066">List&lt;? extends Number></font></tt></td>

<td BGCOLOR="#FFFF99"><tt><font color="#000066">List&lt;Long></font></tt></td>
</tr>

<tr>
<td BGCOLOR="#C6CCDD"><b><tt>ArrayList</tt></b></td>

<td><tt>ArrayList&lt;?></tt></td>

<td BGCOLOR="#FFFF99"><tt><font color="#000066">ArrayList&lt;? extends
Serializable></font></tt></td>

<td BGCOLOR="#FFFF99"><tt><font color="#000066">ArrayList&lt;? extends
Number></font></tt></td>

<td BGCOLOR="#FFFF99"><tt><font color="#000066">ArrayList&lt;Long></font></tt></td>
</tr>
</table>

<p>If you pick a certain entry in the table, say <tt>List&lt;? extends
Serializable></tt>, then the subtable to the bottom and to the right contains
all subtypes of the entry.&nbsp;
<p>Below is another example that involves lower bound wildcards. Again,
the horizontal axis lists type arguments according to their super-subset
relationship of the type families they denote, starting with largest set
of types denoted by the unbounded wildcard "<tt>?</tt>" over type families
of decreasing size to a type set consisting of one concrete type. The difficulty
with lower bound wildcards is that the super-subset relationship of the
type families denoted by lower bound wildcards is slightly counter-intuitive
to determine.&nbsp; Details are discussed in a separate FAQ entry.
<br>&nbsp;
<table BORDER=0 CELLSPACING=3 CELLPADDING=3 >
<tr BGCOLOR="#FFFFFF">
<td></td>

<td COLSPAN="5" BGCOLOR="#FFFFFF"><img SRC="../Diagrams/SuperSubSet-horizontal.jpg" NOSAVE height=30 width=180></td>

<td BGCOLOR="#FFFFFF"></td>

<td BGCOLOR="#FFFFFF"></td>

<td BGCOLOR="#FFFFFF"></td>
</tr>

<tr BGCOLOR="#C6CCDD">
<td ROWSPAN="4" BGCOLOR="#FFFFFF"><img SRC="../Diagrams/SuperSubType.jpg" NOSAVE height=157 width=20></td>

<td></td>

<td><b><tt>?</tt></b></td>

<td><b><tt>? super Long</tt></b></td>

<td><b><tt>? super Number</tt></b></td>

<td><b><tt>Object</tt></b></td>
</tr>

<tr>
<td BGCOLOR="#C6CCDD"><b><tt>Collection</tt></b></td>

<td><tt><nobr>Collection&lt;?></nobr></tt></td>

<td><tt>Collection&lt;? super Long></tt></td>

<td><tt>Collection&lt;? super Number></tt></td>

<td><tt><nobr>Collection&lt;Object></nobr></tt></td>
</tr>

<tr>
<td BGCOLOR="#C6CCDD"><b><tt>List</tt></b></td>

<td><tt>List&lt;?></tt></td>

<td BGCOLOR="#E3E388"><b><tt><font color="#000066">List&lt;? super Long></font></tt></b></td>

<td BGCOLOR="#FFFF99"><tt><font color="#000066">List&lt;? super Number></font></tt></td>

<td BGCOLOR="#FFFF99"><tt><font color="#000066">List&lt;Object></font></tt></td>
</tr>

<tr>
<td BGCOLOR="#C6CCDD"><b><tt>ArrayList</tt></b></td>

<td><tt>ArrayList&lt;?></tt></td>

<td BGCOLOR="#FFFF99"><tt><font color="#000066">ArrayList&lt;? super Long></font></tt></td>

<td BGCOLOR="#FFFF99"><tt><font color="#000066">ArrayList&lt;? super Number></font></tt></td>

<td BGCOLOR="#FFFF99"><tt><font color="#000066">ArrayList&lt;Object></font></tt></td>
</tr>
</table>

<p>If you pick a certain entry in the table, say <tt>List&lt;? super Long></tt>,
then the subtable to the bottom and to the right contains all subtypes
of the entry and you would find information such as: <font color="#000000"><tt>ArrayList&lt;?
super Number> </tt>is</font> a subtype of
<font color="#000000"><tt>List&lt;?
super Long></tt>.</font>
<p>
<hr WIDTH="100%">
<p><i><font color="#000000">Generic Types With More Than One Type Parameter</font></i>
<p>We have been setting up tables to determine the super-subtype relationships
among different instantiations of different, yet related parameterized
types.&nbsp; These tables were two-dimensional because we took into account
inheritance on the one hand and various values for a type argument on the
other hand.&nbsp; A similar technique can be applied to parameterized types
with more than one type parameter.
<p>The example below uses a generic class <tt>Pair</tt> with two type parameters.&nbsp;
The vertical axis lists the first type arguments order by their super-subset
relationship from the largest type set to the smallest type set.&nbsp;
The horizontal axis does the same for the second type argument.
<br>&nbsp;
<table BORDER=0 CELLSPACING=3 CELLPADDING=3 >
<tr BGCOLOR="#FFFFFF">
<td></td>

<td COLSPAN="5" BGCOLOR="#FFFFFF"><img SRC="../Diagrams/SuperSubSet-horizontal.jpg" NOSAVE height=30 width=180></td>

<td BGCOLOR="#FFFFFF"></td>

<td BGCOLOR="#FFFFFF"></td>
</tr>

<tr BGCOLOR="#C6CCDD">
<td ROWSPAN="5" BGCOLOR="#FFFFFF"><img SRC="../Diagrams/SuperSubSet.jpg" NOSAVE height=178 width=23></td>

<td></td>

<td><b><tt>?</tt></b></td>

<td><b><tt>? super Long</tt></b></td>

<td><b><tt>? super Number</tt></b></td>

<td><b><tt>Object</tt></b></td>
</tr>

<tr>
<td BGCOLOR="#C6CCDD"><b><tt>?</tt></b></td>

<td><tt>Pair&lt;?,?></tt></td>

<td><tt>Pair&lt;?,? super Long></tt></td>

<td><tt>Pair&lt;?,? super Number></tt></td>

<td><tt>Pair&lt;?,Object></tt></td>
</tr>

<tr>
<td BGCOLOR="#C6CCDD"><b><tt>? extends Serializable</tt></b></td>

<td><tt>Pair&lt;? extends Serializable,?></tt></td>

<td BGCOLOR="#E3E388"><b><tt><font color="#000066">Pair&lt;? extends Serializable,?
super Long></font></tt></b></td>

<td BGCOLOR="#FFFF99"><tt><font color="#000066"><nobr>Pair&lt;? extends
Serializable</nobr>,? super Number></font></tt></td>

<td BGCOLOR="#FFFF99"><tt><font color="#000066">Pair&lt;? extends Serializable,Object></font></tt></td>
</tr>

<tr>
<td BGCOLOR="#C6CCDD"><b><tt>? extends Number</tt></b></td>

<td><tt>Pair&lt;? extends Number,?></tt></td>

<td BGCOLOR="#FFFF99"><tt><font color="#000066">Pair&lt;? extends Number,?
super Long></font></tt></td>

<td BGCOLOR="#FFFF99"><tt><font color="#000066">Pair&lt;? extends Number,?
super Number></font></tt></td>

<td BGCOLOR="#FFFF99"><tt><font color="#000066">Pair&lt;? extends Number,Object></font></tt></td>
</tr>

<tr>
<td BGCOLOR="#C6CCDD"><b><tt>Long</tt></b></td>

<td><tt>Pair&lt;Long,?></tt></td>

<td BGCOLOR="#FFFF99"><tt><font color="#000066">Pair&lt;Long,? super Long></font></tt></td>

<td BGCOLOR="#FFFF99"><tt><font color="#000066">Pair&lt;Long,? super Number></font></tt></td>

<td BGCOLOR="#FFFF99"><tt><font color="#000066">Pair&lt;Long,Object></font></tt></td>
</tr>
</table>

<p>Tables with more than two dimensions can be set up in analogy.&nbsp;
The key point is that you list generic types from supertype to subtype
and type arguments from superset to subset. For this purpose you need to
interpret type arguments as sets of types and determine their super-subtype
relationships.&nbsp; Note that the latter can be rather counter-intuitive
in case of multi-level wildcards involving lower bounds.&nbsp; Details
are discussed in a separate FAQ entry.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ207">#FAQ207</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#How do parameterized types fit into the Java type system?">How
do parameterized types fit into the Java type system?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which super-subset relationships exist among wildcards?">Which
super-subset relationships exist among wildcards?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is the raw type?">What
is the raw type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a concrete instantiation?">What
is a concrete parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a wildcard instantiation?">What
is a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is an unbounded wildcard instantiation?">What
is the unbounded wildcard parameterized type?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ208"></a>
<h2>
<a NAME="Which super-subset relationships exist among wildcards?"></a><font face="Arial,Helvetica"><font size=+0>Which
super-subset relationships exist among wildcards?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>A super-subtype relationship between
upper bounds leads to a super-subset relationship between the resulting
upper bound wildcards, and vice versa for a lower bounds.</i></b></td>
</tr>

<tr>
<td COLSPAN="2"><font color="#000000">A wildcard denotes a family (or set)
of types. These type sets can have super-subset relationships, namely when
one type set includes the other type set.&nbsp; The super-subset relationship
among wildcards determines the super-subtype relationships of instantiations
of parameterized types using these wildcards as type arguments.&nbsp; The
super-subtype relationships among instantiations of parameterized types
play an important role in method invocation, assignments, type conversions,
casts and type checks (as was discussed in a previous FAQ entry). For this
reason, we need to know how to determine the super-subset relationships
among the type sets denoted by wildcards.</font>
<p><font color="#000000">Here are the rules:</font>
<ul>
<li>
<font color="#000000">The unbounded wildcard "?" denotes the set of all
types and is the superset of all sets denoted by bounded wildcards.</font></li>

<li>
<font color="#000000">A wildcard with an upper bound A denotes a superset
of another wildcard with an upper bound B, if A is a <u>super</u>type of
B.</font></li>

<li>
<font color="#000000">A wildcard with a lower bound A denotes a superset
of another wildcard with a lower bound B, if A is a <u>sub</u>type of B.</font></li>

<li>
<font color="#000000">A concrete type denotes a set with only one element,
namely the type itself.</font></li>
</ul>

<table BORDER=0 CELLSPACING=3 CELLPADDING=3 BGCOLOR="#F4F4FF" >
<tr VALIGN=TOP BGCOLOR="#EDEFF3">
<td BGCOLOR="#FFFFFF"></td>

<td BGCOLOR="#C6CCDD"><b>upper bound wildcards</b></td>

<td BGCOLOR="#C6CCDD"><b>lower bound wildcards</b></td>
</tr>

<tr VALIGN=TOP>
<td VALIGN=TOP ROWSPAN="4" BGCOLOR="#EDEFF3"><img SRC="../Diagrams/SuperSubSet-small.jpg" NOSAVE height=139 width=18></td>

<td><tt>?</tt></td>

<td><tt>?</tt></td>
</tr>

<tr VALIGN=TOP>
<td><tt>? extends <font color="#000099">SuperType</font></tt></td>

<td><tt>? super <font color="#330033">SubType</font></tt></td>
</tr>

<tr VALIGN=TOP>
<td><tt>? extends <font color="#330033">SubType</font></tt></td>

<td><tt>? super <font color="#000099">SuperType</font></tt></td>
</tr>

<tr VALIGN=TOP>
<td>concrete type*
<br><font size=-2>*either <tt>SubType</tt> or a subtype thereof</font></td>

<td>concrete type*
<br><font size=-2>*either <tt>SuperType</tt> or a supertype thereof</font></td>
</tr>
</table>

<p>Here are some examples illustrating the rules:
<br>&nbsp;
<table BORDER=0 CELLSPACING=3 CELLPADDING=3 BGCOLOR="#F4F4FF" >
<tr VALIGN=TOP BGCOLOR="#EDEFF3">
<td></td>

<td BGCOLOR="#C6CCDD"><b>upper bound wildcards</b></td>

<td BGCOLOR="#C6CCDD"><b>lower bound wildcards</b></td>
</tr>

<tr>
<td ROWSPAN="4"><img SRC="../Diagrams/SuperSubSet-small.jpg" NOSAVE height=139 width=18></td>

<td><tt>?</tt></td>

<td><tt>?</tt></td>
</tr>

<tr VALIGN=TOP>
<td><tt>? extends Serializable</tt></td>

<td><tt>? super Long</tt></td>
</tr>

<tr VALIGN=TOP>
<td><tt>? extends Number</tt></td>

<td><tt>? super Number</tt></td>
</tr>

<tr VALIGN=TOP>
<td><tt>Long</tt></td>

<td><tt>Serializable</tt></td>
</tr>
</table>

<p>The wildcard "<tt>?</tt>" denotes the largest possible type set, namely
the set of all types.&nbsp; It is the superset of all type sets.
<p>Upper bound wildcards are fairly easy to understand, compared to lower
bound wildcards.&nbsp; The wildcard "<tt>? extends Serializable</tt>"&nbsp;
denotes the family of types that are subtypes of <tt>Serializable</tt>,
the type <tt>Serializable</tt> itself being included. Naturally, this type
family is a subset of the type set denoted by the wildcard "<tt>?</tt>".&nbsp;
<p>The wildcard "<tt>? extends Number</tt>"&nbsp; denotes the family of
types that are subtypes of <tt>Number</tt>, the type <tt>Number</tt> itself
being included. Since <tt>Number</tt> is a subtype of <tt>Serializable</tt>,
the type family "<tt>? extends Number</tt>" is a subset of the type family
"<tt>? extends Serializable</tt>".&nbsp; In other words, the super-sub<u>type</u>
relationship between the upper bounds leads to a super-sub<u>set</u>&nbsp;
relationship between the resulting type sets.&nbsp;
<p>The concrete type <tt>Long</tt> denotes a single-member type set, which
is a subset of the type family "<tt>? extends Number</tt>" because <tt>Long</tt>
is a subtype of <tt>Number</tt>.
<p>Among the lower bound wildcards, the wildcard "<tt>? super Long</tt>"&nbsp;
denotes the family of types that are supertypes of <tt>Long</tt>, the type
<tt>Long</tt>
itself being included.&nbsp; The wildcard "<tt>? super Number</tt>"&nbsp;
denotes the family of types that are supertypes of <tt>Number</tt>, the
type <tt>Number</tt> itself being included.&nbsp; <tt>Number</tt> is a
supertype of <tt>Long</tt>, and for this reason the type family "<tt>?
super Number</tt>" is smaller than the type family "<tt>? super Long</tt>";
the
latter includes type <tt>Long</tt> as member, while the former excludes
it.&nbsp; In other words, the super-sub<u>type</u> relationship between
the lower bounds leads to the opposite relationship between the resulting
type sets, namely&nbsp; a sub-super<u>set</u>&nbsp; relationship.
<p>
<hr WIDTH="100%">
<p><i>Multi-Level Wildcards</i>
<p>Matters are more complicated when it comes to multi-level wildcards.&nbsp;
In principle, the rules outlined above are extended to multi-level wildcards
in analogy.&nbsp; However, the resulting super-subset relationships tend
to be everything but intuitive to understand, so that in practice you will
probably want to refrain from overly complex multi-level wildcards.&nbsp;
Nonetheless, we discuss in the following the rules for super-subset relationships
among two-level wildcards.
<p>For multi-level wildcards we apply the same rules as before. The only
difference is that the bounds are wildcards instead of concrete types.
As a result we do not consider type relationships among the bounds, but
set relationships.
<ul>
<li>
<font color="#000000">A wildcard with an upper bound A denotes a superset
of another wildcard with an upper bound B, if A denotes a <u>super</u>set
of B.</font></li>

<li>
<font color="#000000">A wildcard with a lower bound A denotes a superset
of another wildcard with a lower bound B, if A denotes a <u>sub</u>set
of B.</font></li>
</ul>
The bounds A and B are wildcards and we can look up their super-subset
relationships in the tables above, which leads us to the following tables
for multi-level wildcards:
<br>&nbsp;
<table BORDER=0 CELLSPACING=3 CELLPADDING=3 BGCOLOR="#F4F4FF" >
<tr VALIGN=TOP BGCOLOR="#EDEFF3">
<td BGCOLOR="#FFFFFF"><b><font color="#000000">&nbsp;</font></b></td>

<td BGCOLOR="#C6CCDD"><b>upper-upper bound wildcards</b></td>

<td BGCOLOR="#C6CCDD"><b>upper-lower bound wildcards</b></td>
</tr>

<tr VALIGN=TOP>
<td VALIGN=TOP ROWSPAN="6" BGCOLOR="#FFFFFF"><img SRC="../Diagrams/SuperSubSet-small.jpg" NOSAVE height=139 width=18></td>

<td><tt>?</tt></td>

<td><tt>?</tt></td>
</tr>

<tr>
<td><tt>? extends ParType&lt;<b>?</b>></tt></td>

<td><tt>? extends ParType&lt;<b>?</b>></tt></td>
</tr>

<tr VALIGN=TOP>
<td><tt><nobr>? extends </nobr>ParType<nobr>&lt;<b>? extends <font color="#000099">SuperType</font></b>></nobr></tt></td>

<td><tt>? extends ParType&lt;<b>? super <font color="#330033">SubType</font></b>></tt></td>
</tr>

<tr VALIGN=TOP>
<td><tt><nobr>? extends </nobr>ParType<nobr>&lt;<b>? extends </b></nobr><b><font color="#330033">SubType</font></b><nobr>></nobr></tt></td>

<td><tt>? extends ParType&lt;<b>? super <nobr><font color="#000099">SuperType</font></nobr></b>></tt></td>
</tr>

<tr VALIGN=TOP>
<td><tt>? extends ParType&lt;</tt><b>concrete type</b>*<tt>></tt>
<br><font size=-2>*either <tt>SubType </tt>or a subtype thereof&nbsp;</font></td>

<td><tt><nobr>? extends </nobr>ParType<nobr>&lt;</nobr></tt><b>concrete
type</b>*<tt><nobr>></nobr></tt>
<br><font size=-2>*either <tt>SuperType </tt>or a supertype thereof</font></td>
</tr>

<tr>
<td>concrete type*<tt>&lt;</tt>concrete type**<tt>></tt>
<br><font size=-2>*either <tt>ParType</tt> or a subtype thereof</font>
<br><font size=-2>**either <tt>SubType </tt>or a subtype thereof</font></td>

<td>concrete type*<tt>&lt;</tt>concrete type**<tt>></tt>
<br><font size=-2>*either <tt>ParType </tt>or a subtype thereof</font>
<br><font size=-2>**either <tt>SuperType </tt>or a supertype thereof</font></td>
</tr>
</table>

<table BORDER=0 CELLSPACING=3 CELLPADDING=3 BGCOLOR="#F4F4FF" >
<tr VALIGN=TOP BGCOLOR="#EDEFF3">
<td BGCOLOR="#FFFFFF"><b><font color="#000000">&nbsp;</font></b></td>

<td BGCOLOR="#C6CCDD"><b>lower-upper bound wildcards</b></td>

<td BGCOLOR="#C6CCDD"><b>lower-lower bound wildcards</b></td>
</tr>

<tr VALIGN=TOP>
<td VALIGN=TOP ROWSPAN="6" BGCOLOR="#EDEFF3"><img SRC="../Diagrams/SuperSubSet-small.jpg" NOSAVE height=139 width=18></td>

<td><tt>?&nbsp;</tt></td>

<td><tt>?&nbsp;</tt></td>
</tr>

<tr>
<td><tt><nobr>? super </nobr>ParType<nobr>&lt;</nobr></tt><b>concrete type</b>*<tt><nobr>></nobr></tt>
<br><nobr><font size=-2>*either <tt>SubType</tt> or a subtype thereof</font></nobr></td>

<td><tt><nobr>? super </nobr>ParType<nobr>&lt;</nobr></tt><b>concrete type</b>*<tt><nobr>></nobr></tt>
<br><nobr><font size=-2>*either <tt>SuperType</tt> or a supertype thereof</font></nobr></td>
</tr>

<tr VALIGN=TOP>
<td><tt>? super ParType&lt;<b>? extends <font color="#330033">SubType</font></b>></tt></td>

<td><tt>? super ParType&lt;<b>? super <nobr><font color="#000099">SuperType</font></nobr></b>></tt></td>
</tr>

<tr VALIGN=TOP>
<td><tt><nobr>? super </nobr>ParType<nobr>&lt;<b>? extends <font color="#000099">SuperType</font></b>></nobr></tt></td>

<td><tt>? super ParType&lt;<b>? super <font color="#330033">SubType</font></b>></tt></td>
</tr>

<tr VALIGN=TOP>
<td><tt>? super ParType&lt;<b>?</b>></tt></td>

<td><tt>? super ParType&lt;<b>?</b>></tt></td>
</tr>

<tr>
<td>concrete type*<tt>&lt;?></tt>
<br><font size=-2>*either <tt>ParType</tt> or a supertype thereof</font></td>

<td>concrete type*<tt>&lt;?></tt>
<br><font size=-2>*either <tt>ParType</tt> or a supertype thereof</font></td>
</tr>
</table>

<p>The rules look fairly complex, but basically it is a recursive process.&nbsp;
For instance: the type set denoted by "<tt><nobr>? extends</nobr><font color="#000000">ParType<nobr>&lt;?
extends SuperType></nobr></font></tt><font color="#000000">"
</font>is
a superset of the type set denoted by "<tt><nobr>? extends </nobr>ParTyp<font color="#000000">e<nobr>&lt;?
extends </nobr>SubType<nobr>></nobr></font></tt><font color="#000000">"
</font>because
the upper bound "<tt><nobr><font color="#000000">? extends SuperType</font></nobr></tt>"
is a superset of the upper bound "<tt><font color="#000000"><nobr>? extends
</nobr>SubType</font></tt>",
and this is because the inner upper bound
<tt><nobr><font color="#000000">SuperType
</font></nobr></tt>is
a supertype of&nbsp; the inner upper bound <tt><font color="#000000">SubType</font></tt>.&nbsp;
In this recursive way, the super-subset relationships of multi-level wildcards
can be made plausible.&nbsp; Here are some concrete examples:
<p>Examples:
<br>&nbsp;
<table BORDER=0 CELLSPACING=3 CELLPADDING=3 BGCOLOR="#F4F4FF" >
<tr VALIGN=TOP BGCOLOR="#EDEFF3">
<td BGCOLOR="#FFFFFF"></td>

<td BGCOLOR="#C6CCDD"><b>upper-upper bound wildcards</b></td>

<td BGCOLOR="#C6CCDD"><b>upper-lower bound wildcards</b></td>
</tr>

<tr>
<td ROWSPAN="6"><img SRC="../Diagrams/SuperSubSet-small.jpg" NOSAVE height=139 width=18></td>

<td><tt>?</tt></td>

<td><tt>?</tt></td>
</tr>

<tr>
<td><tt>? extends List&lt;?></tt></td>

<td><tt>? extends List&lt;?></tt></td>
</tr>

<tr VALIGN=TOP>
<td><tt>? extends List&lt;? extends Serializable></tt></td>

<td><tt>? extends List&lt;? super Long></tt></td>
</tr>

<tr VALIGN=TOP>
<td><tt><nobr>? extends List&lt;? extends Number></nobr></tt></td>

<td><tt><nobr>? extends List&lt;? super Number></nobr></tt></td>
</tr>

<tr VALIGN=TOP>
<td><tt>? extends List&lt;Long></tt></td>

<td><tt>? extends List&lt;Serializable></tt></td>
</tr>

<tr>
<td><tt>ArrayList&lt;Long></tt></td>

<td><tt>LinkedList&lt;Serializable></tt></td>
</tr>
</table>

<table BORDER=0 CELLSPACING=3 CELLPADDING=3 BGCOLOR="#F4F4FF" >
<tr VALIGN=TOP BGCOLOR="#EDEFF3">
<td BGCOLOR="#FFFFFF"></td>

<td BGCOLOR="#C6CCDD"><b>lower-upper bound wildcards</b></td>

<td BGCOLOR="#C6CCDD"><b>lower-lower bound wildcards</b></td>
</tr>

<tr>
<td VALIGN=TOP ROWSPAN="6" BGCOLOR="#EDEFF3"><img SRC="../Diagrams/SuperSubSet-small.jpg" NOSAVE height=139 width=18></td>

<td><tt>?</tt></td>

<td><tt>?&nbsp;</tt></td>
</tr>

<tr>
<td><tt>? super List&lt;Long></tt></td>

<td><tt>? super List&lt;Object></tt></td>
</tr>

<tr VALIGN=TOP>
<td><tt>? super List&lt;? extends Number></tt></td>

<td><tt><nobr>? super List&lt;? super Serializable></nobr></tt></td>
</tr>

<tr VALIGN=TOP>
<td><tt><nobr>? super List&lt;? extends Serializable></nobr></tt></td>

<td><tt>? super List&lt;? super Number></tt></td>
</tr>

<tr VALIGN=TOP>
<td><tt>? super List&lt;?></tt></td>

<td><tt>? super List&lt;?></tt></td>
</tr>

<tr>
<td><tt>Collection&lt;?></tt></td>

<td><tt>Collection&lt;?></tt></td>
</tr>
</table>
</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ208">#FAQ208</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#How do parameterized types fit into the Java type system?">How
do parameterized types fit into the Java type system?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which super-subtype relationships exist among instantiations of parameterized types?">Which
super-subtype relationships exist among instantiations of parameterized
types?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is the raw type?">What
is the raw type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a concrete instantiation?">What
is a concrete instantiation?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a wildcard instantiation?">What
is a wildcard instantiation?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is an unbounded wildcard instantiation?">What
is the unbounded wildcard instantiation?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ209"></a>
<h2>
<a NAME="Does extends always mean inheritance?"></a><font face="Arial,Helvetica"><font size=+0>Does
"extends" always mean "inheritance"?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>No.&nbsp;</i></b></td>
</tr>

<tr>
<td COLSPAN="2"><tt>extends</tt> is an overloaded keyword in the Java programming
language.&nbsp; It has different meanings, depending on the context in
which it appears. The <tt>extends</tt> keyword can appear in four different
locations:
<ul>
<li>
in the definition of a class</li>

<li>
in the definition of an interface</li>

<li>
in the definition of type parameter bounds</li>

<li>
in the definition of wildcard bounds</li>
</ul>
Below we discuss each of these cases in detail.&nbsp; Basically it boils
down to the observation that <tt>extends</tt> refers to more general super-subtype
relationship, of which inheritance is a special case.&nbsp; In conjunction
with class and interface definitions <tt>extends</tt> means inheritance.&nbsp;
In conjunction with type parameter bounds and wildcard bounds <tt>extends
</tt>it
means either inheritance, or identity, or member of a type family denoted
by a wildcard instantiation.
<br>&nbsp;
<p><i>Definition of classes and interfaces</i>
<p>Example (<tt>extends</tt> in the definition of a class):
<blockquote><tt>public class Quadruple&lt;T> <b><font color="#000066">extends</font></b>
Triple&lt;T> {</tt>
<br><tt>&nbsp; private T fth;</tt>
<br><tt>&nbsp; public Triple(T t1, T t2, T t3, T t4) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; super(T1, t2, t3);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fth = t4;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>}</tt></blockquote>
This is an example where <tt>extends</tt> means inheritance. We define
a subclass <tt>Quadruple</tt> that is derived from a superclass <tt>Triple</tt>.&nbsp;
This kind of inheritance exists between non-generic and generic classes.
It leads to a super-subtype relationship between the two types.&nbsp; In
case of generic types it leads to a super-subtype relationship between
instantiations of the two types that have identical type arguments.&nbsp;
For instance, <tt>Triple&lt;Long></tt> is a subtype of <tt>Triple&lt;Long></tt>,
and <tt>Quadruple&lt;? extends Number></tt> is a subtype of <tt>Triple&lt;?
extends Number></tt>.&nbsp;
<p>Example (<tt>extends</tt> in the definition of an interface):
<blockquote><tt>public interface SortedSet&lt;E> <b><font color="#000066">extends</font></b>
Set&lt;E> {</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>}</tt></blockquote>
This is another example where <tt>extends</tt> means inheritance. This
time the inheritance relationship exists between two interfaces instead
of two classes. We have the super-subtype relationships as for classes.
<br>&nbsp;
<p><i>Definition of type parameter bounds</i>
<p>Example (<tt>extends</tt> in the definition of type parameter bounds):
<blockquote><tt>public class Caller&lt;V, T <b><font color="#000066">extends</font></b>
Callable&lt;V>> {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public Caller(T task) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FutureTask&lt;V> future = new FutureTask&lt;V>(task);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread thread = new Thread(future);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; thread.setDaemon(false);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; thread.start();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try { System.out.println ("result:
" + future.get()); }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch (Exception e) { e.printStackTrace();
}</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt></blockquote>
In this example <tt>extends</tt> does not mean inheritance.&nbsp; The <tt>extends</tt>
keyword is here used to define the bounds of a type parameter.&nbsp; A
common misunderstanding is that the type argument that later replaces the
type parameter in an instantiation must inherit from the bounds.&nbsp;
This is often the case, but it is not the only option.
<p>In our example, we can supply a sub-interface of <tt>Callable&lt;V></tt>
as a type argument, that is, an interface that <u>extends</u> the bound.&nbsp;
But we can also supply a class type that <u>implements</u> the bound.&nbsp;
In other words, <tt>extends</tt> in conjunction with type parameter bounds
does not strictly mean inheritance, but it also includes the <tt>implements</tt>-relationship
that exists between classes and interfaces.
<p>In conjunction with type parameter bounds the <tt>extends</tt> keyword
refers to an even broader notion of subtyping.&nbsp; It includes relationships
that cannot be expressed in terms of <tt>extends</tt> or <tt>implements</tt>
as we know them from non-generic Java. Consider the following example.
<p>Example (<tt>extends</tt> in the definition of a type parameter bound
that is a final class):
<blockquote><tt>public class SomeClass&lt;T <b><font color="#000066">extends</font></b>
String> {</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>}</tt></blockquote>
In this example the bound is a final class.&nbsp; Final classes cannot
be inherited from.&nbsp; The only permitted type argument is type <tt>String</tt>,
which is not a type that inherits from the bound; it is the bound itself.&nbsp;&nbsp;
When applied to a bound that is a final class, <tt>extends</tt> does not
mean inheritance; it means <i>identity</i>.
<p>Let us consider another example that demonstrates that <tt>extends</tt>
in conjunction with type parameter bounds means more than inheritance.
<p>Example (<tt>extends</tt> in the definition of a type parameter bound
that is a wildcard parameterized type):
<blockquote><tt>public class SomeClass&lt;T <b><font color="#000066">extends</font></b>
Collection&lt;?>> {</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>}</tt></blockquote>
In this example the bound is a wildcard instantiation of the <tt>Collection</tt>
interface. Wildcard parameterized types cannot be inherited from. In this
case
<tt>extends</tt> does not mean inheritance either. It refers to the
super-subtype relationship that exists among wildcard parameterized types
and concrete parameterized type.&nbsp; Conceivable type arguments would
be concrete parameterized type, such as <tt>Collection&lt;String></tt>
or <tt>List&lt;Long></tt>,&nbsp; but also other wildcard parameterized
types, such as <tt>Collection&lt;? extends Number></tt>.&nbsp; These type
arguments do not inherit from the bound, but they are members of the type
family that the bound denotes. When applied to a bound that is a wildcard
parameterized type, <tt>extends</tt> does not mean inheritance; it means
<i>member of the type family </i>denoted by the wildcard parameterized
type.
<br>&nbsp;
<p><i>Definition of wildcard bounds</i>
<p>Example (<tt>extends</tt> in the definition of a wildcard bound):
<blockquote><tt>List&lt;? <b><font color="#000066">extends</font></b> Number>
ref = new ArrayList&lt;Number>();</tt></blockquote>
The meaning of <tt>extends</tt> in conjunction with wildcard bounds is
similar to the meaning of <tt>extends</tt> in conjuction with type parameter
bounds.&nbsp; It does NOT mean that the unknown type that the wildcard
stands for (the so-called<i> wildcard capture</i>) must inherit from the
wildcard bound. It can, but it does not have to. The capture can equally
well be the bound itself and <tt>extends</tt> would mean identity instead
of inheritance.&nbsp;
<p>If the bound is a wildcard parameterized type, then <tt>extends</tt>
refers to the subtype relationship that exists among wildcard parameterized
types and concrete parameterized types.
<p>Example (<tt>extends</tt> in the definition of a wildcard bound):
<blockquote><tt>Triple&lt;? <b><font color="#000066">extends</font></b>
Collection&lt;?>> q = new Triple&lt;List&lt;? extends Number>>();</tt></blockquote>
In this example the wildcard capture cannot be a type that inherits from
the bound, because wildcard parameterized types such as <tt>Collection&lt;?></tt>
cannot be inherited from.&nbsp; Instead the wildcard capture must be a
member of the type family denoted by <tt>Collection&lt;?></tt>,&nbsp; such
as <tt>Collection&lt;String></tt>, <tt>List&lt;Number></tt>, <tt>List&lt;?></tt>
or <tt>List&lt;? extends Number></tt>.&nbsp; Again, <tt>extends</tt> does
not mean inheritance; it means <i>member of the type family </i>denoted
by the wildcard parameterized type.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ209">#FAQ209</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#How do parameterized types fit into the Java type system?">How
do parameterized types fit into the Java type system?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which super-subset relationships exist among wildcards?">Which
super-subset relationships exist among wildcards?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#What is the capture of a wildcard?">What
is the capture of a wildcard?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350>
<br>&nbsp;
<h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450></h3>

<h3>
<a NAME="Exception Handling"></a>Exception Handling</h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450><a NAME="FAQ301"></a>
<h2>
<a NAME="Can I use parameterized types in exception handling?"></a><font face="Arial,Helvetica"><font size=+0>Can
I use generic or parameterized types in exception handling?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>No.&nbsp; Exception and error types must
not be generic.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">It is illegal to define generic types that are directly
or indirectly derived from class <tt>Throwable</tt>. Consequently, no instantiations
of generic type appear anywhere in exception handling.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ301">#FAQ301</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#Why are parameterized exception and error types illegal?">Why
are generic exception and error types illegal?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ302"></a>
<h2>
<a NAME="Why are parameterized exception and error types illegal?"></a><font face="Arial,Helvetica"><font size=+0>Why
are generic exception and error types illegal?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Because the virtual machine cannot distinguish
between different instantiations of a generic exception type.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">A generic class must not directly or indirectly be derived
from class <tt>Throwable</tt>, which means that generic exception or error
types are not allowed. Imagine if they were allowed ...
<p>Example (of illegal generic exception type):
<blockquote><tt>class IllegalArgumentException&lt;T> extends Exception
{&nbsp;&nbsp; <b><font color="#660000">// illegal</font></b></tt>
<br><tt>&nbsp; private T info;</tt>
<br><tt>&nbsp; public IllegalArgumentException(T arg) { info = arg; }</tt>
<br><tt>&nbsp; public T getInfo() { return info; }&nbsp;</tt>
<br><tt>}</tt></blockquote>
We might then want to catch instantiations of this (illegal) generic exception
type.
<p>Example (of illegal&nbsp; use of illegal parameterized exception type):
<blockquote><tt>void method_1() {</tt>
<br><tt>&nbsp; try { method_2(); }</tt>
<br><tt>&nbsp; catch (IllegalArgumentException&lt;String> e) { ... } <b><font color="#660000">//
illegal</font></b></tt>
<br><tt>&nbsp; catch (IllegalArgumentException&lt;Long> e) { ... }&nbsp;&nbsp;
<b><font color="#660000">// illegal</font></b></tt>
<br><tt>&nbsp; catch (Throwable e) { ... }</tt>
<br><tt>}</tt></blockquote>
Taking into account that generic Java source code is translated to Java
byte code by type erasure, it should be clear that the method's <tt>catch</tt>
clauses do not make any sense.&nbsp; Both parameterized exception types
have the same runtime type and the mechanism for catching exceptions is
a runtime mechanism performed by the virtual machine based on the non-exact
runtime types.&nbsp; The JVM has no chance to distinguish between different
instantiations of the same generic (exception) type.&nbsp; For this reason,
generic exception and error types are pointless in Java and banned from
the language. (Note that generic exception and error types are not pointless
per se, but in the context of Java generics with type erasure their are
nonsensical.)
<p>Other problems occur when we define methods that throw instantiations
of an (illegal) generic exception type.
<p>Example (of illegal&nbsp; use of illegal parameterized exception type):
<blockquote><tt>void method_1()&nbsp;</tt>
<br><tt>&nbsp; throws IllegalArgumentException&lt;String>, IllegalArgumentException&lt;Long>
{ <b><font color="#660000">// illegal</font></b></tt>
<br><tt>&nbsp; ... do something ...</tt>
<br><tt>&nbsp; throw new IllegalArgumentException&lt;String>("argument
missing");</tt>
<br><tt>&nbsp; ... do something&nbsp; else ...</tt>
<br><tt>&nbsp; throw new IllegalArgumentException&lt;Long>(timeout);</tt>
<br><tt>}</tt></blockquote>
Again, after type erasure, both parameterized exception types have the
same runtime type and the method's <tt>throws</tt> clause is nonsensical.
The method could at best throw the raw type, which means that it must not
create and throw any instantiations of the (illegal) generic type either.&nbsp;
Another reason to disallow generic exception and error types.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ302">#FAQ302</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#What is type erasure?">What
is type erasure?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ303"></a>
<h2>
<a NAME="Can I use a type parameter in exception handling?"></a><font face="Arial,Helvetica"><font size=+0>Can
I use a type parameter in exception handling?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>It depends.&nbsp;</i></b></td>
</tr>

<tr>
<td COLSPAN="2">&nbsp;Type parameters can appear in <tt>throws</tt> clauses,
but not in <tt>catch</tt> clauses.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ303">#FAQ303</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#Can I use a type parameter in a catch clause?">Can
I use a type parameter in a catch clause?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Can I use a type parameter in in a throws clause?">Can
I use a type parameter in in a throws clause?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Can I throw an object whose type is a type parameter?">Can
I throw an object whose type is a type parameter?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ304"></a>
<h2>
<a NAME="Can I use a type parameter in a catch clause?"></a><font face="Arial,Helvetica"><font size=+0>Can
I use a type parameter in a catch clause?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>No.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Using a type parameter in a <tt>catch</tt> clause is nonsensical
because of the translation by type erasure.
<p>Example (before type erasure):
<blockquote><tt><font color="#000099">&lt;<b>E extends Exception</b>></font>
void someMethod() {</tt>
<br><tt>&nbsp; try {  do something that might raise an exception </tt>
<br><tt>&nbsp; } catch (<b><font color="#000099">E</font></b> e) {  do
something special for this particular exception type </tt>
<br><tt>&nbsp; } catch (IllegalStateException e) {  handle illegal state
</tt>
<br><tt>&nbsp; } catch (Exception e) {  handle all remaining exceptions
</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
Example (after type erasure):
<blockquote><tt>void someMethod() {</tt>
<br><tt>&nbsp; try {  do something that might raise an exception </tt>
<br><tt>&nbsp; } catch (<b><font color="#330033">Exception</font></b> e)
{  do something special for this particular exception type </tt>
<br><tt>&nbsp; } catch (IllegalStateException e) {  handle illegal state
</tt>
<br><tt>&nbsp; } catch (Exception e) {  handle all remaining exceptions
</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
After type erasure the <tt>catch</tt> clause would boil down to a <tt>catch</tt>
clause using the type parameter's bound.&nbsp; This is because type parameters
do not have a runtime type representation of themselves.&nbsp; Type parameters
are replaced by their leftmost bound in the course of translation by type
erasure. In our example the <tt>catch</tt> clause for the unknown exception
type <tt>E </tt>is translated by type erasure to a <tt>catch</tt> clause
for type <tt>Exception</tt>, which is the bound of the type parameter <tt>E</tt>.&nbsp;
This <tt>catch</tt> clause for type <tt>Exception</tt> precedes further
<tt>catch</tt>
clauses for other exception types, and renders them pointless.
<p>In other words, there never is a <tt>catch</tt> clause for the particular
unknown exception type that the type argument stands for. Instead of catching
a particular exception type we end up catching the bound of the unknown
exception type, which changes the meaning of the sequence of <tt>catch</tt>
clauses substantially and is almost always undesired.&nbsp; For this reason,
the use of type parameters in <tt>catch</tt> clauses is illegal.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ304">#FAQ304</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#Can I use a type parameter in in a throws clause?">Can
I use a type parameter in in a throws clause?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Can I throw an object whose type is a type parameter?">Can
I throw an object whose type is a type parameter?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ305"></a>
<h2>
<a NAME="Can I use a type parameter in in a throws clause?"></a><font face="Arial,Helvetica"><font size=+0>Can
I use a type parameter in in a throws clause?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Yes.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Using a type paramter in a <tt>throws</tt> clause is permitted.
<p>Example (before type erasure):
<blockquote><tt>public interface Action&lt;E extends Exception> {</tt>
<br><tt>&nbsp; void run() <b><font color="#000099">throws E</font></b>;</tt>
<br><tt>}</tt>
<br><tt>public final class Executor {</tt>
<br><tt>&nbsp; public static &lt;E extends Exception></tt>
<br><tt>&nbsp;&nbsp;&nbsp; void execute(Action&lt;E> action) <b><font color="#000099">throws
E</font></b> {&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; action.run();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br><tt>public final class Test {</tt>
<br><tt>&nbsp; private static class TestAction implements <b><font color="#000099">Action&lt;java.io.FileNotFoundException></font></b>
{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public void run() <b><font color="#006600">throws
java.io.FileNotFoundException</font></b><font color="#000000"> {</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><b><font color="#006600">throw
new java.io.FileNotFoundException()</font></b><font color="#000000">;&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font></tt>
<br><tt><font color="#000000">&nbsp; }</font></tt>
<br><tt>&nbsp; public static void main(String[] args) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; try {&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Executor.execute(new TestAction())<font color="#000000">;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; } </font><b><font color="#006600">catch
(java.io.FileNotFoundException f)</font></b><font color="#000000"> </font>{
 }</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}&nbsp;</tt></blockquote>
In this example we see a generic interface <tt>Action</tt> whose type parameter
<tt>E</tt> is the exception type that its <tt>run</tt> method throws.&nbsp;
This is perfectly reasonable, because <tt>throws</tt> clauses are a compile-time
feature and the lack of a runtime type representation of the type parameter
is not needed. At runtime, a particular exception type will have replaced
the type parameter <tt>E</tt>, so that we would throw and catch an object
of a concrete exception type.&nbsp; In our example we instantiate the <tt>Action</tt>
interface using the <tt>FileNotFound</tt> exception type as a type argument,
so that a <tt>FileNotFound</tt> exception is raised and caught.&nbsp;
<p>Even after type erasure the code snippet above still captures the intent.
<p>Example (after type erasure):
<blockquote><tt>public interface Action {</tt>
<br><tt>&nbsp; void run() <font color="#000000">throws </font><b><font color="#330033">Exception</font></b>;</tt>
<br><tt>}</tt>
<br><tt>public final class Executor {</tt>
<br><tt>&nbsp; public static void execute(Action action) <font color="#000000">throws
</font><b><font color="#330033">Exception
</font></b>{&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; action.run();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br><tt>public final class Test {</tt>
<br><tt>&nbsp; private static class TestAction implements Action {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public void run() <b><font color="#006600">throws
java.io.FileNotFoundException</font></b><font color="#000000"> {</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><b><font color="#006600">throw
new java.io.FileNotFoundException()</font></b><font color="#000000">;&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font></tt>
<br><tt><font color="#000000">&nbsp; }</font></tt>
<br><tt>&nbsp; public static void main(String[] args) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; try {&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Executor.execute(new TestAction())<font color="#000000">;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; } </font><b><font color="#006600">catch
(java.io.FileNotFoundException f)</font></b><font color="#000000"> </font>{
 }</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}&nbsp;</tt></blockquote>
</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ305">#FAQ305</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#Can I use a type parameter in a catch clause?">Can
I use a type parameter in a catch clause?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Can I throw an object whose type is a type parameter?">Can
I throw an object whose type is a type parameter?</a></font></font></td>
</tr>
</table>

<h2>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ306"></a></h2>

<h2>
<a NAME="Can I throw an object whose type is a type parameter?"></a><font face="Arial,Helvetica"><font size=+0>Can
I throw an object whose type is a type parameter?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>In principle, yes, but in practice, not
really.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">We can declare methods that throw an exception (or error)
of unknown type.
<p>Example (of method with type parameter in <tt>throws</tt> clause):
<blockquote><tt>interface Task&lt;<b><font color="#000099">E extends Exception</font></b>>
{</tt>
<br><tt>&nbsp; void run() <b><font color="#000099">throws E</font></b>;</tt>
<br><tt>}</tt></blockquote>
Can such a method throw an object of the unknown exception (or error) type?&nbsp;
The method has in principle 3 ways of raising such an exception (or error):
<ul>
<li>
create a new exception (or error) and throw it</li>

<li>
catch the exception (or error) of an invoked operation and re-throw it</li>

<li>
propagate the exception (or error) of an invoked operation</li>
</ul>
As we must not create objects of an unknown type the first possibility
is not an option.&nbsp; Since type parameters must not appear in catch
clauses, we cannot catch and therefore not re-throw an exception of an
unknown type.&nbsp; At best, we can propagate an exception of unknown type
that is raised by any of the invoked operations.
<p>Example (throwing an object of unknown type):
<blockquote><tt>final class CleanUp&lt;<b><font color="#000099">E extends
Exception</font></b>, T extends Task&lt;E>> {</tt>
<br><tt>&nbsp; public void cleanup(T task) <b><font color="#000099">throws
E</font></b> {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; <b>task.run();</b></tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br><tt>final class DisconnectTask implements Task&lt;IllegalAccessException>
{</tt>
<br><tt>&nbsp; public void run() throws IllegalAccessException {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp;&nbsp;&nbsp; throw new IllegalAccessException();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br><tt>class Test {</tt>
<br><tt>&nbsp; public static void main(String[] args) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; CleanUp&lt;IllegalAccessException,DisconnectTask>
cleaner&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = new CleanUp&lt;IllegalAccessException,DisconnectTask>();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; try { cleaner.cleanup(new DisconnectTask());
}</tt>
<br><tt>&nbsp;&nbsp;&nbsp; catch (IllegalAccessException e) { e.printStackTrace();
}</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ306">#FAQ306</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="TypeParameters.html#Can I create an object whose type is a type parameter?">Can
I create an object whose type is a type parameter?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Can I use a type parameter in a catch clause?">Can
I use a type parameter in a catch clause?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Can I use a type parameter in in a throws clause?">Can
I use a type parameter in in a throws clause?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350>
<br>&nbsp;
<h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450></h3>

<h3>
<a NAME="Static Context"></a>Static Context</h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450><a NAME="FAQ351"></a>
<br>&nbsp;
<h2>
<a NAME="How do I refer to static members of a parameterized type?"></a><font face="Arial,Helvetica"><font size=+0>How
do I refer to static members of a parameterized type?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Using the raw type as the scope qualifier,
instead of the any instantiation of the generic type.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">If you refer to a static member of a generic type, the
static member name must be preceded by the name of the enclosing scope,
such as <tt>EnclosingType.StaticMember</tt>.&nbsp; In case of a generic
enclosing type the question is: which instantiation of the generic type
can or must be used as the scope qualifier?
<p>The rule is that no instantiation can be used.&nbsp; The scope is qualified
using the raw type.&nbsp; This is because there is only one instance of
a static member per type.&nbsp;
<p>Example (of a generic type with static members):
<blockquote><tt>public final class Counted&lt;T> {</tt>
<br><tt>&nbsp; public&nbsp; <b>static</b> final int MAX = 1024;</tt>
<br><tt>&nbsp; public&nbsp; <b>static</b> class BeyondThresholdException
extends Exception {}</tt>
<p><tt>&nbsp; private <b>static</b> int count;</tt>
<br><tt>&nbsp; public&nbsp; <b>static</b> int getCount() { return count;
}</tt>
<p><tt>&nbsp; private final T value;</tt>
<br><tt>&nbsp; public Counted(T arg) throws BeyondThresholdException {&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; value = arg;&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; count++;&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if (count >= 1024)&nbsp; throw new BeyondThresholdException();</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; public void finalize() { count--; }</tt>
<br><tt>&nbsp; public T getValue() { return value; }</tt>
<br><tt>}</tt>
<p>
<hr WIDTH="100%">
<p><tt>int m = <b>Counted</b>.MAX;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<b><font color="#003300">// ok</font></b></tt>
<br><tt>int k = <b>Counted<font color="#660000">&lt;Long></font></b>.MAX;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<b><font color="#660000">// error</font></b></tt>
<br><tt>int n = <b>Counted<font color="#660000">&lt;?></font></b>.MAX;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<b><font color="#660000">// error</font></b></tt>
<p><tt>try {</tt>
<br><tt>&nbsp; Counted&lt;?>[] array = null;</tt>
<br><tt>&nbsp; array[0] = new Counted&lt;Long>(10L);</tt>
<br><tt>&nbsp; array[1] = new Counted&lt;String>("abc");</tt>
<br><tt>}</tt>
<br><tt>catch (<b>Counted</b>.BeyondThresholdException e) {</tt>
<br><tt>&nbsp; e.printStackTrace();</tt>
<br><tt>}</tt>
<br><tt>System.out.println(<b>Counted</b>.getCount());&nbsp;&nbsp; <b><font color="#003300">//
ok</font></b></tt>
<br><tt>System.out.println(<b>Counted<font color="#660000">&lt;Long></font></b>.getCount());
<b><font color="#660000">//
error</font></b></tt>
<br><tt>System.out.println(<b>Counted<font color="#660000">&lt;?></font></b>.getCount());
<b><font color="#660000">//
error</font></b></tt>
<br>&nbsp;</blockquote>
In the example above, the generic class <tt>Counted</tt> has a static member
<tt>MAX</tt> and there is only one unique <tt>Counted.MAX</tt>, regardless
of the number of objects of type <tt>Counted</tt> and regardless of the
number of instantiations of the generic type <tt>Counted</tt> that may
be used somewhere in the program. Referring to <tt>MAX</tt> as
<tt>Counted&lt;String>.MAX</tt>,
<tt>Counted&lt;Long>.MAX</tt>,
<tt>Counted&lt;?>.MAX</tt>,
etc. would be misleading, because it suggests that there were several manifestations
of the <tt>MAX</tt> member, which is not true.&nbsp; There is only one
<tt>Counted.MAX</tt>,
and it must be referred to using the raw type <tt>Counted</tt> as the scope
qualifier. The same is true for other static members such as static methods
and static nested types.&nbsp; The example illustrates that we must refer
to the static method as <tt>Counted.getCount</tt> and to the static nested
exception class as <tt>Counted.BeyondThresholdException</tt>.
<p>In sum, it is illegal to refer to a static member using an instantiation
of the generic enclosing type.&nbsp; This is true for all categories of
static members, including static fields, static methods, and static nested
types, because each of these members exists only once per type.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ351">#FAQ351</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="TypeParameters.html#Is there one instances of a static field per instantiation of a parameterized type?">Is
there one instances of a static field per instantiation of a generic type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeParameters.html#Why can't I use a type parameter in any static context of the parameterized class?">Why
can't I use a type parameter in any static context of the generic class?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#How do I refer to an interface type nested into a parameterized type?">How
do I refer to an interface type nested into a generic type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#How do I refer to an enum type nested into a parameterized type?">How
do I refer to an enum type nested into a generic type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#How do I refer to a (non-static) inner class of a parameterized type?">How
do I refer to a (non-static) inner class of a generic type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Can I import a particular instantiation of parameterized type?">Can
I import a particular instantiation of generic type?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ352"></a>
<h2>
<a NAME="How do I refer to a (non-static) inner class of a parameterized type?"></a><font face="Arial,Helvetica"><font size=+0>How
do I refer to a (non-static) inner class of a generic type?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Using an instantiation of the enclosing
generic type as the scope qualifier, instead of the raw type.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Static nested types are referred to using the raw form
of the enclosing generic type as the scope qualifier.&nbsp; This is different
for inner classes.&nbsp;
<p>Like a static nested type, an inner class exists only once, in the sense
that there is only one <tt>.class</tt> file that represents the inner class.&nbsp;
Different from a static nested type, an inner class depends on the type
argument of its outer class type.&nbsp; This is because each object of
an inner class type has a hidden reference to an object of the outer class
type.&nbsp; The type of this hidden reference is an instantiation of the
generic enclosing type.&nbsp; As a result, the inner class type is not
independent of the enclosing class's type arguments.
<p>Example (of an inner class nested into a generic outer class):
<blockquote><tt>&nbsp;class Sequence<b><font color="#000099">&lt;E></font></b>
{</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private E[] theSequence;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private int idx;</tt>
<p><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // static classes</tt></b>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static class
NoMoreElementsException extends Exception {}</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static class
NoElementsException extends Exception {}&nbsp;</tt>
<p><b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (non-static) inner
class</tt></b>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public class Iterator
{&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
boolean hasNext() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return (theSequence != null &amp;&amp; idx &lt; theSequence.length);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#000099">E</font></b>
getNext() throws NoElementsException,&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
NoMoreElementsException,&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
java.lang.IllegalStateException {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (theSequence == null)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
throw new NoElementsException();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (idx &lt; 0)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
throw new java.lang.IllegalStateException();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (idx >= theSequence.length)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
throw new NoMoreElementsException();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
else</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return theSequence[idx++];</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public Iterator getIterator()
{</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return this.new Iterator();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<p><tt>class Test {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; private static &lt;T> void print(Sequence&lt;T>
seq)&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throws <b>Sequence.NoElementsException</b>,&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Sequence.NoMoreElementsException {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Sequence<font color="#000099">&lt;T></font>.Iterator</b>
iter = seq.new Iterator();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (iter.hasNext())</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
System.out.println(iter.getNext());&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp; public static void main(String[] args) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Sequence&lt;String> seq1 = new Sequence&lt;String>();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
... fill the sequence ...</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
print(seq1);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Sequence&lt;Long> seq2 = new Sequence&lt;Long>();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
... fill the sequence ...</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
print(seq2);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch (Exception e)
{ e.printStackTrace();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt></blockquote>
In the example above, the inner class <tt>Iterator</tt> depends on the
outer class's type parameter <tt>E</tt>: the type parameter <tt>E</tt>
is the return type of the iterator's <tt>getNext</tt> method and the inner
class access the outer class's array of elements of type <tt>E</tt>.&nbsp;&nbsp;
For this reason, the iterator type is referred to as <tt>Sequence&lt;T>.Iterator</tt>
(using an instantiation), instead of just <tt>Sequence.Iterator</tt> (using
the raw type).&nbsp; This does not imply, that a scope qualification using
the raw type is illegal; it is permitted and it means that the outer object
being referred to by the inner object is of the raw type instead of a more
specific type.
<p>In contrast, the nested exception types are <i>static</i> classes and
do <i>not</i> depend on the outer class's type parameter. (Static nested
types never depend on their enclosing type's type parameters, because the
type parameters must not appear in any static context of a generic class.
Details are explained in a separate FAQ entry.) Static nested classes must
be referred to using the raw type as the scope qualifier, that is, as <tt>Sequence.NoElementsException</tt>;&nbsp;
use of an instantiation as the scope, such as <tt>Sequence&lt;T>.NoElementsException</tt>,
is illegal.&nbsp;</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ352">#FAQ352</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#How do I refer to static members of a parameterized type?">How
do I refer to static members of a generic type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeParameters.html#Why can't I use a type parameter in any static context of the parameterized class?">Why
can't I use a type parameter in any static context of the generic class?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ353"></a>
<h2>
<a NAME="How do I refer to an interface type nested into a parameterized type?"></a><font face="Arial,Helvetica"><font size=+0>How
do I refer to an interface type nested into a generic type?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Using the raw type as the scope qualifier,
instead of the any instantiation of the generic type.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Nested interfaces are implicitly static. This is sometimes
confusing because the interface looks like it were a non-static member
of its enclosing class, while in fact it is static. As a static member
of a generic type it must be referred to using the raw form of the enclosing
type as the scope qualifier.&nbsp; Using an instantiation as the scope
qualifier is illegal and rejected by the compiler.&nbsp;
<p>Example (of a nested interface):
<blockquote><tt>class <b>Controller<font color="#000099">&lt;E extends
Executor</font></b><font color="#000099">></font> {</tt>
<br><tt>&nbsp; private E executor;</tt>
<br><tt>&nbsp; public Controller(E e) { executor = e; }</tt>
<br><tt>&nbsp; ...&nbsp;</tt>
<br><tt>&nbsp; public <b><font color="#000099">interface</font> Command</b>
{ void&nbsp; doIt(Runnable task); }&nbsp;</tt>
<p><tt>&nbsp; public Command command() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return new Command() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void&nbsp; doIt(Runnable
task) { executor.execute(task); }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; };</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br><tt>class Test</tt>
<br><tt>&nbsp; public static void test(Controller&lt;ThreadPoolExecutor>
c) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; <b>Controller&lt;ExecutorService> </b>controller&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = new Controller&lt;ExecutorService>(Executors.newCachedThreadPool());</tt>
<br><tt>&nbsp;&nbsp;&nbsp; <b>Controller.Command</b> command = controller.command();&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
The <tt>Command</tt> interface is nested into the generic <tt>Controller</tt>
class.&nbsp; The compiler does not allow that we refer to the nested interface
using any instantiation of the enclosing generic class as the scope qualifier.&nbsp;
Instead of saying <tt>Controller&lt;ExecutorService>.Command
</tt>we must
say <tt>Controller.Command</tt>.
<p>Below is another example of a nested interface taken from the <tt>java.util
</tt>package.&nbsp;
The generic <tt>Map</tt> interface has a nested
<tt>Entry</tt> interface.&nbsp;
<p>Example (of a nested interface taken from package <tt>java.util</tt>):
<blockquote><tt>public interface <b>Map<font color="#000099">&lt;K,V></font></b>
{</tt>
<br><tt>&nbsp; public <b><font color="#000099">interface</font> Entry&lt;K,V></b>
{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public K getKey();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; public V getValue();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; public Set&lt;<b>Map.Entry&lt;K, V></b>> entrySet();</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>}</tt></blockquote>
The source code above is an excerpt from the JDK source code.&nbsp; Note
that the nested interface <tt>Entry</tt> is generic itself and has its
own type parameters, which are independent of the outer interface's type
parameters.&nbsp; The fact that the type parameters of inner and outer
interface have the same names, namely <tt>K</tt> and <tt>V</tt>, is perhaps
confusing, but perfectly legal. The inner interface's type parameters
<tt>K</tt>
and <tt>V</tt> are visible only inside the inner interface and have nothing
to do with the outer interface's type parameters <tt>K</tt> and <tt>V</tt>.
<p>When the inner interface <tt>Entry</tt> is used it must be referred
to using the raw type <tt>Map</tt> as the scope qualifier, that is, as
<tt><font color="#000000">Map.Entry&lt;String,Long>
</font></tt>for
instance. A qualification such as&nbsp; <tt><font color="#000000">Map&lt;String,Long>.Entry&lt;String,Long>
</font></tt>is
illegal.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ353">#FAQ353</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="TypeParameters.html#Why can't I use a type parameter in any static context of the parameterized class?">Why
can't I use a type parameter in any static context of the generic class?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#How do I refer to static members of a parameterized type?">How
do I refer to static members of a parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Can I import a particular instantiation of parameterized type?">Can
I import a particular instantiation of parameterized type?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ354"></a>
<h2>
<a NAME="How do I refer to an enum type nested into a parameterized type?"></a><font face="Arial,Helvetica"><font size=+0>How
do I refer to an enum type nested into a generic type?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Using the raw type as the scope qualifier,
instead of the any instantiation of the generic type.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Nested enum types are implicitly static. This is sometimes
confusing because the enum type looks like it were a non-static member
of its enclosing class, while in fact it is static. As a static member
of a generic type it must be referred to using the raw form of the enclosing
type as the scope qualifier.&nbsp; Using an instantiation as the scope
qualifier is illegal and rejected by the compiler.&nbsp;
<p>Example (of a nested enum type):
<blockquote><tt>class <b>Controller<font color="#000099">&lt;E extends
Executor</font></b><font color="#000099">></font> {</tt>
<br><tt>&nbsp; private State state;</tt>
<br><tt>&nbsp; ...&nbsp;</tt>
<br><tt>&nbsp; public <b><font color="#000099">enum</font> State </b>{
VALID, INVALID; }&nbsp;</tt>
<br><tt>&nbsp; public State getState() { return state; }</tt>
<br><tt>}</tt>
<br><tt>class Test</tt>
<br><tt>&nbsp; public static void test(Controller&lt;ThreadPoolExecutor>
c) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; <b>Controller&lt;ExecutorService> </b>controller&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = new Controller&lt;ExecutorService>(Executors.newCachedThreadPool());</tt>
<br><tt>&nbsp;&nbsp;&nbsp; <b>Controller.State</b> state = controller.getState();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; switch (state)) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case INVALID: ... ;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case VALID:&nbsp;&nbsp; ... ;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
The enum type&nbsp; <tt>State </tt>is nested into the generic <tt>Controller</tt>
class.&nbsp; The compiler does not allow that we refer to the nested interface
using any instantiation of the enclosing generic class as the scope qualifier.&nbsp;
Instead of saying <tt>Controller&lt;ExecutorService>.State
</tt>we must
say <tt>Controller.State</tt>. The same applies to the enum constants;
they are referred to as <tt>Controller.State.VALID </tt>and <tt>Controller.State.INVALID</tt>.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ354">#FAQ354</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#How do I refer to static members of a parameterized type?">How
do I refer to static members of a paramterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Can I import a particular instantiation of parameterized type?">Can
I import a particular parameterized type?</a></font></font></td>
</tr>
</table>
<a href="#Can I import a particular instantiation of parameterized type?"><img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350></a><a NAME="FAQ355"></a>
<h2>
<a NAME="Can I import a particular instantiation of parameterized type?"></a><font face="Arial,Helvetica"><font size=+0>Can
I import a particular parameterized type?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>No.&nbsp;</i></b></td>
</tr>

<tr>
<td COLSPAN="2">In an <tt>import</tt> statement we must not use parameterized
types; only raw types are permitted.&nbsp; This applies to regular and
<tt>static import </tt>statements.
<p>Example (of a generic type with static members):
<blockquote><tt>package com.sap.util;</tt>
<p><tt>public final class <b>Counted<font color="#000099">&lt;T></font></b>
{</tt>
<br><tt>&nbsp; public&nbsp; <b>static</b> final int MAX = 1024;</tt>
<br><tt>&nbsp; public&nbsp; <b>static</b> class BeyondThresholdException
extends Exception {}</tt>
<p><tt>&nbsp; private <b>static</b> int count;</tt>
<br><tt>&nbsp; public&nbsp; <b>static</b> int getCount() { return count;
}</tt>
<p><tt>&nbsp; private final T value;</tt>
<br><tt>&nbsp; public Counted(T arg) throws BeyondThresholdException {&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; value = arg;&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; count++;&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if (count >= 1024)&nbsp; throw new BeyondThresholdException();</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; public void finalize() { count--; }</tt>
<br><tt>&nbsp; public T getValue() { return value; }</tt>
<br><tt>}</tt>
<br>
<hr WIDTH="100%">
<br><tt>import com.sap.util.<b>*</b>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b><font color="#003300">// ok</font></b></tt>
<br><tt>import com.sap.util.<b>Counted</b>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b><font color="#003300">// ok</font></b></tt>
<br><tt>import com.sap.util.<b>Counted<font color="#330000">&lt;String></font></b>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b><font color="#330000">// error</font></b></tt>
<p><tt>import static com.sap.<b>Counted</b>.<b>*</b>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b><font color="#003300">// ok</font></b></tt>
<br><tt>import static com.sap.<b>Counted<font color="#330000">&lt;String></font></b>.<b>*</b>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b><font color="#330000">// error</font></b></tt>
<br><tt>import static cam.sap.<b>Counted</b>.BeyondThresholdException;
<b><font color="#003300">//
ok</font></b></tt>
<br><tt>import static com.sap.<b>Counted<font color="#330000">&lt;String></font></b>.BeyondThresholdException;
<b><font color="#330000">//
error</font></b></tt></blockquote>
</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ355">#FAQ355</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#How do I refer to static members of a parameterized type?">How
do I refer to static members of a parameterized type?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ356"></a>
<h2>
<a NAME="Why are parameterized enum types illegal?"></a><font face="Arial,Helvetica"><font size=+0>Why
are generic enum types illegal?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Because they do not make sense in Java.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">An enum type is similar to a class type of which only a
limited number of instances, namely the enum values, exist. The enum values
are static fields of the enum type. The key question is: of which type
would the static enum values be if the enum type were allowed to be parameterized?&nbsp;
<p>Example (of an illegal generic enum type):
<blockquote><tt>public enum Tag&lt;T> {&nbsp; // illegal, but assume we
could do this</tt>
<br><tt>&nbsp; good, bad;</tt>
<p><tt>&nbsp; private T attribute;</tt>
<br><tt>&nbsp; public void setAttribute(T arg) { attribute = arg; }</tt>
<br><tt>&nbsp; public T getAttribute() { return attribute; }</tt>
<br><tt>}</tt></blockquote>
This enum type would be translated to a class that roughly looks like this:
<blockquote><tt>public class Tag&lt;T> extends Enum&lt;Tag&lt;T>> {</tt>
<br><tt>&nbsp; public static final Tag&lt;<i><font color="#CC0000">???</font></i>>
good;</tt>
<br><tt>&nbsp; public static final Tag&lt;<i><font color="#CC0000">???</font></i>>
bad;</tt>
<br><tt>&nbsp; private static final Tag $VALUES[];</tt>
<br><tt>&nbsp; private T attribute;</tt>
<p><tt>&nbsp; private Tag(String s, int i) { super(s, i); }</tt>
<p><tt>&nbsp; static {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; good&nbsp;&nbsp; = new Tag("good", 0);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; bad&nbsp;&nbsp;&nbsp; = new Tag("bad" , 1);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; $VALUES = (new Tag[] { good, bad });</tt>
<br><tt>&nbsp; }</tt>
<p><tt>&nbsp; public void setAttribute(T arg) { attribute = arg; }</tt>
<br><tt>&nbsp; public T getAttribute() { return attribute; }</tt>
<br><tt>}</tt></blockquote>
The static enum values cannot be of type
<tt>Tag&lt;T></tt> because type
parameters such a <tt>T</tt> must not appear in any static context. Should
they be of the raw type <tt>Tag</tt> then?&nbsp; In this case the private
<tt>attribute</tt>
field would be of type <tt>Object,
</tt>the invocation of the <tt>setAttribute</tt>
method would be flagged an "unchecked call" and the <tt>getAttribute</tt>
method would only return
<tt>Object</tt>. The entire parameterization would
be pointless then.
<p>On the other hand, if we wanted that the type of the enum values is
a particular instantiation of the generic enum type, how would we tell
the compiler?&nbsp; There is no syntax for specifying the type of an enum
value.
<p>Also, when we refer to the enum values we must qualify their name by
the name of their defining class, that is, <tt>Tag.good</tt> and <tt>Tag.bad</tt>.&nbsp;
Although <tt>Tag</tt> is a parameterized type, we cannot say <tt>Tag&lt;String>.good</tt>
or <tt>Tag&lt;Long>.bad</tt>.&nbsp; This is because static members of a
generic type must be referred to via the raw type name.&nbsp; In other
words, we would not even be capable of expressing that we intend to refer
to an enum value belonging to a particular instantiation of the generic
enum type.
<p>No matter how we put it: generic enum types do not make sense.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ356">#FAQ356</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="TypeParameters.html#Why can't I use a type parameter in any static context of the parameterized class?">Why
can't I use a type parameter in any static context of the generic class?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#How do I refer to static members of a parameterized type?">How
do I refer to static members of a parameterized type?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350>
<br>&nbsp;
<h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450></h3>

<h3>
<a NAME="Type Argument Inference"></a>Type Argument Inference</h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450><a NAME="FAQ401"></a>
<br>&nbsp;
<h2>
<a NAME="What is type argument inference?"></a><font face="Arial,Helvetica"><font size=+0>What
is type argument inference?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>The automatic deduction of the type arguments
of a generic method at compile time.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">A generic method can be invoked in two ways:
<ul>
<li>
<i>Explicit type argument specification</i>.&nbsp; The type arguments are
explicitly specified in a type argument list.</li>

<li>
<i>Automatic type argument inference. </i>The method is invoked like regular
non-generic methods, that is, without specification of the type arguments.&nbsp;
In this case the compiler automatically infers the type arguments from
the invocation context.&nbsp;</li>
</ul>
Example (of automatic type inference):
<blockquote><tt>class <font color="#000000">Collections {</font></tt>
<br><tt><font color="#000000">&nbsp; public static &lt;A extends Comparable&lt;?
super A>> A max (Collection&lt;A> xs) {</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Iterator&lt;A> xi = xs.iterator();</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; A w = xi.</font>next();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while (xi.hasNext()) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A x = xi.next();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (w.compareTo(x) &lt; 0) w = x;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return w;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}&nbsp;</tt>
<br><tt>final class Test {</tt>
<br><tt>&nbsp; public static void main (String[ ] args) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; LinkedList&lt;Long> list = new LinkedList&lt;Long>();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; list.add(0L);&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; list.add(1L);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Long y = <b><font color="#000099">Collections.max(list)</font></b>;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
In this example, the <tt>max</tt> method is invoked like a regular method
and the compiler automatically infers the type argument from the type of
the method argument.&nbsp; In our example the compiler finds that the formal
method parameter is
<tt>Collection&lt;A></tt> and that the actual method
argument is of type <tt>LinkedList&lt;Long></tt>.&nbsp; From this information
the compiler concludes that <tt>A </tt>must be replaced by <tt>Long</tt>,
which yields an applicable <tt>max</tt> method with the signature <tt>Long
max(Collection&lt;Long>)</tt>.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ401">#FAQ401</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedMethods.html#What is a parameterized (or generic) method?">What
is a parameterized or generic method?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#What explicit type argument specification?">What
is explicit type argument specification?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#What happens if a type parameter does appear in the method parameter list?">What
happens if a type parameter does not appear in the method parameter list?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Why doesn't type argument inference fail when I provide inconsistent method">Why
doesn't type argument inference fail when I provide inconsistent method
arguments?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ402"></a>
<p><a NAME="What explicit type argument specification?"></a><b><font face="Arial,Helvetica"><font size=+0>What
is explicit type argument specification?</font></font></b>
<br>&nbsp;
<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Providing a type argument list when the
method is invoked.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">A generic method can be invoked with or without an explicit
type argument specification. If you do not want to rely on the compiler's
automatic type argument inference process you can specify the type arguments
explicitly.
<p>Example (of a generic method and its invocation):
<blockquote><tt>public class Utilities {</tt>
<br><tt>&nbsp; public static &lt;T extends Comparable> T max(T arg1, T
arg2) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return (arg1.compareTo(arg2)>0)?arg1:arg2;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br><tt>public class Test {</tt>
<br><tt>&nbsp; public static void main(String[] args) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; System.out.println(Utilities.<b><font color="#000099">&lt;String>max</font></b>("abc","xyz"));&nbsp;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
The <tt>max</tt> method can be invoked as
<tt>Utilities.&lt;String>max("abc","xyz")</tt>,
where the type argument is explicitly provided, or as <tt>Utilities.max("abc","xyz")</tt>,
in which case the compiler automatically infers the type argument.
<p>The syntax for explicit type argument specification requires that the
type argument list is precedes the method name, like in <tt>Utilities.&lt;String>max</tt>.&nbsp;
Note the difference to parameterized types, where the type argument list
follows the type name, like in <tt>List&lt;String></tt>.
<p>There is a little syntax quirk in the explicit type argument specification:
it is required that the type argument(s) is preceded by either a type (for
a static method like the one in the example), or the object on which the
method is invoked (for a non-static method), or
<tt>super</tt> (in case
that a superclass's method is invoked).&nbsp; This is even required when
methods are invoked in the scope of the same class.&nbsp; In the scope
of the class we usually omit the type or object on which the method is
invoked;&nbsp; we simply say <tt>method() </tt>rather than <tt>this.method()</tt>.&nbsp;
This shorthand is not permitted when a type argument list precedes the
method name. We must not say <tt>&lt;String>method()</tt>, instead we must
say <tt>this.&lt;String>method()</tt>.
<p>Example:
<blockquote><tt>class SomeClass {</tt>
<br><tt>&nbsp; private static &lt;T> void parameterizedClassMethod()&nbsp;&nbsp;&nbsp;
{ ... }</tt>
<br><tt>&nbsp; private static&nbsp;&nbsp;&nbsp;&nbsp; void regularClassMethod()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{ ... }</tt>
<br><tt>&nbsp; private&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;T>
void parameterizedInstanceMethod() { ... }</tt>
<br><tt>&nbsp; private&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
void regularInstanceMethod()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { ...
}</tt>
<p><tt>&nbsp; public void anotherMethod() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp;&nbsp;&nbsp; regularClassMethod();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// fine</tt>
<br><tt>&nbsp;&nbsp;&nbsp; SomeClass.regularClassMethod();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// fine</tt>
<br><tt>&nbsp;&nbsp;&nbsp; regularInstanceMethod();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// fine</tt>
<br><tt>&nbsp;&nbsp;&nbsp; this.regularInstanceMethod();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// fine</tt>
<p><tt>&nbsp;&nbsp;&nbsp; <b>&lt;String></b>parameterizedClassMethod();
<font color="#660000">//
<b>error</b></font></tt>
<br><tt>&nbsp;&nbsp;&nbsp; <b><font color="#000099">SomeClass.</font><font color="#000000">&lt;String></font></b><font color="#000000">parameterizedClassMethod</font>();
// fine</tt>
<br><tt>&nbsp;&nbsp;&nbsp; <b>&lt;String></b>parameterizedMethod(); <font color="#660000">//
<b>error</b></font></tt>
<br><tt>&nbsp;&nbsp;&nbsp; <b><font color="#000099">this.</font><font color="#000000">&lt;String></font></b><font color="#000000">parameterizedMethod</font>();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// fine</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ402">#FAQ402</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedMethods.html#What is a parameterized (or generic) method?">What
is a parameterized or generic method?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedMethods.html#How do I invoke a parameterized method?">How
do I invoke a generic method?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#What is type argument inference?">What
is type argument inference?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ403"></a>
<p><a NAME="What happens if a type parameter does appear in the method parameter list?"></a><b><font face="Arial,Helvetica"><font size=+0>What
happens if a type parameter does not appear in the method parameter list?</font></font></b>
<br>&nbsp;
<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>The compiler tries to infer the type
argument from the calling context.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">If the type parameter does not appear in the types of the
method arguments, then the compiler cannot infer the type arguments by
examining the types of the actual method arguments.&nbsp; If the type parameter
appears in the method's return type, then the compiler takes a look at
the context in which the return value is used.&nbsp; If the method call
appears as the righthand side operand of an assignment, then the compiler
tries to infer the method's type arguments from the static type of the
lefthand side operand of the assignment.
<p>Example (for inference from assignment context):
<blockquote><tt>public final class Utilities {</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>&nbsp; public static &lt;T> <b><font color="#000099">HashSet&lt;T></font></b>
create(int size) {&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return new HashSet&lt;T>(size);&nbsp;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br><tt>public final class Test</tt>
<br><tt>&nbsp; public static void main(String[] args) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; <b><font color="#000099">HashSet&lt;Integer></font></b>
hi = Utilities.create(10);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
The <tt>create</tt> method is generic and the type parameter <tt>T
</tt>does
not appear in the method parameter list; it appears in the method's return
type <tt>HashSet&lt;T> </tt>though.&nbsp; The result of the method is assigned
to a variable of type <tt>HashSet&lt;Integer></tt> so that the compiler
infers that the type argument of the <tt>create</tt> method must be <tt>T:=Integer</tt>.&nbsp;
The compiler is even smart enough to infer the type argument of the <tt>create</tt>
method if the method result is assigned to a variable of a supertype of
<tt>HashSet&lt;Integer></tt>,
such as <tt>Collection&lt;Integer></tt>.
<p>An invocation context other than an assignment is not considered for
type inference.&nbsp; The result of the method call might be passed as
an argument to another method, for instance.&nbsp; The compiler does not
try to perform any special type inference in that case.&nbsp; Instead the
compiler handles the method call as though it would appear in no context.
No context means that the compiler performs the type inference algorithm
as though the method result was assigned to a variable of type <tt>Object</tt>.
<p>Example (for inference from context other than assignment):
<blockquote><tt>public final class Utilities {</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>&nbsp; public static &lt;T> <b><font color="#000099">HashSet&lt;T></font></b>
create(int size) {&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return new HashSet&lt;T>(size);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; public static void print(<b><font color="#000099">HashSet&lt;String></font></b>
h) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for (String s : h) System.out.println(s);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br><tt>public final class Test</tt>
<br><tt>&nbsp; public static void main(String[] args) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; print(Utilities.create(10));</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br>
<hr WIDTH="100%">
<br><tt>error: print(java.util.HashSet&lt;java.lang.String>) cannot be
applied to (java.util.HashSet&lt;java.lang.Object>)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(Utilities.create(10));</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^</tt></blockquote>
The compiler treats the call <tt>print(Utilities.create(10))</tt> like
it were an assignment <tt>Object o = Utilities.create(10))</tt>.&nbsp;
A lefthand side of type <tt>Object</tt> does not provide any particular
type information so that the compiler cannot really infer anything.&nbsp;
If no specific type can be inferred then the compiler chooses <tt>Object</tt>
as the type argument.&nbsp; With type <tt>Object</tt> as the type argument
the <tt>create</tt> method returns a&nbsp; <tt>HashSet&lt;Object></tt>,
which is incompatible to a <tt>HashSet&lt;String></tt> and leads to the
error message displayed above.
<p>If the type argument inference does not lead to the desired result or
if we want to disable the automatic inference, we can explicitly specify
the type arguments.&nbsp;
<p>Example (for explicit type argument specification):
<blockquote><tt>public final class Utilities {</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>&nbsp; public static &lt;T> <b><font color="#000099">HashSet&lt;T></font></b>
create(int size) {&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return new HashSet&lt;T>(size);&nbsp;</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; public static void print(<b><font color="#000099">HashSet&lt;String></font></b>
h) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for (String s : h) System.out.println(s);</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br><tt>public final class Test</tt>
<br><tt>&nbsp; public static void main(String[] args) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; print(Utilities.<b><font color="#000099">&lt;String></font></b>create(10));</tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ403">#FAQ403</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedMethods.html#What is a parameterized (or generic) method?">What
is a parameterized or generic method?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#What is type argument inference?">What
is type argument inference?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#What explicit type argument specification?">What
is explicit type argument specification?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Why doesn't type argument inference fail when I provide inconsistent method">Why
doesn't type argument inference fail when I provide inconsistent method
arguments?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Why do temporary variables matter in case of invocation of parameterized methods?">Why
do temporary variables matter in case of invocation of generic methods?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ404"></a>
<h2>
<a NAME="Why doesn't type argument inference fail when I provide inconsistent method"></a><font face="Arial,Helvetica"><font size=+0>Why
doesn't type argument inference fail when I provide inconsistent method
arguments?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Because the "inconsistent" arguments
might make sense to the compiler.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Occasionally the compiler infers a type where we might
expect that no type can be inferred.
<p>Example (of surprising type argument inference):
<blockquote><tt><nobr>public final class Utilities {</nobr></tt>
<br><tt><nobr>&nbsp; </nobr></tt>
<br><tt><nobr>&nbsp; public static <b><font color="#000099">&lt;T></font></b>
void fill(<b><font color="#000099">T</font></b>[] array, <b><font color="#000099">T</font></b>
elem) {</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp; for (int i=0; i&lt;array.length; ++i)
{ array[i] = elem; }</nobr></tt>
<br><tt><nobr>&nbsp; }</nobr></tt>
<br><tt><nobr>}</nobr></tt>
<p><tt><nobr>public final class Test</nobr></tt>
<br><tt><nobr>&nbsp; public static void main(String[] args) {</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp; Utilities.fill(new <b><font color="#000099">String</font></b>[5],
new <b><font color="#000099">String</font></b>("XYZ"));&nbsp; // T:=String</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp; Utilities.fill(new <b><font color="#000099">String</font></b>[5],
new <b><font color="#000099">Integer</font></b>(100));&nbsp;&nbsp; // T:=Object&amp;Serializable&amp;Comparable</nobr></tt>
<br><tt><nobr>&nbsp; }</nobr></tt>
<br><tt><nobr>}</nobr></tt></blockquote>
This is the example of a method whose type argument appears in several
method arguments.&nbsp; Quite obviously the intent is that the component
type of the array should match the type of the second argument.&nbsp; For
this reason we might expect that a method invocation such as <tt>Utilities.fill<font color="#000000">(new
String[5], new Integer(1</font>00)) </tt>would fail, because the argument
types <tt>String[]</tt> and <tt>Integer</tt> are inconsistent.&nbsp;
<p>However, the compiler does not reject this method call.&nbsp; Instead
it performs type inference and infers the common supertypes of <tt>String</tt>
and <tt>Integer</tt> as type argument.&nbsp; To be precise the compiler
infers&nbsp;
<blockquote><tt><nobr>T := Object &amp; Serializable &amp; Comparable&lt;?
extends Object&amp;Serializable&amp;Comparable&lt;?>></nobr></tt></blockquote>
which is a synthetic type construct used internally by the compiler.&nbsp;&nbsp;
It denotes the set of supertypes of <tt>String</tt> and <tt>Integer</tt>.
<p>Whether the result of this successful type inference is desired or not
depends on the circumstances.&nbsp; In this example the source code compiles,
but the method invocation in question will fail at runtime with an <tt>ArrayStoreException</tt>,
because the method would try to store integers in an array of strings.
<p>We can prevent the perhaps undesired type argument inference by a minor
modification of the <tt>fill</tt> method.
<p>Example (modified):
<blockquote><tt><nobr>public final class Utilities {</nobr></tt>
<br><tt><nobr>&nbsp; </nobr></tt>
<br><tt><nobr>&nbsp; public static &lt;<b><font color="#000099">T</font></b>,
<b><font color="#330033">S
extends T</font></b>> void fill(<b><font color="#000099">T</font></b>[]
array, <b><font color="#330033">S</font></b> elem) {&nbsp;</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp; for (int i=0; i&lt;array.length; ++i)
{ array[i] = elem; }</nobr></tt>
<br><tt><nobr>&nbsp; }</nobr></tt>
<br><tt><nobr>}</nobr></tt>
<p><tt><nobr>public final class Test</nobr></tt>
<br><tt><nobr>&nbsp; public static void main(String[] args) {</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp; Utilities.fill(new <b><font color="#000099">String</font></b>[5],
new <b><font color="#000099">String</font></b>("XYZ"));&nbsp; // T:=String
</nobr></tt><nobr>and<tt>
S:= String</tt></nobr>
<br><tt><nobr>&nbsp;&nbsp;&nbsp; Utilities.fill(new <b><font color="#000099">String</font></b>[5],
new
<b><font color="#000099">Integer</font></b>(100));&nbsp;&nbsp; // T:=String
</nobr></tt><nobr>and<tt>
S:= Integer&nbsp; => error!!!</tt></nobr>
<br><tt><nobr>&nbsp; }</nobr></tt>
<br><tt><nobr>}</nobr></tt></blockquote>
The compiler now infers both type arguments separately as <tt>String</tt>
and <tt><nobr>Integer</nobr></tt>. When it checks the bounds it finds that
<tt><nobr>S</nobr></tt>
is not within bounds because <tt><nobr>Integer</nobr></tt> is not a subtype
of <tt>String</tt> and the call is rejected.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ404">#FAQ404</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedMethods.html#What is a parameterized (or generic) method?">What
is a parameterized or generic method?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#What is type argument inference?">What
is type argument inference?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#What explicit type argument specification?">What
is explicit type argument specification?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#What happens if a type parameter does appear in the method parameter list?">What
happens if a type parameter does not appear in the method parameter list?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Why do temporary variables matter in case of invocation of parameterized methods?">Why
do temporary variables matter in case of invocation of generic methods?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ405"></a>
<h2>
<a NAME="Why do temporary variables matter in case of invocation of parameterized methods?"></a><font face="Arial,Helvetica"><font size=+0>Why
do temporary variables matter in case of invocation of generic methods?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Because of the automatic type argument
inference.</i></b></td>
</tr>

<tr>
<td COLSPAN="2"><font size=+0>Usually, it does not make a difference whether
we pass the result of a method call directly as argument to the next method,
like in&nbsp;</font>
<blockquote><tt><font size=+0>g(f(x));</font></tt></blockquote>
<font size=+0>or whether we store the result first in a temporary variable
and then pass the temporary variable to the next method, like in&nbsp;</font>
<blockquote><tt><font size=+0>tmp=f(x);&nbsp;</font></tt>
<br><tt><font size=+0>g(tmp);</font></tt></blockquote>
<font size=+0>The effect is usually the same.&nbsp; However, when the methods
are generic methods, it may well make a difference.</font>
<p><font size=+0>Example:</font>
<blockquote><tt><nobr>public final class Utilities {</nobr></tt>
<br><tt><nobr>&nbsp; </nobr></tt>
<br><tt><nobr>&nbsp; public static &lt;T> HashSet&lt;T> create(int size)
{</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp; return new HashSet&lt;T>(size);&nbsp;</nobr></tt>
<br><tt><nobr>&nbsp; }</nobr></tt>
<br><tt><nobr>&nbsp; public static &lt;T> T choose(boolean first, T arg1,
T arg2) {</nobr></tt>
<br><tt><nobr>&nbsp;&nbsp;&nbsp; return (first) ? arg1: arg2;</nobr></tt>
<br><tt><nobr>&nbsp; }</nobr></tt>
<br><tt><nobr>}</nobr></tt></blockquote>
<font size=+0>Let us consider a nested method call where the result of
the <tt>choose</tt> method is passed as argument to the <tt>create</tt>
method.&nbsp; We can perform the nested method call in two steps using
a temporary variable:</font>
<blockquote><tt><nobr>HashSet&lt;Integer> <b><font color="#003300">tmp</font></b>
= <b><font color="#000099">Utilities.create</font></b>(5);</nobr></tt>
<br><tt><nobr>HashSet&lt;Integer> c&nbsp;&nbsp; = <b><font color="#000099">Utilities.choose</font></b>(false,new
HashSet&lt;Integer>(10),<b><font color="#003300">tmp</font></b>);</nobr></tt></blockquote>
<font size=+0>Or we can perform it one step:</font>
<blockquote><tt><nobr>HashSet&lt;Integer> c = <b><font color="#000099">Utilities.choose</font></b>(false,new
HashSet&lt;Integer>(10),<b><font color="#000099">Utilities.create</font></b>(5));&nbsp;</nobr></tt></blockquote>
<font size=+0>If the methods were non-generic methods the result of both
invocation techniques would be the same. Not so in our example, where both
methods are generic and the compiler automatically infers the type arguments
from the calling context.&nbsp; Obviously, the calling context is different.&nbsp;</font>
<p><font size=+0>In the two-step invocation the result of the <tt>choose</tt>
method appears in an assignment, and assignment is a context that the compiler
considers for type inference. In the one-step invocation the result of
the <tt>choose</tt> method is passed as an argument to another method,
and method invocation is not considered for type inference.&nbsp;</font>
<p><font size=+0>Here is what the compiler infers for the two-step call:</font>
<blockquote><tt><nobr>HashSet&lt;Integer> <b><font color="#003300">tmp</font></b>
= <b><font color="#000099">Utilities.create</font></b>(5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// T:=Integer</nobr></tt>
<br><tt><nobr>HashSet&lt;Integer> c&nbsp;&nbsp; = <b><font color="#000099">Utilities.choose</font></b>(false,new
HashSet&lt;Integer>(10),<b><font color="#003300">tmp</font></b>);&nbsp;
// T:=Integer</nobr></tt></blockquote>
<font size=+0>For inference of the type argument of the <tt>create</tt>
method the compiler takes a look at the type of the lefthand side of the
assignement, namely the type of the temporary variable.&nbsp; It is of
type <tt>HashSet&lt;Integer></tt> and the compiler infers <tt>T:=Integer</tt>.</font>
<br><font size=+0>For the invocation of the <tt>choose</tt> method the
compiler looks at both method arguments.&nbsp; They are both of type <tt>HashSet&lt;Integer>
</tt>and
therefore the compiler infers that <tt>T:=Integer</tt>.</font>
<p><font size=+0>The one-step call, in contrast, does not compile because
the type argument inference works differently in this case:</font>
<blockquote><tt>HashSet&lt;Integer> c = <b><font color="#000099">Utilities.choose</font></b>(false,new
HashSet&lt;Integer>(10),<b><font color="#000099">Utilities.create</font></b>(5));<font size=+0>&nbsp;
// error</font></tt></blockquote>
<font size=+0>For inference of the type argument of the <tt>create</tt>
method the compiler does not consider any context information, because
it does not appear in an assignment.&nbsp; It treats the invocation of
<tt>create</tt>
as though the result of <tt>create</tt> were assigned to a variable of
type <tt>Object</tt>, which does not provide any type information to deduce
anything from.&nbsp; For this reason the compiler infers <tt>T:=Object</tt>,
which yields an instantiation of the <tt>create</tt> method with the signature
<tt>HashSet&lt;Object>
create()</tt>.</font>
<br><font size=+0>Equipped with this information the compiler tries to
infer the type argument of the <tt>choose</tt> method. The two method arguments
are of type <tt>HashSet&lt;Integer></tt> and <tt>HashSet&lt;Object></tt>
and the compiler infers <tt>T:=?</tt>, which yields an instantiation of
the <tt>choose</tt> method with the signature <tt>HashSet&lt;?> choose(boolean,HashSet&lt;?>,HashSet&lt;?>)</tt>.&nbsp;
The instantiation is applicable as far as the argument types are concerned,
but it returns a result of&nbsp; type <tt>HashSet&lt;?></tt>, which is
incompatible with <tt>HashSet&lt;Integer></tt> and the compiler issues
an error message.</font>
<p><font size=+0>The example demonstrates, that in rare cases there can
be a difference between a one-step nested method call such as <tt>g(f(x));</tt>
and a two-step call using a temporary variable such as <tt>tmp=f(x); g(tmp);</tt>.
The difference stems from the fact that an assignment context is considered
for the type argument inference, while other situations are not.</font>
<br>&nbsp;</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ405">#FAQ405</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedMethods.html#What is a parameterized (or generic) method?">What
is a parameterized or generic)method?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#What is type argument inference?">What
is type argument inference?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#What explicit type argument specification?">What
is explicit type argument specification?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#What happens if a type parameter does appear in the method parameter list?">What
happens if a type parameter does not appear in the method parameter list?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Why doesn't type argument inference fail when I provide inconsistent method">Why
doesn't type argument inference fail when I provide inconsistent method
arguments?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350>
<br>&nbsp;
<br>&nbsp;
<h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450></h3>

<h3>
<a NAME="Wildcard Capture"></a>Wildcard Capture</h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450><a NAME="FAQ501"></a>
<h2>
<a NAME="What is the capture of a wildcard?"></a><b><font face="Arial,Helvetica"><font size=+0>What
is the capture of a wildcard?</font></font></b></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>An anonymous type variable that represents
the particular unknown type that the wildcard stands for.&nbsp; The compiler
uses the capture internally for evaluation of expressions and the term
"capture of ?" occasionally shows up in error message.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">A wildcard is compatible with all types from a set of types.
For instance, all instantiations of the generic type
<tt>List</tt>, such
as <tt>List&lt;String></tt>, <tt>List&lt;Number></tt>,
<tt>List&lt;Long></tt>,
etc. can be assigned to a reference variable of type <tt>List&lt;?></tt>.&nbsp;
Wildcards are typically used as argument or return types in method signatures.
The goal and effect is that the method accepts arguments of a larger set
of types, namely all types that belong to the type family that the wildcard
denotes.
<p>Example (of a wildcard in a method signature):
<blockquote><tt>public static List&lt;?> reverse(List&lt;?> list) {</tt>
<br><tt>&nbsp; // ...&nbsp; the implementation ...</tt>
<br><tt>}</tt></blockquote>
The <tt>reverse</tt> method accepts arguments that are of a type that is
an instantiation of the generic type <tt>List</tt>. In order to use the
type argument <tt>list</tt> of type <tt>List&lt;?></tt> the compiler converts
the wildcard instantiation to the so-called <i>capture</i> of the wildcard.
The capture represents the particular albeit unknown type of the argument
that is actually passed the method.&nbsp; This particular unknown type
is, of course, a member of the type family that the wildcard denotes.&nbsp;
<p>The wildcard capture can be imagined as an anonymous type variable that
the compiler generates internally and uses as the static type of the method
parameter.&nbsp; A type variable is like a type parameter of a generic
type or method; it stands for a particular unknown type. Changing the method
parameter's type from the instantiation using a wildcard to an instantiation
using the capture is known as <i>capture conversion</i>. The translation
of our method can be imagined as though the compiler had re-implemented
the method to use a synthetic generic method that has the wildcard capture
as it type parameter.
<p>Example (pseudo code showing the wildcard capture):
<blockquote><b><tt><font color="#330033">private static &lt;T_?001> List&lt;T_?001>
reverse_?001(List&lt;T_?001> list) {</font></tt></b>
<br><tt><b><font color="#330033">&nbsp; </font></b>// ...&nbsp; the implementation
...</tt>
<br><b><tt><font color="#330033">}</font></tt></b>
<br><tt>public static List&lt;?> reverse(List&lt;?> list) {</tt>
<br><tt>&nbsp; <b><font color="#330033">return reverse_?001(list);</font></b></tt>
<br><tt>}</tt></blockquote>
For the analysis and translation of the implementation of the <tt>reverse</tt>
method the compiler will use <tt>List&lt;T_?001></tt> as the type of the
method parameter. The synthetic type variable <tt>T_?001</tt> is used for
all purposes where the method parameter's static type information is needed,
like for instance, in type checks and for type inference.
<p>For illustration, let us consider a conceivable implementation of the
<tt>reverse
</tt>method
using a generic helper method <tt>rev</tt> for which the compiler must
infer the type arguments from the wildcard.
<p>Example (implementation of the <tt>reverse</tt> method):
<blockquote><tt>private static &lt;T> List&lt;T> rev(List&lt;T> list) {</tt>
<br><tt>&nbsp; List&lt;T> tmp = new ArrayList&lt;T>(list);</tt>
<br><tt>&nbsp; for (int i=0;i&lt;list.size();i++){</tt>
<br><tt>&nbsp;&nbsp;&nbsp; tmp.set(i,list.get(list.size()-i-1));</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; return tmp;</tt>
<br><tt>}</tt>
<br><tt>public static List&lt;?> reverse(List&lt;?> list) {</tt>
<br><tt>&nbsp; return rev(list);</tt>
<br><tt>}</tt></blockquote>
The compiler applies capture conversion and generates an anonymous type
variable. In principle, the compiler translates the <tt>reverse</tt> method
to something like this.
<p>Example (pseudo code showing the wildcard capture):
<blockquote><tt>private static &lt;T> List&lt;T> rev(List&lt;T> list) {</tt>
<br><tt>&nbsp; List&lt;T> tmp = new ArrayList&lt;T>(list);</tt>
<br><tt>&nbsp; for (int i=0;i&lt;list.size();i++){</tt>
<br><tt>&nbsp;&nbsp;&nbsp; tmp.set(i,list.get(list.size()-i-1));</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; return tmp;</tt>
<br><tt>}</tt>
<br><b><tt><font color="#330033">private static &lt;T_?001> List&lt;T_?001>
reverse_?001(List&lt;T_?001> list) {</font></tt></b>
<br><tt><b><font color="#330033">&nbsp; </font></b>return rev(list);</tt>
<br><b><tt><font color="#330033">}</font></tt></b>
<br><tt>public static List&lt;?> reverse(List&lt;?> list) {</tt>
<br><tt>&nbsp; <b><font color="#330033">return reverse_?001(list);</font></b></tt>
<br><tt>}</tt></blockquote>
Among other things, the compiler uses the wildcard capture <tt>T_?001</tt>
for&nbsp; inference of the type argument <tt>T</tt> of the generic helper
method
<tt>rev</tt>. It infers <tt>T:=T_?001</tt> and therefore invokes
the instantiation <tt>&lt;T_?001>rev</tt> of method <tt>rev</tt>.&nbsp;
The result returned from the helper method <tt>rev</tt> is of type <tt>List&lt;T_?001></tt>,
so that the result of the <tt>reverse</tt> method is of type <tt>List&lt;T_?001></tt>,
too.&nbsp; This becomes visible in error messages, should the compiler
issue any.
<p>Example (of invocation of the <tt>reverse</tt> method):
<blockquote><tt>List&lt;?> list = new ArrayList&lt;String>();</tt>
<br><tt>...</tt>
<br><tt>List&lt;String>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ll0 = reverse(list);&nbsp; // error&nbsp;</tt>
<br><tt>List&lt;?>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ll1 = reverse(list);</tt>
<br>
<hr WIDTH="100%">
<br><tt>error: incompatible types</tt>
<br><tt>found&nbsp;&nbsp; : java.util.List&lt;<b><font color="#000099">capture
of ?</font></b>></tt>
<br><tt>required: java.util.List&lt;java.lang.String></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List&lt;String>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ll0 = reverse(list);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt></blockquote>
What the compiler refers to as "capture of ?" in the error method is the
anonymous type variable that we named <tt>T_?001</tt> for sake of illustration
in the examples above.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ501">#FAQ501</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#What is a wildcard capture assignment-compatible to?">What
is a wildcard capture assignment-compatible to?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ502"></a>
<h2>
<a NAME="What is a wildcard capture assignment-compatible to?"></a><font face="Arial,Helvetica"><font size=+0>What
is a wildcard capture assignment-compatible to?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>A captured instantiation can only be
assigned to another wildcard instantiation.&nbsp;</i></b></td>
</tr>

<tr>
<td COLSPAN="2">The capture of a wildcard is compatible to a corresponding
wildcard, never to a concrete type.
<p>Example (implementation of method with wildcards in the argument and
return type):
<blockquote><tt>private static &lt;T> List&lt;T> rev(List&lt;T> list) {</tt>
<br><tt>&nbsp; List&lt;T> tmp = new ArrayList&lt;T>(list);</tt>
<br><tt>&nbsp; for (int i=0;i&lt;list.size();i++){</tt>
<br><tt>&nbsp;&nbsp;&nbsp; tmp.set(i,list.get(list.size()-i-1));</tt>
<br><tt>&nbsp; }</tt>
<br><tt>&nbsp; return tmp;</tt>
<br><tt>}</tt>
<br><tt>public static List&lt;?> reverse(List&lt;?> list) {</tt>
<br><tt>&nbsp; return rev(list);</tt>
<br><tt>}</tt></blockquote>
Example (of invocation of the <tt>reverse</tt> method):
<blockquote><tt>List&lt;?> list = new ArrayList&lt;String>();</tt>
<br><tt>...</tt>
<br><tt>List&lt;String>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ll0 = reverse(list);&nbsp; // error&nbsp;</tt>
<br><tt>List&lt;?>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ll1 = reverse(list);&nbsp;</tt>
<br>
<hr WIDTH="100%">
<br><tt>error: incompatible types</tt>
<br><tt>found&nbsp;&nbsp; : java.util.List&lt;<b><font color="#000099">capture
of ?</font></b>></tt>
<br><tt>required: java.util.List&lt;java.lang.String></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List&lt;String>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ll0 = reverse(list);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt></blockquote>
The <tt>reverse</tt> method returns a result of type <tt>List&lt;capture
of ?></tt>. The wildcard capture denotes a particular unknown type.&nbsp;
From the static type information "capture of ?" the compiler cannot tell,
whether capture stands for <tt>String</tt>; the capture could stand for
any type.&nbsp; On this ground the compiler rejects the assignment of the
method result of type <tt>List&lt;capture of ?> </tt>to the variable of
type <tt>List&lt;String></tt> in the example.&nbsp;
<p>The return type of the <tt>reverse</tt> method remains type <tt>List&lt;capture
of ?></tt> even if we pass an argument of type <tt>List&lt;String> </tt>to
the method.
<p>Example (of invocation of the <tt>reverse</tt> method):
<blockquote><tt>List&lt;<b><font color="#000099">String</font></b>> list
= new ArrayList&lt;String>();</tt>
<br><tt>...</tt>
<br><tt>List&lt;String>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ll0 = reverse(list);&nbsp; // error&nbsp;</tt>
<br><tt>List&lt;?>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ll1 = reverse(list);&nbsp;</tt>
<br>
<hr WIDTH="100%">
<br><tt>error: incompatible types</tt>
<br><tt>found&nbsp;&nbsp; : java.util.List&lt;<b><font color="#000099">capture
of ?</font></b>></tt>
<br><tt>required: java.util.List&lt;java.lang.String></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List&lt;String>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ll0 = reverse(list);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt></blockquote>
The compiler performs the capture conversion when it translates the <tt>reverse</tt>
method and the computation of the return type as&nbsp; <tt>List&lt;capture
of ?> </tt>is based on the type declared for the method parameter, not
based on the static type of any arguments passed to the method in any particular
invocation context.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ502">#FAQ502</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#What is the capture of a wildcard?">What
is the capture of a wildcard?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="Fundamentals.html#What does type-safety mean?">What
does type-safety mean?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ503"></a>
<h2>
<a NAME="Is the capture of a bounded wildcard compatible to the bound?"></a><font face="Arial,Helvetica"><font size=+0>Is
the capture of a bounded wildcard compatible to the bound?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>No, not even if the bound is a final
class.&nbsp;</i></b></td>
</tr>

<tr>
<td COLSPAN="2">The capture of a wildcard is compatible to a corresponding
wildcard, never to a concrete type. Correspondingly, the capture of a bounded
wildcard is compatible solely to other wildcards, but never to the bound.
<p>For illustration we use the <tt>getClass</tt> method, which is defined
in class <tt>Object</tt> (see <tt><a href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#getClass()">java.lang.Object.getClass</a></tt>).
The result of the <tt>getClass</tt> method is of type <tt>Class&lt;? extends
X></tt>, where <tt>X</tt> is the erasure of the static type of the expression
on which <tt>getClass</tt> is called.&nbsp;
<p>Example (with bounded wildcard):
<blockquote><tt>Number n = new Integer(5);</tt>
<br><tt>Class&lt;Number> c = n.getClass();&nbsp; // error</tt>
<br>
<hr WIDTH="100%">
<br><tt>error: incompatible types</tt>
<br><tt>found&nbsp;&nbsp; : java.lang.Class&lt;capture of ? extends java.lang.Number></tt>
<br><tt>required: java.lang.Class&lt;java.lang.Integer></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class&lt;Number> c =
n.getClass();&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt></blockquote>
In our example the static type of the expression on which <tt>getClass</tt>
is called is <tt>Number</tt>.&nbsp; Hence the return value is of type <tt>Class&lt;capture
of ? extends Number></tt>. A variable of type <tt>Class&lt;capture of ?
extends Number></tt> can refer to a <tt>Class&lt;Number></tt>, a <tt>Class&lt;Long></tt>,
a <tt>Class&lt;Integer></tt>, etc.&nbsp;&nbsp; There's no guarantee that
is actually refers to a <tt>Class&lt;Number></tt>, and indeed, in our example
it refers to a <tt>Class&lt;Integer></tt>. The compiler rightly complains.&nbsp;
How do we fix it?
<p>Example (corrected):
<blockquote><tt>Number n = new Integer(5);</tt>
<br><tt>Class&lt;?>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
c1 = n.getClass();&nbsp;</tt>
<br><tt>Class&lt;? extends Number> c2 = n.getClass();</tt></blockquote>
Since <tt>getClass</tt> returns a wildcard instantiation we must assign
the result to a wildcard instantiation.&nbsp; <tt>Class&lt;?></tt> would
be correct, but also the more specific type <tt>Class&lt;? extends Number></tt>would
work.
<p>Interestingly, the capture of a bounded wildcard, whose upper bound
is a final class, is still incompatible to the bounds type, although the
set of types that the bounded wildcard denotes contains only one type,
namely the bounds type itself.
<p>Example (using final class as bound):
<blockquote><tt>String s = new String("abc");</tt>
<br><tt>Class&lt;String>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
c0 = s.getClass();&nbsp; // error</tt>
<br><tt>Class&lt;?>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
c1 = s.getClass();&nbsp; // fine</tt>
<br><tt>Class&lt;? extends String> c2 = s.getClass();&nbsp; // fine</tt>
<br>
<hr WIDTH="100%">
<br><tt>error: incompatible types</tt>
<br><tt>found&nbsp;&nbsp; : java.lang.Class&lt;capture of ? extends java.lang.String></tt>
<br><tt>required: java.lang.Class&lt;java.lang.String></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class&lt;String>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
c0 = s.getClass();&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt></blockquote>
</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ503">#FAQ503</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#What is the capture of a wildcard?">What
is the capture of a wildcard?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#What is a wildcard capture assignment-compatible to?">What
is a wildcard capture assignment-compatible to?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350>
<br>&nbsp;
<br>&nbsp;
<h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450></h3>

<h3>
<a NAME="Wildcard Instantiations"></a>Wildcard Instantiations</h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450><a NAME="FAQ601"></a>
<h2>
<a NAME="Which methods and fields are accessible/inaccessible through a reference variable of a wildcard type?"></a><font face="Arial,Helvetica"><font size=+0>Which
methods and fields are accessible/inaccessible through a reference variable
of a wildcard type?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i><font size=+0>It depends on the kind
of wildcard.</font></i></b></td>
</tr>

<tr>
<td COLSPAN="2">Using an object through a reference variable of a wildcard
parameterized type is restricted. Consider the following class:
<p>Example ( of a parameterized class):
<blockquote><tt>class Box&lt;T> {</tt>
<br><tt>&nbsp; private T t;</tt>
<br><tt>&nbsp; public Box(T t) { this.t = t; }</tt>
<br><tt>&nbsp; public void put(T t) { this.t = t;}</tt>
<br><tt>&nbsp; public T take() { return t; }</tt>
<br><tt>&nbsp; public boolean equalTo(Box&lt;T> other) { return this.t.equals(other.t);
}</tt>
<br><tt>&nbsp; public Box&lt;T> copy() { return new Box&lt;T>(t); }</tt>
<br><tt>}</tt></blockquote>
In a wildcard parameterized type such as <tt>Box&lt;?></tt> the type of
the field and the argument and the return types of the methods would be
unknown.&nbsp; It is like the field t would be of type "<tt>?</tt>" and
the <tt>put</tt> method would take an argument of type "<tt>?</tt>" and
so on.&nbsp; In this situation the compiler does not let us assign anything
to the field or pass anything to the <tt>put</tt> method. The reason is
that the compiler cannot make sure that the object that we are trying to
assign to the field or pass as an argument to a method is of the expected
type, since the expected type is unknown.&nbsp; Similar effects can be
observed for methods such as like <tt>equalTo</tt> and <tt>clone</tt>,
which&nbsp; have a parameterized argument or return type and the type parameter
<tt>T</tt> appears as type argument of the parameterized argument or return
type.&nbsp;
<p>Below is a table that lists which uses of fields and methods are legal
or illegal. It assumes a class like this:
<blockquote><tt>class X&lt;<b>T</b>> {</tt>
<br><tt>&nbsp; private <b>T</b> t;</tt>
<p><tt>&nbsp; public&nbsp; <b>T</b>&nbsp;&nbsp;&nbsp; m()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{ ... }</tt>
<br><tt>&nbsp; public&nbsp; void m(<b>T</b> arg)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{ ... }</tt>
<p><tt>&nbsp; public&nbsp; Y&lt;<b>T</b>> f()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{ ... }</tt>
<br><tt>&nbsp; public&nbsp; void f(Y&lt;<b>T</b>> arg)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{ ... }</tt>
<p><tt>&nbsp; public&nbsp; Y&lt;? extends <b>T</b>> f()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{ ... }</tt>
<br><tt>&nbsp; public&nbsp; void f(Y&lt;? extends <b>T</b>> arg) { ...
}</tt>
<p><tt>&nbsp; public&nbsp; Y&lt;? super <b>T</b>> f()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{ ... }</tt>
<br><tt>&nbsp; public&nbsp; void f(Y&lt;? super <b>T</b>> arg)&nbsp;&nbsp;
{ ... }</tt>
<br><tt>}</tt></blockquote>
Examples and further explanations can be found in subsequent FAQ entries.
<br>&nbsp;
<table BORDER=0 CELLSPACING=3 CELLPADDING=3 WIDTH="100%" BGCOLOR="#F4F4FF" >
<tr VALIGN=TOP BGCOLOR="#C6CCDD">
<td BGCOLOR="#C6CCDD"><b><nobr><font face="Arial,Helvetica">X&lt;?></font></nobr></b></td>

<td COLSPAN="4"><b><font color="#000000">unbounded wildcard</font></b></td>
</tr>

<tr VALIGN=TOP BGCOLOR="#EDEFF3">
<td></td>

<td COLSPAN="2"><b>legal</b></td>

<td COLSPAN="2"><b>illegal</b></td>
</tr>

<tr VALIGN=TOP>
<td VALIGN=TOP BGCOLOR="#EDEFF3"><b>fields</b></td>

<td><b><nobr><font face="Arial,Helvetica"><font color="#000000">x = </font><font color="#3333FF">t</font></font></nobr></b></td>

<td>We can <u>read</u> a field whose type is the type parameter.
<br>The field is accessible through a reference of type <tt>Object</tt>.</td>

<td><b><font face="Arial,Helvetica"><nobr><font color="#3333FF">t</font></nobr><font color="#000000">
= x</font></font></b></td>

<td>We cannot <u>assign</u> to a field whose type is the type parameter
<br>except: <tt>null</tt></td>
</tr>

<tr VALIGN=TOP>
<td VALIGN=TOP ROWSPAN="3" BGCOLOR="#EDEFF3"><b>methods</b></td>

<td><b><nobr><font face="Arial,Helvetica"><font color="#3333FF">T</font><font color="#000000">m()</font></font></nobr></b></td>

<td>We can call methods that use the type parameter as the <u>return type</u>.
<br>The returned value is accessible through a reference of type <tt>Object</tt>.</td>

<td><b><nobr><font face="Arial,Helvetica">void m(<font color="#3333FF">T</font>)</font></nobr></b></td>

<td>We cannot call methods that use the type parameter as an <u>argument
type</u>.
<br>except: <tt>null</tt></td>
</tr>

<tr VALIGN=TOP>
<td><b><nobr><font face="Arial,Helvetica"><font color="#000000">Y&lt;</font><font color="#3333FF">T</font><font color="#000000">>
f()</font></font></nobr></b>
<br><b><nobr><font face="Arial,Helvetica"><font color="#000000">Y&lt;?
extends </font><font color="#3333FF">T</font><font color="#000000">> f()</font></font></nobr></b>
<br><b><nobr><font face="Arial,Helvetica"><font color="#000000">Y&lt;?
super </font><font color="#3333FF">T</font><font color="#000000">> f()</font></font></nobr></b></td>

<td>We can call methods that use the type parameter as <u>type argument</u>
in the return type or as an <u>upper</u> or <u>lower wildcard bound</u>
in the <u>return type</u>.
<br>The returned value is accessible through the unbounded wildcard instantiation
of the return type (i.e. <tt>Y&lt;?></tt>).</td>

<td><b><nobr><font face="Arial,Helvetica">void f(<font color="#000000">Y&lt;</font><font color="#3333FF">T</font><font color="#000000">></font>)</font></nobr></b>
<br><b><nobr><font face="Arial,Helvetica">void f(<font color="#000000">Y&lt;?
extends </font><font color="#3333FF">T</font><font color="#000000">></font>)</font></nobr></b></td>

<td>We cannot call methods that use the type parameter as <u>type argument</u>
in an argument type or as an <u>upper wildcard bound</u>&nbsp; in an <u>argument
type</u>.
<br>except: <tt>null</tt></td>
</tr>

<tr VALIGN=TOP>
<td><b><nobr><font face="Arial,Helvetica">void f(<font color="#000000">Y&lt;?
super </font><font color="#3333FF">T</font><font color="#000000">></font>)</font></nobr></b></td>

<td>We can call methods that use the type parameter as a <u>lower wildcard
bound</u>&nbsp; in an <u>argument type</u>.
<br>The method argument must be either <tt>null</tt> or of type <tt>Y&lt;Object></tt>
(the argument type instantiated for type <tt>Object</tt>).</td>

<td></td>

<td></td>
</tr>

<tr VALIGN=TOP BGCOLOR="#C6CCDD">
<td><b><nobr><font face="Arial,Helvetica">X&lt;? extends B></font></nobr></b></td>

<td COLSPAN="4"><b><font color="#000000">wildcard with upper bound</font></b></td>
</tr>

<tr VALIGN=TOP BGCOLOR="#EDEFF3">
<td></td>

<td COLSPAN="2"><b>legal</b></td>

<td COLSPAN="2"><b>illegal</b></td>
</tr>

<tr VALIGN=TOP>
<td BGCOLOR="#EDEFF3"><b>fields</b></td>

<td><b><nobr><font face="Arial,Helvetica"><font color="#000000">x = </font><font color="#3333FF">t</font></font></nobr></b></td>

<td>We can <u>read</u> a field whose type is the type parameter.
<br>The field is accessible through a a reference whose type is the upper
bound.</td>

<td><b><font face="Arial,Helvetica"><nobr><font color="#3333FF">t</font></nobr><font color="#000000">
= x</font></font></b></td>

<td>We cannot <u>assign</u> to a field whose type is the type parameter.
<br>except: <tt>null</tt></td>
</tr>

<tr VALIGN=TOP>
<td VALIGN=TOP ROWSPAN="4" BGCOLOR="#EDEFF3"><b>methods</b></td>

<td><b><font face="Arial,Helvetica"><nobr><font color="#3333FF">T </font></nobr><font color="#000000">m()</font></font></b></td>

<td>We can call methods that use the type parameter as the<u> return type</u>.
<br>The returned value is accessible through a reference whose type is
the upper bound.</td>

<td><b><nobr><font face="Arial,Helvetica">void m(<font color="#3333FF">T</font>)</font></nobr></b></td>

<td>We cannot call methods that use the type parameter as an <u>argument
type</u>.
<br>except: <tt>null</tt></td>
</tr>

<tr VALIGN=TOP>
<td><b><nobr><font face="Arial,Helvetica"><font color="#000000">Y&lt;</font><font color="#3333FF">T</font><font color="#000000">>
f()</font></font></nobr></b>
<br><b><nobr><font face="Arial,Helvetica"><font color="#000000">Y&lt;?
extends </font><font color="#3333FF">T</font><font color="#000000">> f()</font></font></nobr></b></td>

<td>We can call methods that use the type parameter as <u>type argument</u>
in the return type or as an <u>upper wildcard bound</u> in the <u>return
type</u>.
<br>The returned value is accessible through the upper bound wildcard instantiation
of the return type (i.e. <tt>Y&lt;? extends B></tt>).</td>

<td><b><nobr><font face="Arial,Helvetica">void f(<font color="#000000">Y&lt;</font><font color="#3333FF">T</font><font color="#000000">></font>)</font></nobr></b>
<br><b><nobr><font face="Arial,Helvetica">void f(<font color="#000000">Y&lt;?
extends </font><font color="#3333FF">T</font><font color="#000000">></font>)</font></nobr></b></td>

<td>We cannot call methods that use the type parameter as <u>type argument</u>
in an argument type or as an <u>upper wildcard bound</u>&nbsp; in an <u>argument
type</u>.
<br>except: <tt>null</tt></td>
</tr>

<tr VALIGN=TOP>
<td><b><nobr><font face="Arial,Helvetica"><font color="#000000">Y&lt;?
super </font><font color="#3333FF">T</font><font color="#000000">> f()</font></font></nobr></b></td>

<td>We can call methods that use the type parameter as an <u>lower wildcard
bound</u> in the <u>return type</u>.
<br>The returned value is accessible through the unbounded wildcard instantiation
of the return type (i.e. <tt>Y&lt;?></tt>).</td>

<td></td>

<td></td>
</tr>

<tr VALIGN=TOP>
<td><b><nobr><font face="Arial,Helvetica">void f(<font color="#000000">Y&lt;?
super </font><font color="#3333FF">T</font><font color="#000000">></font>)</font></nobr></b></td>

<td>We cannot call methods that use the type parameter&nbsp; as an <u>lower
wildcard bound</u> in an <u>argument type</u>.
<br>The method argument must be either <tt>null</tt> or of a type that
belongs to the family denoted by <tt>Y&lt;? super B></tt>.</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr VALIGN=TOP BGCOLOR="#C6CCDD">
<td><b><nobr><font face="Arial,Helvetica">X&lt;? super B></font></nobr></b></td>

<td COLSPAN="4"><b><font color="#000000">wildcard with lower bound</font></b></td>
</tr>

<tr VALIGN=TOP BGCOLOR="#EDEFF3">
<td></td>

<td COLSPAN="2"><b>legal</b></td>

<td COLSPAN="2"><b>illegal</b></td>
</tr>

<tr VALIGN=TOP>
<td ROWSPAN="2" BGCOLOR="#EDEFF3"><b>fields</b></td>

<td><b><font face="Arial,Helvetica"><nobr><font color="#3333FF">t</font></nobr><font color="#000000">
= x</font></font></b></td>

<td>We can <u>assign</u> to a field whose type is the type parameter.
<br>The value to be assigend must be either <tt>null</tt> or of a type
that is the lower bound or a subtype thereof.</td>

<td></td>

<td></td>
</tr>

<tr VALIGN=TOP>
<td><b><nobr><font face="Arial,Helvetica"><font color="#000000">x = </font><font color="#3333FF">t</font></font></nobr></b></td>

<td>We can <u>read</u> a field whose type is the type parameter.
<br>The field is accessible through a reference of type <tt>Object</tt>.</td>

<td></td>

<td></td>
</tr>

<tr VALIGN=TOP>
<td ROWSPAN="6" BGCOLOR="#EDEFF3"><b>methods</b></td>

<td><b><nobr><font face="Arial,Helvetica">void m(<font color="#3333FF">T</font>)</font></nobr></b></td>

<td>We can call methods that use the type parameter as an <u>argument type</u>.
<br>The method argument must be either <tt>null</tt> or of a type <tt>B</tt>
(the lower bound).&nbsp;</td>

<td></td>

<td></td>
</tr>

<tr VALIGN=TOP>
<td><b><font face="Arial,Helvetica"><nobr><font color="#3333FF">T</font></nobr><font color="#000000">
m()</font></font></b></td>

<td>We can call methods that use the type parameter as the<u> return type</u>.
<br>The returned value is accessible through a reference of type <tt>Object</tt>.</td>

<td></td>

<td></td>
</tr>

<tr VALIGN=TOP>
<td><b><nobr><font face="Arial,Helvetica"><font color="#000000">Y&lt;</font><font color="#3333FF">T</font><font color="#000000">>
f()</font></font></nobr></b>
<br><b><nobr><font face="Arial,Helvetica"><font color="#000000">Y&lt;?
super </font><font color="#3333FF">T</font><font color="#000000">> f()</font></font></nobr></b></td>

<td>We can call methods that use the type parameter as <u>type argument</u>
in the return type or as a <u>lower wildcard bound</u> in&nbsp; the <u>return
type</u>.
<br>The returned value is accessible through the lower bound wildcard instantiation
of the return type (i.e. <tt>Y&lt;? super B></tt>).</td>

<td><b><nobr><font face="Arial,Helvetica">void f(<font color="#000000">Y&lt;</font><font color="#3333FF">T</font><font color="#000000">></font>)</font></nobr></b></td>

<td>We cannot call methods that use the type parameter as type argument
in an <u>argument type</u>.
<br>except: <tt>null</tt></td>
</tr>

<tr VALIGN=TOP>
<td><b><nobr><font face="Arial,Helvetica"><font color="#000000">Y&lt;?
extends </font><font color="#3333FF">T</font><font color="#000000">> f()</font></font></nobr></b></td>

<td>We can call methods that use the type parameter as an <u>upper wildcard
bound</u> in the <u>return type</u>.
<br>The returned value is accessible through the unbounded wildcard instantiation
of the return type (i.e. <tt>Y&lt;?></tt>).</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr VALIGN=TOP>
<td><b><nobr><font face="Arial,Helvetica">void f(<font color="#000000">Y&lt;?
extends </font><font color="#3333FF">T</font><font color="#000000">></font>)</font></nobr></b></td>

<td>We can call methods that use the type parameter&nbsp; as an <u>upper
wildcard bound</u> in an <u>argument type</u>.
<br>The method argument must be either <tt>null</tt> or of a type that
belong to the family denoted by <tt>Y&lt;? extends B></tt>.</td>

<td></td>

<td></td>
</tr>

<tr VALIGN=TOP>
<td><b><nobr><font face="Arial,Helvetica"><font color="#000000">void f(Y&lt;?
super </font><font color="#3333FF">T</font><font color="#000000">>)</font></font></nobr></b></td>

<td>We can call methods that use the type parameter as a <u>lower wildcard
bound</u>&nbsp; in an <u>argument type</u>.
<br>The method argument must be either <tt>null</tt> or of type <tt>Y&lt;Object></tt>
(the argument type instantiated for type <tt>Object</tt>).</td>

<td></td>

<td></td>
</tr>
</table>
</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ601">#FAQ601</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a wildcard instantiation?">What
is a wildcard instantiation?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What is a wildcard?">What
is a wildcard?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What is an unbounded wildcard?">What
is an unbounded wildcard?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What is a bounded wildcard?">What
is a bounded wildcard?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter in the argument or return type are accessible in an unbounded wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in an unbounded wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter in the argument or return type are accessible in an upper bound wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in an upper bound wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter in the argument or return type are accessible in a lower bound wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in a lower bound wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter as type argument of a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as type argument of a parameterized
argument or return type are accessible in a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter as upper wildcard bound in a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as upper wildcard bound in a parameterized
argument or return type are accessible in a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter as lower wildcard bound in a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as lower wildcard bound in a parameterized
argument or return type are accessible in a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#In a wildcard instantiation, can I read and write fields whose type is the type parameter?">In
a wildcard parameterized type, can I read and write fields whose type is
the type parameter?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ602"></a>
<h2>
<a NAME="Which methods that use the type parameter in the argument or return type are accessible in an unbounded wildcard instantiation?"></a><b><font face="Arial,Helvetica"><font size=+0>Which
methods that use the type parameter in the argument or return type are
accessible in an unbounded wildcard parameterized type?</font></font></b></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>We cannot call methods through an unbounded
wildcard parameterized type that take arguments of the "unknown" type.&nbsp;
But we can call methods that return objects of the "unknown" type.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Example:
<blockquote><tt>class Box&lt;<b>T</b>> {</tt>
<br><tt>&nbsp; private T t;&nbsp;</tt>
<p><tt>&nbsp; public Box(T t) { this.t = t; }</tt>
<br><tt>&nbsp; public void put(<b>T</b> t) { this.t = t;}</tt>
<br><tt>&nbsp; public <b>T</b> take() { return t; }</tt>
<p><tt>&nbsp; public boolean contains(<b>T</b> t) { return this.t == t;
}</tt>
<br><tt>&nbsp; public String toString() { return "Box["+t.toString()+"]";
}</tt>
<br><tt>}</tt>
<br><tt>class Test {</tt>
<br><tt>&nbsp; public static void main(String[] args) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; <b><font color="#000099">Box&lt;?></font></b>
box = new Box&lt;String>("abc");</tt>
<p><tt>&nbsp;&nbsp;&nbsp; box.put("xyz");&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#660000">//
error</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; box.put(null);&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#003300">//
ok</font></b></tt>
<p><tt>&nbsp;&nbsp;&nbsp; box.contains("abc");&nbsp;&nbsp;&nbsp; <b><font color="#660000">//
error</font></b></tt>
<br><tt><b><font color="#660000">&nbsp;&nbsp;&nbsp; </font></b><font color="#000000">box.toString();&nbsp;&nbsp;&nbsp;

</font><b><font color="#003300">// ok</font></b></tt>
<p><tt>&nbsp;&nbsp;&nbsp; String s = box.take();&nbsp; <b><font color="#660000">//
error</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; Object o = box.take();&nbsp; <b><font color="#003300">//
ok</font></b></tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
We cannot call the <tt>put</tt> method of the <tt>Box</tt> type through
a reference variable of type <tt>Box&lt;?></tt>, because the method takes
an argument of the unknown type that the wildcard stands for.&nbsp; From
the type information
<tt>Box&lt;?></tt> the compiler does not know whether
the object we are passing to the method is compatible with the actual object
contained in the box.&nbsp; If the
<tt>Box&lt;?></tt> would be refering
to a <tt>Box&lt;Long></tt>, then it would clearly violate the type guarantees
if we could put a string into the box that is supposed to contain a long
value. The only argument that is accepted it the <tt>null</tt> reference,
because it has no type.
<p>The same reasoning applies to <i>all</i> methods that take an argument
of the "unknown" type, even if the method does not even modify the box,
like the <tt>contains</tt> method.&nbsp; It just takes an object of the
"unknown" type and compares it.&nbsp; If a string is passed to the <tt>contains</tt>
method of a box that contains a long value, it simply returns <tt>false</tt>.&nbsp;
No harm is done.&nbsp; Yet the invocation is illegal if performed through
a reference variable of type <tt>Box&lt;?></tt>. [Defining the <tt>contains</tt>
method as taking an argument of type <tt>Object</tt>, instead of <tt>T</tt>,
would avoid this effect.&nbsp; In this case the <tt>contains</tt> method
would not take an object of "unknown", but an object of "any" type, and
it would be permitted to invoke it through a reference variable of type
<tt>Box&lt;?></tt>.]
<p>We can freely invoke any methods that neither take nor return objects
of the "unknown" type.
<p>The example demonstrates that methods returning an object of the unknown
type can be called and return an object of unknown type, which can be assigned
to a reference variable of type <tt>Object</tt>, but to not to a reference
variable of a more specific type.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ602">#FAQ602</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#Which methods and fields are accessible/inaccessible through a reference variable of a wildcard type?">Which
methods and fields are accessible/inaccessible through a reference variable
of a wildcard type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter in the argument or return type are accessible in an unbounded wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in an unbounded wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter in the argument or return type are accessible in an upper bound wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in an upper bound wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter in the argument or return type are accessible in a lower bound wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in a lower bound wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter as type argument of a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as type argument of a parameterized
argument or return type are accessible in a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter as upper wildcard bound in a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as upper wildcard bound in a parameterized
argument or return type are accessible in a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter as lower wildcard bound in a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as lower wildcard bound in a parameterized
argument or return type are accessible in a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#In a wildcard instantiation, can I read and write fields whose type is the type parameter?">In
a wildcard instantiation, can I read and write fields whose type is the
type parameter?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a wildcard instantiation?">What
is a wildcard instantiation?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What is a wildcard?">What
is a wildcard?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What is an unbounded wildcard?">What
is an unbounded wildcard?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What is a bounded wildcard?">What
is a bounded wildcard?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ603"></a>
<h2>
<a NAME="Which methods that use the type parameter in the argument or return type are accessible in an upper bound wildcard instantiation?"></a><b><font face="Arial,Helvetica"><font size=+0>Which
methods that use the type parameter in the argument or return type are
accessible in an upper bound wildcard parameterized type?</font></font></b></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>We cannot call methods through an unbounded
wildcard parameterized type that take arguments of the "unknown" type.&nbsp;
But we can call methods that return objects of the "unknown" type.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">The rules for an upper bound wildcard parameterized type
are the same as for an unbounded wildcard parameterized type.&nbsp; The
only difference that a returned object of "unknown" type is known to be
compatible to the upper bound.&nbsp;
<p>Example:
<blockquote><tt>class Box&lt;T> {</tt>
<br><tt>&nbsp; private T t;&nbsp;</tt>
<p><tt>&nbsp; public Box(T t) { this.t = t; }</tt>
<br><tt>&nbsp; public void put(<b>T</b> t) { this.t = t;}</tt>
<br><tt>&nbsp; public <b>T</b> take() { return t; }</tt>
<p><tt>&nbsp; public boolean contains(<b>T</b> t) { return this.t == t;
}</tt>
<br><tt>&nbsp; public String toString() { return "Box["+t.toString()+"]";
}</tt>
<br><tt>}</tt>
<br><tt>class Test {</tt>
<br><tt>&nbsp; public static void main(String[] args) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; <b><font color="#000000">Box&lt;? </font><font color="#000099">extends
Number</font><font color="#000000">></font></b> box = new Box&lt;Long>(0L);</tt>
<p><tt>&nbsp;&nbsp;&nbsp; box.put(1L);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#660000">//
error</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; box.put(null);&nbsp;&nbsp;&nbsp; <b><font color="#003300">//
ok</font></b></tt>
<p><tt>&nbsp;&nbsp;&nbsp; box.contains(0L);&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#660000">//
error</font></b></tt>
<br><tt><b><font color="#660000">&nbsp;&nbsp;&nbsp; </font></b><font color="#000000">box.toString();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

</font><b><font color="#003300">// ok</font></b></tt>
<p><tt>&nbsp;&nbsp;&nbsp; Long&nbsp;&nbsp; l = box.take(); <b><font color="#660000">//
error</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; <b><font color="#000099">Number</font></b> n
= box.take(); <b><font color="#003300">// ok</font></b></tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
The returned object of "unknown" type is known to be compatible to the
upper bound.&nbsp; Hence we can assign the result of <tt>take</tt> to a
reference variable of type <tt>Number</tt> in our example.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ603">#FAQ603</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#Which methods and fields are accessible/inaccessible through a reference variable of a wildcard type?">Which
methods and fields are accessible/inaccessible through a reference variable
of a wildcard type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter in the argument or return type are accessible in an unbounded wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in an unbounded wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter in the argument or return type are accessible in an upper bound wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in an upper bound wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter in the argument or return type are accessible in a lower bound wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in a lower bound wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter as type argument of a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as type argument of a parameterized
argument or return type are accessible in a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter as upper wildcard bound in a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as upper wildcard bound in a parameterized
argument or return type are accessible in a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter as lower wildcard bound in a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as lower wildcard bound in a parameterized
argument or return type are accessible in a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#In a wildcard instantiation, can I read and write fields whose type is the type parameter?">In
a wildcard instantiation, can I read and write fields whose type is the
type parameter?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a wildcard instantiation?">What
is a wildcard instantiation?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What is a wildcard?">What
is a wildcard?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What is an unbounded wildcard?">What
is an unbounded wildcard?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What is a bounded wildcard?">What
is a bounded wildcard?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ604"></a>
<h2>
<a NAME="Which methods that use the type parameter in the argument or return type are accessible in a lower bound wildcard instantiation?"></a><b><font face="Arial,Helvetica"><font size=+0>Which
methods that use the type parameter in the argument or return type are
accessible in a lower bound wildcard parameterized type?</font></font></b></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>We can call methods through an unbounded
wildcard parameterized type that take arguments of the "unknown" type.&nbsp;
But we cannot call methods that return objects of the "unknown" type.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">Compared to the rules for upper bound wildcard parameterized
types the rules for wildcard parameterized types with a lower bound wildcard
are the other way round.
<p>We can call methods through an unbounded wildcard parameterized type
that take arguments of the "unknown" type.&nbsp; But we cannot call methods
that return objects of the "unknown" type.
<p>Example:
<blockquote><tt>class Box&lt;T> {</tt>
<br><tt>&nbsp; private T t;&nbsp;</tt>
<p><tt>&nbsp; public Box(T t) { this.t = t; }</tt>
<br><tt>&nbsp; public void put(<b>T</b> t) { this.t = t;}</tt>
<br><tt>&nbsp; public <b>T</b> take() { return t; }</tt>
<p><tt>&nbsp; public boolean contains(<b>T</b> t) { return this.t == t;
}</tt>
<br><tt>&nbsp; public String toString() { return "Box["+t.toString()+"]";
}</tt>
<br><tt>}</tt>
<br><tt>class Test {</tt>
<br><tt>&nbsp; public static void main(String[] args) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; <b><font color="#000000">Box&lt;? </font><font color="#000099">super
Long</font><font color="#000000">></font></b> box = new Box&lt;Number>(0L);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Number number = new Integer(1);</tt>
<p><tt>&nbsp;&nbsp;&nbsp; box.put(1L);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#003300">//
ok</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; box.put(null);&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#003300">//
ok</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; box.put(number);&nbsp;&nbsp; <b><font color="#660000">//
error</font></b></tt>
<p><tt>&nbsp;&nbsp;&nbsp; box.contains(0L);&nbsp;&nbsp;&nbsp; <b><font color="#003300">//
ok</font></b></tt>
<br><tt><b><font color="#660000">&nbsp;&nbsp;&nbsp; </font></b><font color="#000000">box.toString();

</font><b><font color="#003300">// ok</font></b></tt>
<p><tt>&nbsp;&nbsp;&nbsp; Long&nbsp;&nbsp; l = box.take(); <b><font color="#660000">//
error</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; <font color="#000000">Number</font> n = box.take();
<b><font color="#660000">//
error</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Object o</font> = box.take();
<b><font color="#003300">//
ok</font></b></tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
Methods that take an argument of the "unknown" type can be invoked with
either <tt>null</tt> or an argument whose type is the lower bound or a
subtype thereof.&nbsp; That is, we can pass a <tt>Long</tt> to method <tt>take</tt>
through the reference of type <tt>Box&lt;? super Long></tt>.&nbsp; But
we cannot pass a <tt>Number</tt> as an argument, because the compiler does
not know whether the <tt>Box&lt;? super Long></tt> refers to a <tt>Box&lt;Number></tt>or
perhaps to a <tt>Box&lt;Comparable&lt;Long>></tt>, in which case a <tt>Number</tt>
were inacceptable, because it is not comparable.
<p>Methods that return a value of the "unknown" type can be invoked, but
only if no assumptions are made regarding the type of the returned object
and it is treated like an <tt>Object</tt>.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ604">#FAQ604</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#Which methods and fields are accessible/inaccessible through a reference variable of a wildcard type?">Which
methods and fields are accessible/inaccessible through a reference variable
of a wildcard type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter in the argument or return type are accessible in an unbounded wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in an unbounded wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter in the argument or return type are accessible in an upper bound wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in an upper bound wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter in the argument or return type are accessible in a lower bound wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in a lower bound wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter as type argument of a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as type argument of a parameterized
argument or return type are accessible in a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter as upper wildcard bound in a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as upper wildcard bound in a parameterized
argument or return type are accessible in a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter as lower wildcard bound in a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as lower wildcard bound in a parameterized
argument or return type are accessible in a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#In a wildcard instantiation, can I read and write fields whose type is the type parameter?">In
a wildcard instantiation, can I read and write fields whose type is the
type parameter?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a wildcard instantiation?">What
is a wildcard instantiation?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What is a wildcard?">What
is a wildcard?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What is an unbounded wildcard?">What
is an unbounded wildcard?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What is a bounded wildcard?">What
is a bounded wildcard?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ605"></a>
<h2>
<a NAME="Which methods that use the type parameter as type argument of a parameterized argument or return type are accessible in a wildcard instantiation?"></a><b><font face="Arial,Helvetica"><font size=+0>Which
methods that use the type parameter as type argument of a parameterized
argument or return type are accessible in a wildcard parameterized type?</font></font></b></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>We cannot call methods that use the type
parameter as type argument in an argument type. We can call methods that
use the type parameter as type argument in the return type; the returned
value is accessible through a wildcard instantiation of the return type.&nbsp;</i></b></td>
</tr>

<tr>
<td COLSPAN="2">In a wildcard parameterized type, we cannot call methods
that use the type parameter as type argument in an argument type&nbsp;
in an argument type.&nbsp; But, we can call methods that use the type parameter
as type argument in the return type; the returned value is accessible through
a wildcard instantiation of the return type.&nbsp; The wildcard instantiation
of the return type corresponds to the wildcards instantiation that was
used for the method invocation, e.g. a method of <tt>Box&lt;? extends Number></tt>
would return a <tt>ReturnType&lt;? extends Number></tt> and a a method
of <tt>Box&lt;? super Number></tt> would return a <tt>ReturnType&lt;? super
Number></tt> .
<p><a NAME="Type parameter used as type argument.+ Unbounded wildcard instantiation"></a><i>Unbounded
wildcard parameterized type.</i>
<p>Example (access through unbounded wildcard):
<blockquote><tt>class Box&lt;<b>T</b>> {</tt>
<br><tt>&nbsp; private T t;&nbsp;</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>&nbsp; public boolean equalTo(<b>Box&lt;<font color="#3333FF">T</font>></b>
other) { return this.t.equals(other.t); }</tt>
<br><tt>&nbsp; public <b>Box&lt;<font color="#3333FF">T</font>></b> copy()
{ return new Box&lt;T>(t); }</tt>
<br><tt>}</tt>
<br><tt>class Test {</tt>
<br><tt>&nbsp; public static void main(String[] args) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Box&lt;String> stringBox = new Box&lt;String>("abc");&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; <b><font color="#000066">Box&lt;?></font></b>
unknownBox = stringBox;</tt>
<p><tt>&nbsp;&nbsp;&nbsp; boolean equal = true;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; equal = unknownBox.equalTo(<font color="#000000">unknownBox</font>);
<b><font color="#660000">//
error</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; equal = unknownBox.equalTo(stringBox); <b><font color="#660000">//
error</font></b></tt>
<p><tt>&nbsp;&nbsp;&nbsp; Box&lt;?> box1 = unknownBox.copy();&nbsp; <b><font color="#003300">//
ok</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; Box&lt;String> box2 = unknownBox.copy(); <b><font color="#660000">//
error</font></b></tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br>
<hr WIDTH="100%">
<br><tt>error: equalTo(Box&lt;capture of ?>) in Box&lt;capture of ?> cannot
be applied to (Box&lt;capture of ?>)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; equal = unknownBox.equalTo(<font color="#000000">unknownBox</font>);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>error: equalTo(Box&lt;capture of ?>) in Box&lt;capture of ?> cannot
be applied to (Box&lt;java.lang.String>)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; equal = unknownBox.equalTo(stringBox);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>error: incompatible types</tt>
<br><tt>found&nbsp;&nbsp; : Box&lt;capture of ?></tt>
<br><tt>required: Box&lt;java.lang.String></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Box&lt;String> box2
= unknownBox.copy();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt></blockquote>
We cannot call the <tt>equalTo</tt> method of the <tt>Box</tt> type through
a reference variable of type <tt>Box&lt;?></tt>, because the compiler does
not know which type of object is expected as an argument of the <tt>equalTo</tt>
method. In our example the reference variable <tt>unknownBox </tt>refers
to a <tt>Box&lt;String></tt> and hence only a <tt>Box&lt;String></tt> would
be acceptable as an argument of the <tt>equalTo</tt> method.&nbsp; But
from the type information <tt>Box&lt;?></tt> the compiler does not know
which type of box would be acceptable as an argument.&nbsp; For this reason
the compiler rejects all attempts to invoke the <tt>equalTo</tt> method.
<p>Invocation of the <tt>copy</tt> method is permitted.&nbsp; It returns
an object of an unknown instantiation of the <tt>Box</tt> type to which
we can refer through a variable of type <tt>Box&lt;?></tt>.&nbsp; More
specific information about the instantiation of the <tt>Box</tt> type is
not available and for this reason the assigment to a reference variable
of an instantiation different from <tt>Box&lt;?></tt> fails.
<p>In the example, the parameterized argument and return type happens to
be the enclosing type.&nbsp; This is just by chance. The rules explained
above apply in the same way to unrelated parameterized argument and return
types.&nbsp; For instance, if the <tt>Box</tt> class had methods taking
or returning a <tt>Comparable&lt;T> </tt>the same rules would apply: methods
that take arguments of type <tt>Comparable&lt;T>&nbsp;</tt> cannot be called
and methods that return a <tt>Comparable&lt;T> </tt>can be called and the
result can be assigned to a <tt>Comparable&lt;?></tt>.&nbsp;
<br>&nbsp;
<p><i>A note on the error messages and the term "capture of":</i>
<br>The compiler uses the term "capture of ?" when it refers to the unknown
type that the wildcard stands for.&nbsp; More on the wildcard capture can
be found in <font face="Arial,Helvetica"><font size=-2><a href="#FAQ501">#FAQ501</a></font></font>.
The compiler uses the capture of a wildcard in order to denote the signatures
of methods in wildcard instantiations.&nbsp;
<br>The signature of a method in a wildcard parameterized type is determined
by replacing all occurrences of the type parameter by the capture of the
parameterized type's wildcard. For instance, the method <tt>equalTo<font color="#000000">(Box&lt;T>)</font></tt>
in <tt>Box&lt;?></tt> has the signature <tt>equalTo(Box&lt;capture of ?>)</tt>.&nbsp;&nbsp;
The same method in <tt>Box&lt;? extends Number></tt> has the signature
<tt>equalTo(Box&lt;capture
of ? extends Number>)</tt>. The method <tt>takeContentFrom<font color="#000000">(Box&lt;?
extends T></font>) </tt>in <tt>Box&lt;?> </tt>has the signature <tt>takeContentFrom(Box&lt;?
extends capture of ?>)</tt> and the same method in <tt>Box&lt;? super Number>
</tt>has
the signature <tt>takeContentFrom(Box&lt;? extends capture of ? super Number>)</tt>.&nbsp;
<br>What these "capture of capture" things mean is explained below in the
discussion of various examples. Just to give you an idea, the term "<tt>?
extends capture of ?</tt>"&nbsp; refers to a subtype ("? extends ...")
of an unknown type ("capture of ?") , and the term "<tt>? extends capture
of ? super Number</tt>" refers to subtype&nbsp; ("? extends ...") of an
unknown type ("capture of ? ...")&nbsp; that is a supertype of <tt>Number
</tt>("?
super Number") .
<br>&nbsp;
<p><a NAME="Type parameter used as type argument.+ Bounded wildcard instantiation"></a><i>Bounded
wildcard parameterized types.</i>
<p>The example above used a reference variable of the unbounded wildcard
type <tt>Box&lt;?></tt>. If we use a bounded wildcard type such as <tt>Box&lt;?
extends Number></tt> or <tt>Box&lt;? super Number></tt> the same rules
apply.&nbsp;
<p>Example (access through bounded wilcdard):
<blockquote><tt>class Box&lt;<b>T</b>> {</tt>
<br><tt>&nbsp; private T t;&nbsp;</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>&nbsp; public boolean equalTo(<b>Box&lt;<font color="#3333FF">T</font>></b>
other) { return this.t.equals(other.t); }</tt>
<br><tt>&nbsp; public <b>Box&lt;<font color="#3333FF">T</font>></b> copy()
{ return new Box&lt;T>(t); }</tt>
<br><tt>}</tt>
<br><tt>class Test {</tt>
<br><tt>&nbsp; public static void main(String[] args) {</tt>
<br><tt>&nbsp;&nbsp;<b><font color="#660000">&nbsp; </font></b><font color="#000000">Box&lt;Number>
numberBox = new Box&lt;Number>(0L);</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; </font><b><font color="#000066">Box&lt;?
extends Number></font></b><font color="#000000"> unknownBox = numberBox;&nbsp;</font></tt>
<p><tt><font color="#000000">&nbsp;&nbsp;&nbsp; boolean equal = true;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; equal = unknownBox.equalTo(unknownBox);
</font><b><font color="#660000">//
error</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; equal = unknownBox.equalTo(numberBox);
</font><b><font color="#660000">//
error</font></b></tt>
<p><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Box&lt;?> box1 = unknownBox.copy();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</font><b><font color="#003300">// ok</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Box&lt;? extends Number>
box2 = unknownBox.copy(); </font><b><font color="#003300">// ok</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Box&lt;Number> box3 =
unknownBox.copy();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><b><font color="#660000">//
error</font></b></tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br>
<hr WIDTH="100%">
<br><tt>error: equalTo(Box&lt;capture of ? extends java.lang.Number>)&nbsp;</tt>
<br><tt>in Box&lt;capture of ? extends java.lang.Number>&nbsp;</tt>
<br><tt>cannot be applied to (Box&lt;capture of ? extends java.lang.Number>)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; equal = unknownBox.equalTo(unknownBox);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>error: equalTo(Box&lt;capture of ? extends java.lang.Number>)&nbsp;</tt>
<br><tt>in Box&lt;capture of ? extends java.lang.Number>&nbsp;</tt>
<br><tt>cannot be applied to (Box&lt;java.lang.<font color="#000000">Number</font>>)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; equal = unknownBox.equalTo(numberBox);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>error: incompatible types</tt>
<br><tt>found&nbsp;&nbsp; : Box&lt;capture of ? extends java.lang.Number></tt>
<br><tt>required: Box&lt;java.lang.Number></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Box&lt;Number> box3
= unknownBox.copy();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt></blockquote>
The <tt>equalTo</tt> method cannot be called through a reference variable&nbsp;
of type <tt>Box&lt;? extends Number></tt> because the argument type is
still an unknown type.&nbsp; Thanks to the upper bound the compiler knows
that the expected argument type must be an instantiation of <tt>Box</tt>
for a type argument that is a subtype of <tt>Number</tt>, but the compiler
still does not know which instantiation exactly. Hence, the compiler cannot
make sure that the right type of argument is provided for the method invocation
and rejects the method invocation. The effect is exactly the same as for
<tt>Box&lt;?></tt>,
and likewise for <tt>Box&lt;? super Number></tt>.
<p>The copy method can be called and the in this case the result can be
assigned to a reference variable of the more specific type <tt>Box&lt;?
extends Number></tt>, instead of just <tt>Box&lt;?></tt>.&nbsp; When invoked
on a <tt>Box&lt;? super Number></tt> the result would be assignable to
a <tt>Box&lt;? super Number></tt>.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ605">#FAQ605</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#Which methods and fields are accessible/inaccessible through a reference variable of a wildcard type?">Which
methods and fields are accessible/inaccessible through a reference variable
of a wildcard type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter in the argument or return type are accessible in an unbounded wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in an unbounded wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter in the argument or return type are accessible in an upper bound wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in an upper bound wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter in the argument or return type are accessible in a lower bound wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in a lower bound wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter as type argument of a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as type argument of a parameterized
argument or return type are accessible in a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter as upper wildcard bound in a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as upper wildcard bound in a parameterized
argument or return type are accessible in a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter as lower wildcard bound in a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as lower wildcard bound in a parameterized
argument or return type are accessible in a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#In a wildcard instantiation, can I read and write fields whose type is the type parameter?">In
a wildcard instantiation, can I read and write fields whose type is the
type parameter?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a wildcard instantiation?">What
is a wildcard instantiation?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What is a wildcard?">What
is a wildcard?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#What is the capture of a wildcard?">What
is the capture of a wildcard?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ606"></a>
<h2>
<a NAME="Which methods that use the type parameter as upper wildcard bound in a parameterized argument or return type are accessible in a wildcard instantiation?"></a><b><font face="Arial,Helvetica"><font size=+0>Which
methods that use the type parameter as upper wildcard bound in a parameterized
argument or return type are accessible in a wildcard parameterized type?</font></font></b></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>We cannot call methods that use the type
parameter as an upper wildcard bound&nbsp; in an argument type, with an
exception for access through a lower bound wildcard parameterized type.
We can call methods that use the type parameter as the upper wildcard bound
in the return type; the returned value is accessible through the unbounded
wildcard instantiation of the return type.&nbsp;</i></b></td>
</tr>

<tr>
<td COLSPAN="2">In an upper bound wildcard parameterized type, we cannot
call methods that use the type parameter as an upper wildcard bound&nbsp;
in an argument type. This holds for access through unbounded and upper
bound wildcard parameterized types.&nbsp; Access through a lower bound
wildcard parameterized type is possible for certain argument types.
<p>We can call methods that use the type parameter as the upper wildcard
bound in the return type; the returned value is accessible through the
unbounded wildcard instantiation of the return type.&nbsp; This holds for
access through unbounded and lower bound wildcard parameterized types.
Access through an upper bound wildcard parameterized type yields a more
specific return type, namely a return type that corresponds to the upper
bound wildcard instantiation that was used for the method invocation, e.g.
a method of
<tt>Box&lt;? extends Number></tt> would return a <tt>ReturnType&lt;?
extends Number></tt>.
<p><a NAME="Type parameter used as upper wildcard bound. + Unbounded wildcard instantiation"></a><i>Unbounded
wildcard parameterized type.</i>
<p>Example (access through unbounded wildcard):
<blockquote><tt>class Box&lt;<b>T</b>> {</tt>
<br><tt>&nbsp; private T t;&nbsp;</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>&nbsp; public void takeContentFrom(<b>Box&lt;? extends <font color="#3333FF">T</font>></b>
box) { t = box.t; }</tt>
<br><tt>&nbsp; public <b>Class&lt;? extends <font color="#3333FF">T</font>></b>
getContentType() { ... }&nbsp;</tt>
<br><tt>}</tt>
<br><tt>class Test {</tt>
<br><tt>&nbsp; public static void main(String[] args) {</tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Box&lt;Number> numberBox
= new Box&lt;Number>(5L);&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; </font><b><font color="#000066">Box&lt;?></font></b><font color="#000000">
unknownBox = numberBox;&nbsp;</font></tt>
<p><tt><font color="#000000">&nbsp;&nbsp;&nbsp; unknownBox.takeContentFrom(numberBox);
</font><b><font color="#660000">//
error</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; unknownBox.takeContentFrom(unknownBox);
</font><b><font color="#660000">//
error</font></b></tt>
<p><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Class&lt;Number> type0
= unknownBox.getContentType();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><b><font color="#660000">//
error</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Class&lt;? extends Number>
type1 = unknownBox.getContentType(); </font><b><font color="#660000">//
error</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Class&lt;?> type2 = unknownBox.getContentType();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

</font><b><font color="#003300">// ok</font></b></tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt>
<br>
<hr WIDTH="100%">
<br><tt>error: takeContentFrom(Box&lt;? extends capture of ?>) in Box&lt;capture
of ?>&nbsp;</tt>
<br><tt>cannot be applied to (Box&lt;java.lang.Number>)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unknownBox.takeContentFrom(numberBox);&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>error: takeContentFrom(Box&lt;? extends capture of ?>) in Box&lt;capture
of ?>&nbsp;</tt>
<br><tt>cannot be applied to (Box&lt;capture of ?>)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unknownBox.takeContentFrom(unknownBox);&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>error: incompatible types</tt>
<br><tt>found&nbsp;&nbsp; : java.lang.Class&lt;capture of ? extends capture
of ?></tt>
<br><tt>required: java.lang.Class&lt;java.lang.Number></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class&lt;Number> type0
= unknownBox.getContentType();&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>error: incompatible types</tt>
<br><tt>found&nbsp;&nbsp; : java.lang.Class&lt;capture of ? extends capture
of ?></tt>
<br><tt>required: java.lang.Class&lt;? extends java.lang.Number></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class&lt;? extends Number>
type1 = unknownBox.getContentType();&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt></blockquote>
We cannot call the <tt>takeContentFrom</tt>&nbsp; through a reference variable
of type <tt>Box&lt;?></tt>, because the compiler does not know which type
of object is expected as an argument of the <tt>takeContentFrom</tt> method.
From the error message you can tell what the compiler find, namely a method
with the signature <tt>takeContentFrom(Box&lt;? extends capture of ?>)</tt>.&nbsp;&nbsp;&nbsp;
The term <tt>Box&lt;? extends capture of ?> </tt>stands for an instantiation
of Box with a type argument of an unknown type that is a subtype of another
unknown type. In essence, the argument type is unknown and the compiler
has no chance to perform any type checks to make sure the correct type
of argument is passed to the method call. And hence the invocation is illegal.
<p>Invocation of the <tt>getContentType</tt> method is permitted.&nbsp;
The return value is of a type that is an unknown instantiation of the <tt>Class</tt>
type to which we can refer through a variable of type <tt>Class&lt;?></tt>.&nbsp;
More specific information about the instantiation of the <tt>Class</tt>
type is not available and for this reason the assigment to instantiations
such as <tt>Class&lt;? extends Number></tt> as <tt>Class&lt;Number></tt>
fails.
<p><a NAME="Type parameter used as upper wildcard bound. + Upper bound wildcard instantiation"></a><i>Upper
bound wildcard parameterized type.</i>
<p>Let us see what the situation is like when we use a bounded wildcard
parameterized type instead of the unbounded one.
<p>Example (access through upper bound wildcard):
<blockquote><tt>class Box&lt;<b>T</b>> {</tt>
<br><tt>&nbsp; private T t;&nbsp;</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>&nbsp; public void takeContentFrom(<b>Box&lt;? extends <font color="#3333FF">T</font>></b>
box) { t = box.t; }</tt>
<br><tt>&nbsp; public <b>Class&lt;? extends <font color="#3333FF">T</font>></b>
getContentType() { ... }&nbsp;</tt>
<br><tt>}</tt>
<br><tt>class Test {</tt>
<br><tt>&nbsp; public static void main(String[] args) {</tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Box&lt;Number> numberBox
= new Box&lt;Number>(5L);&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; </font><b><font color="#000066">Box&lt;?
extends Number></font></b><font color="#000000"> unknownBox = numberBox;&nbsp;</font></tt>
<p><tt><font color="#000000">&nbsp;&nbsp;&nbsp; unknownBox.takeContentFrom(numberBox);
</font><b><font color="#660000">//
error</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; unknownBox.takeContentFrom(unknownBox);
</font><b><font color="#660000">//
error</font></b></tt>
<p><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Class&lt;Number> type0
= unknownBox.getContentType();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><b><font color="#660000">//
error</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Class&lt;? extends Number>
type1 = unknownBox.getContentType(); </font><b><font color="#003300">//
ok</font></b></tt>
<br><tt><font color="#000000">&nbsp;</font>&nbsp; }</tt>
<br><tt>}</tt>
<br>
<hr WIDTH="100%">
<br><tt>error: takeContentFrom(Box&lt;? extends capture of ? extends java.lang.Number>)&nbsp;</tt>
<br><tt>in Box&lt;capture of ? extends java.lang.Number>&nbsp;</tt>
<br><tt>cannot be applied to (Box&lt;java.lang.Number>)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unknownBox.takeContentFrom(numberBox);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>error: takeContentFrom(Box&lt;? extends capture of ? extends java.lang.Number>)&nbsp;</tt>
<br><tt>in Box&lt;capture of ? extends java.lang.Number>&nbsp;</tt>
<br><tt>cannot be applied to (Box&lt;capture of ? extends java.lang.Number>)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unknownBox.takeContentFrom(unknownBox);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>error: incompatible types</tt>
<br><tt>found&nbsp;&nbsp; : java.lang.Class&lt;capture of ? extends capture
of ? extends java.lang.Number></tt>
<br><tt>required: java.lang.Class&lt;java.lang.Number></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class&lt;Number> type1
= unknownBox.getContentType();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt></blockquote>
In an upper bound wildcard parameterized type such as <tt>Box&lt;? extends
Number>
</tt>the behavior is the same as in an unbounded wildcard parameterized
type. The invocation of <tt>takeFromContent</tt> is rejected because the
argument type in unknown.&nbsp; The argument type is <tt>Box&lt;? extends
capture of ? extends Number></tt> which is an instantiation of <tt>Box</tt>
for an unknown subtype of an unknown subtype of <tt>Number</tt>.
<p>Invocation of the <tt>getContentType</tt> method is permitted.&nbsp;
The return type is more specific than for the unbounded wildcard case;
we can refer to the result through a variable of type <tt>Class&lt;? extends
Number></tt>.&nbsp; This is because the return type is <tt>Class&lt;capture
of ? extends capture of ? extends Number></tt>, which is an unknown subtype
of an unknown subtype of <tt>Number</tt>, that is, a subtype of <tt>Number</tt>.
<p><a NAME="Type parameter used as upper wildcard bound. + Lower bound wildcard instantiation"></a><i>Lower
bound wildcard parameterized type.</i>
<p>Last but no least, the invocation through a lower bound wildcard.
<p>Example (access through lower bound wildcard):
<blockquote><tt>class Box&lt;<b>T</b>> {</tt>
<br><tt>&nbsp; private T t;&nbsp;</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>&nbsp; public void takeContentFrom(<b>Box&lt;? extends <font color="#3333FF">T</font>></b>
box) { t = box.t; }</tt>
<br><tt>&nbsp; public <b>Class&lt;? extends <font color="#3333FF">T</font>></b>
getContentType() { ... }&nbsp;</tt>
<br><tt>}</tt>
<br><tt>class Test {</tt>
<br><tt>&nbsp; public static void main(String[] args) {</tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Box&lt;Long>&nbsp;&nbsp;
longBox&nbsp;&nbsp; = new Box&lt;Long>(0L);</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Box&lt;Number> numberBox
= new Box&lt;Number>(0L);&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Box&lt;Object> objectBox
= new Box&lt;Object>(5L);</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Box&lt;? extends Number>
unknownNumberBox = numberBox;&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; </font><b><font color="#000066">Box&lt;?
super Number></font></b><font color="#000000">&nbsp;&nbsp; unknownBox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= numberBox;&nbsp;</font></tt>
<p><tt><font color="#000000">&nbsp;&nbsp;&nbsp; unknownBox.takeContentFrom(longBox);&nbsp;&nbsp;
</font><b><font color="#003300">// ok</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; unknownBox.takeContentFrom(numberBox);
</font><b><font color="#003300">// ok</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; unknownBox.takeContentFrom(objectBox);
</font><b><font color="#660000">// error</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; unknownBox.takeContentFrom(unknownNumberBox);
</font><b><font color="#003300">//
ok</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; unknownBox.takeContentFrom(unknownBox);
</font><b><font color="#660000">//
error</font></b></tt>
<p><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Class&lt;Number> type1
= unknownBox.getContentType();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><b><font color="#660000">//
error</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Class&lt;? extends Number>
type2 = unknownBox.getContentType(); </font><b><font color="#660000">//
error</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Class&lt;? super Number>
type3 = unknownBox.getContentType();&nbsp;&nbsp; </font><b><font color="#660000">//
error</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Class&lt;?> type4 = unknownBox.getContentType();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</font><b><font color="#003300">// ok</font></b></tt>
<br><tt><font color="#000000">&nbsp;</font>&nbsp; }</tt>
<br><tt>}</tt>
<br>
<hr WIDTH="100%">
<br><tt>error: takeContentFrom(Box&lt;? extends capture of ? super java.lang.Number>)&nbsp;</tt>
<br><tt>in Box&lt;capture of ? super java.lang.Number>&nbsp;</tt>
<br><tt>cannot be applied to (Box&lt;java.lang.Object>)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unknownBox.takeContentFrom(objectBox);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>error: takeContentFrom(Box&lt;? extends capture of ? super java.lang.Number>)&nbsp;</tt>
<br><tt>in Box&lt;capture of ? super java.lang.Number>&nbsp;</tt>
<br><tt>cannot be applied to (Box&lt;capture of ? super java.lang.Number>)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unknownBox.takeContentFrom(unknownBox);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>error: incompatible types</tt>
<br><tt>found&nbsp;&nbsp; : java.lang.Class&lt;capture of ? extends capture
of ? super java.lang.Number></tt>
<br><tt>required: java.lang.Class&lt;java.lang.Number></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class&lt;Number> type1
= unknownBox.getContentType();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>error: incompatible types</tt>
<br><tt>found&nbsp;&nbsp; : java.lang.Class&lt;capture of ? extends capture
of ? super java.lang.Number></tt>
<br><tt>required: java.lang.Class&lt;? extends java.lang.Number></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class&lt;? extends Number>
type2
= unknownBox.getContentType();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>error: incompatible types</tt>
<br><tt>found&nbsp;&nbsp; : java.lang.Class&lt;capture of ? extends capture
of ? super java.lang.Number></tt>
<br><tt>required: java.lang.Class&lt;? super java.lang.Number></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class&lt;? super Number>
type3 = unknownBox.getContentType();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt></blockquote>
The key difference for lower bound wildcards is that the <tt><font color="#000000">takeContentFrom</font></tt>&nbsp;
method can be called for certain argument types, namely for those types
that are members of the type family denoted by <tt>Box&lt;? extends Number></tt>
in our example.&nbsp; It is basically as though the <tt><font color="#000000">takeContentFrom</font></tt>&nbsp;
method in <tt>Box&lt;? super Number></tt> had the signature <tt>takeContentFrom(Box&lt;?
extends Number>)</tt>. Why is this?&nbsp; The compiler determines the signature
of the <tt><font color="#000000">takeContentFrom</font></tt>&nbsp; method
in <tt>Box&lt;? super Number></tt> as <tt>takeContentFrom(Box&lt;? extends
capture of ? super java.lang.Number>)</tt>. Now, what does "<tt>? extends
capture of ? super java.lang.Number</tt>" mean?&nbsp; It is an unknown
subtype of an unknown supertype of <tt>Number</tt>.&nbsp; No matter what
this unknown supertype of <tt>Number</tt> may be, the subtypes of <tt>Number</tt>
would conform to this description.
<p>Invocation of the <tt>getContentType</tt> method is permitted, as expected.&nbsp;
Perhaps surprising is that fact that the return type is not <tt>Class&lt;?
super Number></tt>, but only <tt>Class&lt;?></tt>. This is because the
return type is <tt>Class&lt;capture of ? extends capture of ? super Number></tt>,
which is an unknown subtype of an unknown supertype of <tt>Number</tt>.
Just imagine the unknown supertype of <tt>Number</tt> were <tt>Object</tt>,
then it could by any type. Hence we know nothing about the return type
except that it is an instantiation of class <tt>Class</tt> and <tt>Class&lt;?>
</tt>correctly
describes it.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ606">#FAQ606</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#Which methods and fields are accessible/inaccessible through a reference variable of a wildcard type?">Which
methods and fields are accessible/inaccessible through a reference variable
of a wildcard type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter in the argument or return type are accessible in an unbounded wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in an unbounded wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter in the argument or return type are accessible in an upper bound wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in an upper bound wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter in the argument or return type are accessible in a lower bound wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in a lower bound wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter as type argument of a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as type argument of a parameterized
argument or return type are accessible in a wildcard parameterized typ?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter as upper wildcard bound in a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as upper wildcard bound in a parameterized
argument or return type are accessible in a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter as lower wildcard bound in a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as lower wildcard bound in a parameterized
argument or return type are accessible in a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#In a wildcard instantiation, can I read and write fields whose type is the type parameter?">In
a wildcard instantiation, can I read and write fields whose type is the
type parameter?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a wildcard instantiation?">What
is a wildcard instantiation?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What is a wildcard?">What
is a wildcard?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#What is the capture of a wildcard?">What
is the capture of a wildcard?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ607"></a>
<h2>
<a NAME="Which methods that use the type parameter as lower wildcard bound in a parameterized argument or return type are accessible in a wildcard instantiation?"></a><b><font face="Arial,Helvetica"><font size=+0>Which
methods that use the type parameter as lower wildcard bound in a parameterized
argument or return type are accessible in a wildcard parameterized type?</font></font></b></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>We can call methods that use the type
parameter as a lower wildcard bound in the return type; the returned value
is accessible through a wildcard instantiation of the return type (which
one depends on the wildcard parameterized type being used). We can call
methods that use the type parameter as a lower wildcard bound&nbsp; in
an argument type; the argument type is restricted depending on the wildcard
being use.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">In a lower bound wildcard parameterized type, we can call
methods that use the type parameter as a lower wildcard bound in the return
type. The returned value is accessible through a wildcard instantiation
of the return type.&nbsp; In an unbounded wildcard parameterized type and
an upper bound wildcard parameterized type the return type is the unbounded
wildcard instantiation of the return type. In a lower bound wildcard parameterized
type the return type is more specific, namely the lower bound wildcard
instantiation of the return type. That is, a method in class <tt>Box</tt>
that return
<tt>Comparable&lt;? super T></tt> would return <tt>Comparable&lt;?></tt>
in <tt>Box&lt;?> </tt>and
<tt>Box&lt;? extends Number></tt> and would return
<tt>Comparable&lt;?
super Number></tt> in <tt>Box&lt;? super Number></tt>.&nbsp;
<p>This matches the return types of methods with an upper bound wildcard;
a method in class <tt>Box</tt> that return <tt>Comparable&lt;? extends
T></tt> would return <tt>Comparable&lt;?></tt> in <tt>Box&lt;?> </tt>and
<tt>Box&lt;?
super Number></tt> and would return <tt>Comparable&lt;? extends Number></tt>
in <tt>Box&lt;? extends Number></tt>.&nbsp; The reasoning for lower bound
wildcard parameterized types is the exactly the same as for upper bound
wildcard parameterized types.&nbsp; The more specific return type in a
lower bound wildcard parameterized type stems from the fact that the return
type of a method that returns <tt>Comparable&lt;? super T></tt>&nbsp; in
the instantiation <tt>Box&lt;? super Number></tt> would be <tt>Comparable&lt;capture
of ? super capture of ? super Number></tt>, which boils down to <tt>Comparable&lt;?
super Number></tt>.
<br>&nbsp;
<p>More interesting is the invocation of methods that take arguments with
lower wildcard bounds. We can call methods that use the type parameter
as a lower wildcard bound&nbsp; in an argument type. In an unbounded wildcard
parameterized type and a lower bound wildcard parameterized type the only
permitted argument type is the argument type instantiated for type <tt>Object</tt>.
That is, a method in class <tt>Box</tt> that takes an argument of type
<tt>Comparable&lt;?
super Number></tt> would in the parameterized types <tt>Box&lt;?>
</tt>and<tt>
Box&lt;? super Number></tt> accept arguments of <tt>Comparable&lt;Object></tt>.&nbsp;
Note, this is different from methods that use the type parameter as a <u>upper</u>
wildcard bound&nbsp; in an argument type; they cannot be invokeds at all.&nbsp;
The reason for this permitted argument type is that such a method would
have the signature <tt>method(Comparable&lt;? super capture of ?>)</tt>
in an unbounded parameterized type such as <tt>Box&lt;?></tt>, and "? super
capture of ?" denotes an unknown supertype of an unknown type. The ultimate
supertype of all types is <tt>Object</tt>, hence <tt>Comparable&lt;Object></tt>
is permitted as an argument type. And likewise in <tt>Box&lt;? super Number></tt>,
where the signature would involve "? super capture of ? super Number",
and again <tt>Object</tt> is the only type that would fit.
<p>In an upper bound wildcard parameterized type with upper bound <tt>Bound</tt>
the permitted arguments types are the types that belong to the family denoted
by <tt>ArgumentType&lt;? super Bound></tt>.&nbsp; That is, a method in
class <tt>Box</tt> that takes an argument of type <tt>Comparable&lt;? super
Number></tt> would in the instantiation <tt>Box&lt;? extends Number></tt>
accept arguments from the type family <tt>Comparable&lt;? super Number></tt>.
Note, this is similar to a method with an upper bound argument type in
an lower bound parameterized type; e.g. a method in class <tt>Box</tt>
that takes an argument of type <tt>Comparable&lt;? extends Number></tt>
would in the parameterized type <tt>Box&lt;? super Number></tt> accept
arguments from the type family <tt>Comparable&lt;? extends Number></tt>.
The reason for the permitted argument types is that the compiler determines
the signature of such a method in <tt>Box&lt;? extends Number></tt> as
method<tt>(Box&lt;? super capture of ? extends Number>)</tt>.&nbsp; "<tt>
super capture of ? extends Number</tt>" means unknown supertype of an unknown
subtype of
<tt>Number</tt>, in other words all supertypes of <tt>Number</tt>.&nbsp;
<p><a NAME="Type parameter used as lower wildcard bound. + Unbounded wildcard instantiation"></a><i>Unbounded
wildcard parameterized type.</i>
<p>Example (access through unbounded wildcard):
<blockquote><tt>class Box&lt;<b>T</b>> {</tt>
<br><tt>&nbsp; private T t;&nbsp;</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>&nbsp; public int compareTo(<b>Comparable&lt;? super <font color="#3333FF">T</font>></b>
other) { return other.compareTo(t); }</tt>
<br><tt>&nbsp; public <b>Box&lt;? super <font color="#3333FF">T</font>></b>
copy() { return new Box&lt;T>(t); }&nbsp;</tt>
<br><tt>}</tt>
<br><tt>class Test {</tt>
<br><tt>&nbsp; public static void main(String[] args) {</tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Box&lt;Number> numberBox
= new Box&lt;Number>(5L);&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; </font><b><font color="#000066">Box&lt;?></font></b><font color="#000000">
unknownBox = numberBox;&nbsp;</font></tt>
<p><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Comparable&lt;?> comparableToUnknown
= new Integer(1);</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Comparable&lt;Object>
comparableToObject = ...;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Comparable&lt;? super
Number> comparableToNumber = comparableToObject;</font></tt>
<p><tt><font color="#000000">&nbsp;&nbsp;&nbsp; int compared = 0;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; compared = unknownBox.compareTo(comparableToUnknown);
</font><b><font color="#660000">//
error</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; compared = unknownBox.compareTo(comparableToObject);
</font><b><font color="#003300">//
ok</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; compared = unknownBox.compareTo(comparableToNumber);
</font><b><font color="#660000">//
error</font></b></tt>
<p><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Box&lt;?>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
box1 = unknownBox.copy(); </font><b><font color="#003300">// ok</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Box&lt;? extends Number>
box2 = unknownBox.copy(); </font><b><font color="#660000">// error</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Box&lt;? super Number>&nbsp;&nbsp;
box3 = unknownBox.copy);&nbsp; </font><b><font color="#660000">// error</font></b></tt>
<br><tt><font color="#000000">&nbsp;</font>&nbsp; }</tt>
<br><tt>}</tt>
<br>
<hr WIDTH="100%">
<br><tt>error: compareTo(java.lang.Comparable&lt;? super capture of ?>)
in Box&lt;capture of ?> cannot be applied to (java.lang.Comparable&lt;capture
of ?>)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; compared = unknownBox.compareTo(comparableToUnknown);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>error: compareTo(java.lang.Comparable&lt;? super capture of ?>)
in Box&lt;capture of ?> cannot be applied to (java.lang.Comparable&lt;capture
of ? super java.lang.Number>)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; compared = unknownBox.compareTo(comparableToNumber);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>error: incompatible types</tt>
<br><tt>found&nbsp;&nbsp; : Box&lt;capture of ? super capture of ?></tt>
<br><tt>required: Box&lt;? extends java.lang.Number></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Box&lt;? extends Number>
box2 = unknownBox.copy();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>error: incompatible types</tt>
<br><tt>found&nbsp;&nbsp; : Box&lt;capture of ? super capture of ?></tt>
<br><tt>required: Box&lt;? super java.lang.Number></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Box&lt;? super Number>
box3 = unknownBox.copy();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt></blockquote>
The example shows that method <tt>compareTo</tt> can only be invoked for
arguments of type <tt>Comparable&lt;Object></tt> and that the return type
of method <tt>copy</tt> is <tt>Comparable&lt;?></tt>.
<p><a NAME="Type parameter used as lower wildcard bound. +Upper bound wildcard instantiation"></a><i>Upper
bound wildcard parameterized type.</i>
<p>Example (access through upper bound wildcard):
<blockquote><tt>class Box&lt;<b>T</b>> {</tt>
<br><tt>&nbsp; private T t;&nbsp;</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>&nbsp; public int compareTo(<b>Comparable&lt;? super <font color="#3333FF">T</font>></b>
other) { return other.compareTo(t); }</tt>
<br><tt>&nbsp; public <b>Box&lt;? super <font color="#3333FF">T</font>></b>
copy() { return new Box&lt;T>(t); }&nbsp;</tt>
<br><tt>}</tt>
<br><tt>class Test {</tt>
<br><tt>&nbsp; public static void main(String[] args) {</tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Box&lt;Number> numberBox
= new Box&lt;Number>(5L);&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; </font><b><font color="#000066">Box&lt;?
extends Number></font></b><font color="#000000"> unknownBox = numberBox;&nbsp;</font></tt>
<p><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Comparable&lt;?> comparableToUnknown
= new Integer(1);</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Comparable&lt;Object>
comparableToObject = ...;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Comparable&lt;? super
Number> comparableToNumber = comparableToObject;</font></tt>
<p><tt><font color="#000000">&nbsp;&nbsp;&nbsp; int compared = 0;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; compared = unknownBox.compareTo(comparableToUnknown);
</font><b><font color="#660000">//
error</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; compared = unknownBox.compareTo(comparableToObject);
</font><b><font color="#003300">//
ok</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; compared = unknownBox.compareTo(comparableToNumber);
</font><b><font color="#003300">//
ok</font></b></tt>
<p><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Box&lt;?>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
box1 = unknownBox.copy(); </font><b><font color="#003300">// ok</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Box&lt;? extends Number>
box2 = unknownBox.copy(); </font><b><font color="#660000">// error</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Box&lt;? super Number>&nbsp;&nbsp;
box3 = unknownBox.copy);&nbsp; </font><b><font color="#660000">// error</font></b></tt>
<br><tt><font color="#000000">&nbsp;</font>&nbsp; }</tt>
<br><tt>}</tt>
<br>
<hr WIDTH="100%">
<br><tt>error: compareTo(java.lang.Comparable&lt;? super capture of ? extends
java.lang.Number>) in Box&lt;capture of ? extends java.lang.Number> cannot
be applied to (java.lang.Comparable&lt;capture of ?>)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; compared = unknownBox.compareTo(comparableToUnknown);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>error: incompatible types</tt>
<br><tt>found&nbsp;&nbsp; : Box&lt;capture of ? super capture of ? extends
java.lang.Number></tt>
<br><tt>required: Box&lt;? extends java.lang.Number></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Box&lt;? extends Number>
box2 = unknownBox.copy();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>error: incompatible types</tt>
<br><tt>found&nbsp;&nbsp; : Box&lt;capture of ? super capture of ? extends
java.lang.Number></tt>
<br><tt>required: Box&lt;? super java.lang.Number></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Box&lt;? super Number>
box3 = unknownBox.copy();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt></blockquote>
The example shows that method <tt>compareTo</tt> can only be invoked for
arguments from the type family denoted by&nbsp; <tt>Comparable&lt;? super
Number></tt> and that the return type of method <tt>copy</tt> is <tt>Comparable&lt;?></tt>.
<p><a NAME="Type parameter used as lower wildcard bound. + Lower bound wildcard instantiation"></a><i>Lower
bound wildcard parameterized type.</i>
<p>Example (access through lower bound wildcard):
<blockquote><tt>class Box&lt;<b>T</b>> {</tt>
<br><tt>&nbsp; private T t;&nbsp;</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>&nbsp; public int compareTo(<b>Comparable&lt;? super <font color="#3333FF">T</font>></b>
other) { return other.compareTo(t); }</tt>
<br><tt>&nbsp; public <b>Box&lt;? super <font color="#3333FF">T</font>></b>
copy() { return new Box&lt;T>(t); }&nbsp;</tt>
<br><tt>}</tt>
<br><tt>class Test {</tt>
<br><tt>&nbsp; public static void main(String[] args) {</tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Box&lt;Number> numberBox
= new Box&lt;Number>(5L);&nbsp;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; </font><b><font color="#000066">Box&lt;?
super Number></font></b><font color="#000000"> unknownBox = numberBox;&nbsp;</font></tt>
<p><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Comparable&lt;?> comparableToUnknown
= new Integer(1);</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Comparable&lt;Object>
comparableToObject = ...;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Comparable&lt;? super
Number> comparableToNumber = comparableToObject;</font></tt>
<p><tt><font color="#000000">&nbsp;&nbsp;&nbsp; int compared = 0;</font></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; compared = unknownBox.compareTo(comparableToUnknown);
</font><b><font color="#660000">//
error</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; compared = unknownBox.compareTo(comparableToObject);
</font><b><font color="#003300">//
ok</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; compared = unknownBox.compareTo(comparableToNumber);
</font><b><font color="#660000">//
error</font></b></tt>
<p><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Box&lt;?>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
box1 = unknownBox.copy(); </font><b><font color="#003300">// ok</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Box&lt;? extends Number>
box2 = unknownBox.copy(); </font><b><font color="#660000">// error</font></b></tt>
<br><tt><font color="#000000">&nbsp;&nbsp;&nbsp; Box&lt;? super Number>&nbsp;&nbsp;
box3 = unknownBox.copy);&nbsp; </font><b><font color="#003300">// ok</font></b></tt>
<br><tt><font color="#000000">&nbsp;</font>&nbsp; }</tt>
<br><tt>}</tt>
<br>
<hr WIDTH="100%">
<br><tt>error: compareTo(java.lang.Comparable&lt;? super capture of ? super
java.lang.Number>) in Box&lt;capture of ? super java.lang.Number> cannot
be applied to (java.lang.Comparable&lt;capture of ?>)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; compared = unknownBox.compareTo(comparableToUnknown);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>error: compareTo(java.lang.Comparable&lt;? super capture of ? super
java.lang.Number>) in Box&lt;capture of ? super java.lang.Number> cannot
be applied to (java.lang.Comparable&lt;capture of ? super java.lang.Number>)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; compared = unknownBox.compareTo(comparableToNumber);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt>
<br><tt>error: incompatible types</tt>
<br><tt>found&nbsp;&nbsp; : Box&lt;capture of ? super capture of ? super
java.lang.Number></tt>
<br><tt>required: Box&lt;? extends java.lang.Number></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Box&lt;? extends Number>
box3 = unknownBox.copy();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^</tt></blockquote>
The example shows that method <tt>compareTo</tt> can only be invoked for
arguments of type <tt>Comparable&lt;Object></tt> and that the return type
of method <tt>copy</tt> is <tt>Comparable&lt;? super Number></tt>.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ607">#FAQ607</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#Which methods and fields are accessible/inaccessible through a reference variable of a wildcard type?">Which
methods and fields are accessible/inaccessible through a reference variable
of a wildcard type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter in the argument or return type are accessible in an unbounded wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in an unbounded wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter in the argument or return type are accessible in an upper bound wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in an upper bound wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter in the argument or return type are accessible in a lower bound wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in a lower bound wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter as type argument of a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as type argument of a parameterized
argument or return type are accessible in a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter as upper wildcard bound in a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as upper wildcard bound in a parameterized
argument or return type are accessible in a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter as lower wildcard bound in a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as lower wildcard bound in a parameterized
argument or return type are accessible in a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#In a wildcard instantiation, can I read and write fields whose type is the type parameter?">In
a wildcard parameterized type, can I read and write fields whose type is
the type parameter?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a wildcard instantiation?">What
is a wildcard instantiation?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What is a wildcard?">What
is a wildcard?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#What is the capture of a wildcard?">What
is the capture of a wildcard?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350><a NAME="FAQ608"></a>
<h2>
<a NAME="In a wildcard instantiation, can I read and write fields whose type is the type parameter?"></a><b><font face="Arial,Helvetica"><font size=+0>In
a wildcard parameterized type, can I read and write fields whose type is
the type parameter?</font></font></b></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i><font size=+0>It depends on the kind
of wildcard.</font></i></b></td>
</tr>

<tr>
<td COLSPAN="2">In a wildcard parameterized type a field whose type is
the type parameter of the enclosing generic class is of unknown type. Depending
on the wildcard (whether it is unbounded or has an upper or lower bound)
different kinds of access are permitted or disallowed.
<p>
<hr WIDTH="100%">
<p><i>Unbounded wildcards.</i>
<p>Assignment to a field of the "unknown" type is rejected because the
compiler cannot judge whether the object to be assigned is an acceptable
one.&nbsp; Read access to a field of the "unknown" type is permitted, but
the field has no specific type and must be refered to through a reference
of type <tt>Object</tt>.
<p>Example:
<blockquote><tt>class Box&lt;T> {</tt>
<br><tt>&nbsp; public T t;&nbsp; // public just for sake of demonstration</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>}</tt>
<br><tt>class Test {</tt>
<br><tt>&nbsp; public static void main(String[] args) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; <b><font color="#000099">Box&lt;?></font></b>
box = new Box&lt;String>("abc");</tt>
<p><tt>&nbsp;&nbsp;&nbsp; box.t = "xyz";&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#660000">//
error</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; box.t = null;&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#003300">//
ok</font></b></tt>
<p><tt>&nbsp;&nbsp;&nbsp; String s = box.t;&nbsp; <b><font color="#660000">//
error</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; Object o = box.t;&nbsp; <b><font color="#003300">//
ok</font></b></tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>

<hr WIDTH="100%">
<br><i>Wildcards with an upper bound.</i>
<p>The same rules apply to wildcard parameterized type with an upper bound
wildcard.
<p>Example:
<blockquote><tt>class Box&lt;T> {</tt>
<br><tt>&nbsp; public T t;&nbsp; // public just for sake of demonstration</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>}</tt>
<br><tt>class Test {</tt>
<br><tt>&nbsp; public static void main(String[] args) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; <b><font color="#000000">Box&lt;? </font><font color="#000099">extends
Number</font><font color="#000000">></font></b> box = new Box&lt;Long>(0L);</tt>
<p><tt>&nbsp;&nbsp;&nbsp; box.t = 1L;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#660000">//
error</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; box.t = null;&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#003300">//
ok</font></b></tt>
<p><tt>&nbsp;&nbsp;&nbsp; <b><font color="#000099">Number </font></b>n
= box.t; <b><font color="#660000">// error</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; Object o = box.t; <b><font color="#003300">//
ok</font></b></tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
The only difference that a field of "unknown" type is known to be compatible
to the upper bound.&nbsp; Hence we can assign the field to a reference
variable of type <tt>Number</tt> in our example.
<p>
<hr WIDTH="100%">
<br><i>Wildcards with a lower bound.</i>
<p>The rules for wildcard parameterized types with a lower bound wildcard
are the other way round. We can assign <tt>null</tt> or a value whose type
is the lower bound or a subtype thereof, but we cannot assign a value that
is of a supertype of the lower bound. And we must not make any assumptions
regarding the type of the field; it must be treated like an <tt>Object</tt>.
<p>Example:
<blockquote><tt>class Box&lt;T> {</tt>
<br><tt>&nbsp; public T t;&nbsp; // public just for sake of demonstration</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>}</tt>
<br><tt>class Test {</tt>
<br><tt>&nbsp; public static void main(String[] args) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; <b><font color="#000000">Box&lt;? </font><font color="#000099">super
Long</font><font color="#000000">></font></b> box = new Box&lt;Number>(0L);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Number number = new Integer(1);</tt>
<p><tt>&nbsp;&nbsp;&nbsp; box.t = 1L;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#003300">//
ok</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; box.t = null;&nbsp;&nbsp;&nbsp;&nbsp; <b><font color="#003300">//
ok</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; box.t = number;&nbsp;&nbsp;&nbsp; <b><font color="#660000">//
error</font></b></tt>
<p><tt>&nbsp;&nbsp;&nbsp; Long&nbsp;&nbsp; l = box.t;&nbsp; <b><font color="#660000">//
error</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; Number n = box.t;&nbsp; <b><font color="#660000">//
error</font></b></tt>
<br><tt>&nbsp;&nbsp;&nbsp; Object o = box.t;&nbsp; <b><font color="#003300">//
ok</font></b></tt>
<br><tt>&nbsp; }</tt>
<br><tt>}</tt></blockquote>
</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ608">#FAQ608</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#Which methods and fields are accessible/inaccessible through a reference variable of a wildcard type?">Which
methods and fields are accessible/inaccessible through a reference variable
of a wildcard type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter in the argument or return type are accessible in an unbounded wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in an unbounded wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter in the argument or return type are accessible in an upper bound wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in an upper bound wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter in the argument or return type are accessible in a lower bound wildcard instantiation?">Which
methods that use the type parameter in the argument or return type are
accessible in a lower bound wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter as type argument of a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as type argument of a parameterized
argument or return type are accessible in a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter as upper wildcard bound in a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as upper wildcard bound in a parameterized
argument or return type are accessible in a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#Which methods that use the type parameter as lower wildcard bound in a parameterized argument or return type are accessible in a wildcard instantiation?">Which
methods that use the type parameter as lower wildcard bound in a parameterized
argument
or return type are accessible in a wildcard parameterized type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="#In a wildcard instantiation, can I read and write fields whose type is the type parameter?">In
a wildcard parameterized type, can I read and write fields whose type is
the type parameter?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is a wildcard instantiation?">What
is a wildcard instantiation?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What is a wildcard?">What
is a wildcard?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What is an unbounded wildcard?">What
is an unbounded wildcard?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="TypeArguments.html#What is a bounded wildcard?">What
is a bounded wildcard?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350>
<br>&nbsp;
<h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450></h3>

<h3>
<a NAME="Cast and instanceof"></a>Cast and instanceof</h3>
<img SRC="../../Images/bar.gif" NOSAVE height=3 width=450><a NAME="FAQ701"></a>
<h2>
<a NAME="Which types can or must not appear as target type in an instanceof expression?"></a><font face="Arial,Helvetica"><font size=+0>Which
types can or must not appear as target type in an instanceof expression?</font></font></h2>

<table CELLPADDING=10 WIDTH="100%" >
<tr VALIGN=TOP>
<td COLSPAN="2" WIDTH="68%"><b><i>Only reifiable types are permitted.</i></b></td>
</tr>

<tr>
<td COLSPAN="2">It is a compile-time error if the reference type mentioned
after the <tt>instanceof</tt> operator does not denote a reifiable type.&nbsp;
In other words, concrete and bounded wildcard parameterized types are NOT
permitted in an <tt>instanceof</tt> expression.
<p>Examples:
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object o = new LinkedList&lt;Long>();</tt>
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println (o
instanceof List);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println (o
instanceof List&lt;?>);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println (o
instanceof List&lt;Long>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// error</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println (o
instanceof List&lt;? extends Number>);&nbsp;&nbsp;&nbsp;&nbsp; // error</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println (o
instanceof List&lt;? super Number>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// error</tt>
<p>The reason for disallowing non-reifiable types (i.e., instantiations
of a generic type with at least one type arguments that is a concrete type
or a bounded wildcard) in <tt>instanceof</tt> expression is that these
parameterized types do not have an exact runtime type representation.&nbsp;
Their dynamic type after type erasure is just the raw type.&nbsp;&nbsp;
The evaluation of an <tt>instanceof </tt>expression could at best check
whether the object in question is an instance of the raw type.&nbsp; In
the example, the expression
<tt>(o instanceof List&lt;Long>) </tt>would
check whether o is an instance of type<tt> List</tt>, which is a check
different from what the source code suggests. In order to avoid confusion,
the non-reifiable types are prohibited in <tt>instanceof</tt> expression.
<p>Only the reifiable types (i.e., the raw type and the unbounded wildcard
parameterized type) are permitted in an <tt>instanceof</tt> expression.&nbsp;
The reifiable types do not lose any type information during translation
by type erasure. For this reason, the <tt>instanceof</tt> check makes sense
and is allowed.</td>
</tr>

<tr>
<td><b><font face="Arial,Helvetica"><font size=-2>LINK TO THIS</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#FAQ701">#FAQ701</a></font></font></td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="10%"><b><font face="Arial,Helvetica"><font size=-2>REFERENCES</font></font></b></td>

<td><font face="Arial,Helvetica"><font size=-2><a href="#What is a reifiable type?">What
is a reifiable type?</a></font></font>
<br><font face="Arial,Helvetica"><font size=-2><a href="ParameterizedTypes.html#What is an unbounded wildcard instantiation?">What
is an unbounded wildcard instantiation?</a></font></font></td>
</tr>
</table>
<img SRC="../../Images/bar-small.gif" NOSAVE height=3 width=350>
<br>
<hr WIDTH="100%">
<br><font face="Arial,Helvetica"><font size=-2><a href="../JavaGenericsFAQ.html#TOC">CONTENT<a href="../JavaGenericsFAQ.html#TOC"><img SRC="../../Images/bluebullet.gif" NOSAVE BORDER=0 height=6 width=4></a></a><font color="#666666"><a href="ProgrammingIdioms.html">PREVIOUS<a href="../JavaGenericsFAQ.html#TOC"><img SRC="../../Images/bluebullet.gif" NOSAVE BORDER=0 height=6 width=4></a></a></font><a href="MoreInformation.html">NEXT<a href="../JavaGenericsFAQ.html#TOC"><img SRC="../../Images/bluebullet.gif" NOSAVE BORDER=0 height=6 width=4></a></a><a href="Index.html#IDX">INDEX</a></font></font>
</body>
</html>
