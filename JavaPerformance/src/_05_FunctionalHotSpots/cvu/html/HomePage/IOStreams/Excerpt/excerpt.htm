<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.79 [en] (Windows NT 5.0; U) [Netscape]">
   <meta name="Author" content="Angelika Langer and Klaus Kreft">
   <title>Book Excerpt (published in C++ Report, April 2000)</title>
</head>
<body text="#000000" bgcolor="#FFFFFF" link="#113E79" vlink="#677DAD" alink="#008080">
<a NAME="Top"></a><a NAME="IOStreamsExcerpt"></a>
<h1>
<b><font face=""><font color="#003333"><font size=+0>streambuf: The Stream
Buffer Classes</font></font></font></b></h1>
<font face=""><font size=-2><i>excerpted from pages 84-109 of</i> Standard
C++ IOStreams and Locales,</font></font>
<br><i><font face=""><font size=-2>by Angelika Langer and Klaus Kreft</font></font></i>
<br>&nbsp;
<br>&nbsp;
<p><i><font face=""><font size=-1>&copy; 2000 by Addison Wesley Longman
Inc.</font></font></i>
<br><i><font face=""><font size=-1>Reproduced by permission of Addison
Wesley Longman. All rights reserved.</font></font></i>
<p><font face=""><font size=-1>You might wonder why on earth we devote
10+ pages of our book to the guts of stream buffers, which seem to be nothing
more than an implementation detail of the IOStreams library. For an answer,
let us quote Jerry Schwarz, the "inventor" of IOStreams (quote taken from
the foreword):</font></font>
<br>&nbsp;
<br>&nbsp;
<blockquote><i><font face=""><font size=-1>"A major goal in my original
design was that it be extensible in interesting ways. In particular, in
the stream library the streambuf class was an implementation detail, but
in the iostream library I intended it to be a usable class in its own right.
I was hoping for the promulgation of many streambufs with varied functionality.
I wrote a few myself, but almost no one else did. I answered many more
questions of the form "how do I make my numbers look like this" than "how
do I write a streambuf". And textbook authors also tended to ignore streambufs.
Apparently they did not share my view that the architecture of the input/output
library was an interesting case study."</font></font></i></blockquote>
<font size=-1><font face="">Essentially, we agree with Jerry and find that
the architecture IOStreams is an interesting case study of an extensible
framework. Within this framework, the stream buffer abstraction is much
more than an irrelevant implementation detail. Deriving from the stream
buffer base class </font><font face="Courier">basic_streambuf</font><font face="">
is a major extension point in IOStreams. It allows connection of user-specific
devices to the IOStreams framework in a way that the stream layer's rich
functionality of formatting and parsing can be reused together with the
newly connected device. Not only can additional hardware be made accessible
through the stream buffer interface, but also software abstractions can
be hooked into the IOStreams framework. In fact, every abstraction that
exhibits stream-like behavior and can serve as a source or sink of characters
can be seen as an external device. Examples include: output to a certain
window in a graphical user interface for display of trace information or
input and output to a socket or shared memory for communication between
two processes or a special wrap-around file abstraction for logbook purposes
or any kind of filter functionality such as skipping comments on input
or insertion of line counts on output. The list of conceivable extensions
is endlessly long, and naturally you will find a section in the book that
goes into the practical details of deriving concrete stream buffer classes.
As Jerry said: It's an interesting case study.</font></font>
<br>&nbsp;
<br>&nbsp;
<p><b><font face=""><font size=-1>The Stream Buffer Classes</font></font></b>
<br><font face=""><font size=-1>The stream buffer classes represent the
abstraction of a connection to an external device. The main task of the
stream buffer is transport of characters to and from this external device,
and buffering of these characters in an internal buffer.</font></font>
<p><font face=""><font size=-1>&nbsp;The external devices are seen as sequences
of characters. In the following, we will therefore simply talk of <i>sequences</i>
when we mean the abstraction of an external device.</font></font>
<p><font face=""><font size=-1>&nbsp;Stream buffers are used by streams
for actual transport of characters to and from a device, whereas the streams
themselves are responsible for parsing and formatting the text input and
output.</font></font>
<br>&nbsp;
<br>&nbsp;
<p><b><font face=""><font size=-1>Class Hierarchy</font></font></b>
<br><font face=""><font size=-1>Like the stream classes, the stream buffer
classes are organized in a class hierarchy (see figure 2-5).</font></font>
<p><img SRC="fig02-05.jpg" ALT="Figure 2-5" BORDER=0 >
<br><i><font face=""><font size=-1><b>Figure 2-5:</b> The stream buffer
classes.</font></font></i>
<p><font size=-1><font face="">&nbsp;Class </font><font face="Courier">basic_streambuf&lt;class
charT, class Traits></font><font face=""> acts as an "abstract" stream
buffer class. All concrete stream buffer classes, such as file stream buffers
and string stream buffers, are derived from that "abstract" stream buffer
class. The concrete stream buffer classes encapsulate knowledge that is
specific to the external device connected to the stream, whereas the stream
base class is independent of the specific device and defines the general
buffering and transport interface and functionality that has to be provided
by a stream buffer.</font></font>
<p><font size=-1><font face="">&nbsp;Class </font><font face="Courier">basic_streambuf&lt;class
charT, class Traits></font><font face=""> is an "abstract" base class in
the sense that no instances of this class can be constructed. Its constructor
is protected and accessible only to derived classes. A number of member
functions are virtual and meant to be overwritten by a derived class. However,
none of the virtual functions is purely virtual. Rather, all virtual member
functions implement a sensible default behavior so that they need not be
overwritten in a derived class if the default behavior already meets the
derived class's needs.</font></font>
<p><font size=-1><font face="">&nbsp;The file buffer classes </font><font face="Courier">basic_filebuf&lt;class
charT, class Traits></font><font face=""> allow input and output to files.
They have additional member functions </font><font face="Courier">open()</font><font face="">
and </font><font face="Courier">close()</font><font face=""> that are necessary
for file handling, and they override several virtual functions that perform
the actual transport of characters to and from the file.</font></font>
<p><font size=-1><font face="">&nbsp;The string stream buffer classes </font><font face="Courier">basic_stringbuf&lt;class
charT, class Traits, class Allocator></font><font face=""> implement the
in-memory I/O, i.e., they associate the input and output sequences with
a memory location.</font></font>
<p><font face=""><font size=-1>&nbsp;The following sections describe first
the principles of the stream buffer abstraction in general and then the
concrete mechanisms for each of the derived stream buffer classes. We concentrate
on the main functionality of stream buffers, namely input, output, and
putback. Other aspects such as positioning and locale management are omitted,
but can be looked up in the reference part of this book if needed.</font></font>
<p><font face=""><font size=-1>&nbsp;<b>The Stream Buffer Abstraction</b></font></font>
<br><font face=""><font size=-1>Two character sequences are associated
with a stream buffer: the input sequence and the output sequence, which
represents the external device. Internally a stream buffer maintains a
character array for buffering the input and/or output sequence. If the
entire sequence does not fit into this character array, which naturally
is of limited length, the buffer represents a subsequence of the input
and/or output sequence. This way the internal buffer can be seen as a window
to the input and/or output sequence (see figure 2-6).</font></font>
<p><img SRC="fig02-06.jpg" ALT="Figure 2-6" BORDER=0 height=175 width=507>
<br><i><font face=""><font size=-1><b>Figure 2-6:</b> The stream buffer
represents a subsequence of the external character sequence.</font></font></i>
<p><font face=""><font size=-1>&nbsp;The input (sub)sequence, which is
kept in the character array, is called the <i>get area;</i> the output
(sub)sequence is called the <i>put area.</i> Each (sub)sequence, the input
as well as the output sequence, is described by three pointers: (1) the
<i>begin_pointer,</i>
which is the address of the lowest element in the area, (2) the <i>next_pointer,</i>
which is the address of the element that is the next candidate for reading
or writing, and (3) the <i>end-pointer,</i> which is the address of the
next element beyond the end of the area.</font></font>
<p><font face=""><font size=-1>&nbsp;If an area is not available, the next_pointer
is null. The way in which input and out-put areas are related is unspecified
for the stream buffer base class. All you know is that there are two areas,
each of which is described by three pointers and represents a (sub)sequence
of the external device.</font></font>
<p><font face=""><font size=-1>&nbsp;The interface of the stream buffer
base class falls into three parts:</font></font>
<br>&nbsp;
<br>&nbsp;
<ol>
<li>
<font face=""><font size=-1><i>Public.</i> These functions are used by
the streams for implementing their functionality on top of the stream buffer.</font></font></li>

<li>
<font face=""><font size=-1><i>Protected nonvirtual.</i> These functions
are used for implementing the stream buffer's public interface.</font></font></li>

<li>
<font face=""><font size=-1><i>Protected virtual.</i> These functions are
meant to be overridden by any derived stream buffer classes.</font></font></li>
</ol>
<font face=""><font size=-1>The protected virtual interface of a stream
buffer class provides operations that access the external character sequence.<sup><a href="#1">
1</a> </sup>Such operations</font></font>
<br>&nbsp;
<br>&nbsp;
<ul>
<li>
<font size=-1><font face="">perform reads directly on the associated input
(sub)sequence (</font><font face="Courier">xsgetn()</font><font face="">
, </font><font face="Courier">underflow()</font><font face="">, </font><font face="Courier">uflow()</font><font face="">,
etc.), or</font></font></li>

<li>
<font size=-1><font face="">perform writes directly on the associated output
(sub)sequence (</font><font face="Courier">xsputn()</font><font face="">
, </font><font face="Courier">overflow()</font><font face="">),</font></font></li>

<li>
<font size=-1><font face="">make put back positions available in the input
(sub)sequence (</font><font face="Courier">pbackfail()</font><font face="">
), and</font></font></li>

<li>
<font size=-1><font face="">alter "the stream position" and conversion
state (</font><font face="Courier">seekoff()</font><font face="">, </font><font face="Courier">seekpos()</font><font face="">).</font></font></li>
</ul>
<font face=""><font size=-1>The protected nonvirtual interface of a stream
buffer class provides operations that manipulate one or both of the internal
sequences. Such operations</font></font>
<br>&nbsp;
<br>&nbsp;
<ul>
<li>
<font size=-1><font face="">retrieve the values of the pointers (the get
area's begin_, next_, and end_pointer via </font><font face="Courier">eback()</font><font face="">,
</font><font face="Courier">gptr()</font><font face="">
, </font><font face="Courier">egptr()</font><font face="">, and the put
area's begin_, next_, and end_pointer via </font><font face="Courier">pbase()</font><font face="">
, </font><font face="Courier">pptr()</font><font face="">, </font><font face="Courier">epptr()</font><font face="">),</font></font></li>

<li>
<font size=-1><font face="">alter the value of the pointers (by assigning
new pointers via </font><font face="Courier">setg()</font><font face="">
, </font><font face="Courier">setp()</font><font face="">, or by incrementing
the next_pointer via </font><font face="Courier">gbump()</font><font face="">
, </font><font face="Courier">pbump()</font><font face="">).</font></font></li>
</ul>
<font face=""><font size=-1>The public interface is built on top of the
protected interface and is used by the stream layer to implement its operations.
The stream buffer's public interface includes operations for extraction
and insertion of characters from/to the get/put area, stream positioning,
and other functionality:</font></font>
<br>&nbsp;
<br>&nbsp;
<ul>
<li>
<font size=-1><font face="">extract characters from the get area (</font><font face="Courier">sgetc()</font><font face="">,
</font><font face="Courier">sgetn()</font><font face="">,
</font><font face="Courier">sbumpc()</font><font face="">
, etc.)</font></font></li>

<li>
<font size=-1><font face="">insert characters to the put area (</font><font face="Courier">
sputc()</font><font face="">, </font><font face="Courier">sputn()</font><font face="">
, etc.)</font></font></li>

<li>
<font size=-1><font face="">put back characters to the get area (</font><font face="Courier">sputbackc()</font><font face="">,
</font><font face="Courier">sungetc()</font><font face="">)</font></font></li>

<li>
<font size=-1><font face="">stream positioning (</font><font face="Courier">
pubseekoff()</font><font face="">, </font><font face="Courier">pubseekpos()</font><font face="">
).</font></font></li>
</ul>
<font face=""><font size=-1>In addition to the functions mentioned above,
stream buffers have a couple of other member functions. Only the most important
and typical functions are listed above. For a complete description of the
stream buffer base class's interface, see the reference section. Also,
section 3.4, Adding Stream Buffer Functionality, provides more details
on the protected interface.</font></font>
<p><font face=""><font size=-1>&nbsp;A note on the stream buffer classes'
constructors and destructors:</font></font>
<br>&nbsp;
<br>&nbsp;
<ul>
<li>
<font face=""><font size=-1>The stream buffer base class's destructor is
public and virtual, as is usual for a class that is designed to serve as
a base class.</font></font></li>

<li>
<font face=""><font size=-1>The stream buffer base class has only one constructor,
which is a protected default constructor. This is to ensure that only derived
stream buffer objects may be constructed. The concrete stream buffer classes,
of course, have public constructors.</font></font></li>
</ul>
<font face=""><font size=-1>Neither the copy constructor nor the copy assignment
for any of the stream buffer classes is specified by the standard. In particular,
it is not required that they are inaccessible. They will most likely not
be implemented at all, which means that the compiler-generated default
functionality for copying and assignment will apply. As a consequence,
stream buffers, which contain pointers to their get and put areas, <i>can</i>
be copied and assigned, meaning that the internally held pointers will
be copied. Two stream buffer objects that are copies of each other would
operate on the same character array without any coordination. The results
are likely to be unpredictable. For this reason, avoid inadvertent copies
or assignments of stream buffer objects.</font></font>
<p><font face=""><font size=-1>&nbsp;Let's return to the stream buffer's
core functionality and look at the principles of handling character input
and output in the stream buffer classes.</font></font>
<p><font face=""><font size=-1>&nbsp;<b>EXTRACTING INTPUT FROM THE INPUT
SEQUENCE</b></font></font>
<br><font size=-1><font face="">A character can be requested from the input
sequence by calling the stream buffer's public member function </font><font face="Courier">sgetc()</font><font face="">.
If the get area exists and is not empty, i.e., next_pointer != 0 and next_pointer
&lt; end_pointer, the next character from the get area is returned. If
the get area does not exist or is empty, the protected virtual member function
</font><font face="Courier">underflow()</font><font face="">
is called.</font></font>
<p><font size=-1><font face="">&nbsp;Alternatively, a character can be
requested from the input sequence via the stream buffer's public member
function </font><font face="Courier">sbumpc()</font><font face="">. In
addition to the functionality of </font><font face="Courier">sgetc()</font><font face="">
, namely, extraction of a character from the input sequence, </font><font face="Courier">sbumpc()</font><font face="">
also advances the read position. The effect is that the character extracted
after a call to </font><font face="Courier">sbumpc()</font><font face="">
is the character at the next read position, whereas after a call to </font><font face="Courier">sgetc()</font><font face="">
the same character will be returned again. Roughly speaking, </font><font face="Courier">sgetc()</font><font face="">
means "looking at the available character" and </font><font face="Courier">sbumpc()</font><font face="">
means "consuming the available character." If the get area does not exist
or is empty, then </font><font face="Courier">sbumpc()</font><font face="">
invokes the protected virtual member function </font><font face="Courier">uflow()</font><font face="">
, which is the counterpart to </font><font face="Courier">underflow()</font><font face="">
in the case of </font><font face="Courier">sgetc()</font><font face="">.</font></font>
<p><font size=-1><font face="">&nbsp;In the stream buffer base class </font><font face="Courier">basic_streambuf</font><font face="">,
the virtual function </font><font face="Courier">uflow()</font><font face="">
is implemented in terms of </font><font face="Courier">underflow()</font><font face="">
: It invokes </font><font face="Courier">underflow()</font><font face="">
and increments the get area's next pointer. This is a sensible default
behavior that works nicely for stream buffers that have an internal character
buffer. In fact, neither file buffers nor string buffers override this
default behavior of </font><font face="Courier">uflow()</font><font face="">,
but only redefine </font><font face="Courier">underflow()</font><font face="">.
For this reason, we focus on the functionality of </font><font face="Courier">underflow()</font><font face="">
in the rest of this section.</font></font>
<p><font size=-1><font face="">&nbsp;The general purpose of </font><font face="Courier">underflow()</font><font face="">
is to make additional characters from the external sequence available in
the internal buffer; in other words, it fills (all or part of) the get
area with characters taken from the external device.</font></font>
<p><font size=-1><font face="">&nbsp;<b>BASE CLASS.</b> For the stream
buffer base class, </font><font face="Courier">basic_streambuf</font><font face="">
, </font><font face="Courier">underflow()</font><font face=""> is in a
nonoperational mode; its implementation returns </font><font face="Courier">traits::eof()</font><font face="">
, which indicates that the end of the stream is reached. Any useful behavior
of </font><font face="Courier">underflow()</font><font face=""> fully depends
on the characteristics of the external device, and </font><font face="Courier">underflow()</font><font face="">
is well defined for the derived stream buffer classes, which redefine this
virtual function. The functionality of </font><font face="Courier">uflow()</font><font face="">
is that of </font><font face="Courier">underflow()</font><font face="">
plus advancing the read position.</font></font>
<p><font size=-1><font face="">&nbsp;<b>STRING BUFFER.</b> A string buffer
cannot make additional characters available from an external device, because
string streams are not connected to an external character sequence.<sup><a href="#2">
2</a> </sup>A string stream buffer can make characters available for reading
only when they have previously been stored in the internal buffer, for
instance, as a result of a previous output operation. Such characters are
made accessible by adjusting the get area pointers; more precisely, the
get area's end pointer must be moved forward to include additional positions.
This pointer adjustment can be done in </font><font face="Courier">underflow()</font><font face="">
or </font><font face="Courier">uflow()</font><font face=""> as part of
an input operation. Alternatively, it can be performed during </font><font face="Courier">overflow()</font><font face="">
as part of an output operation. The standard allows both implementations.</font></font>
<p><font size=-1><font face="">&nbsp;<b>FILE BUFFER.</b> A file buffer's
</font><font face="Courier">underflow()</font><font face="">
function makes additional characters available by reading new characters
from the file. It then converts them to the internal character representation
(if necessary), writes the result of the conversion into the get area,
and returns the first newly read character.</font></font>
<p><font face=""><font size=-1>&nbsp;<b>INSERTING OUTPUT TO THE OUTPUT
SEQUENCE</b></font></font>
<br><font size=-1><font face="">A character is written to the output sequence
via the public member function </font><font face="Courier">sputc()</font><font face="">
. As an argument to </font><font face="Courier">sputc()</font><font face="">
the stream buffer receives a character to be inserted into the output sequence.
If the put area exits and it is not already full, i.e., next_pointer !=
0 and next_pointer &lt; end_pointer, then the character is put to the position
the next_pointer is referring to, and the next_pointer is incremented.
If the put area does not exist or is full, then the protected member function
</font><font face="Courier">overflow()</font><font face="">
is called, taking the character as an argument.</font></font>
<p><font size=-1><font face="">&nbsp;The general notion of </font><font face="Courier">overflow()</font><font face="">
is to make positions in the internal buffer available by writing characters
to the external sequence, in other words, it empties (all or part of) the
put area by writing characters to the external device. If the character
received as an argument to </font><font face="Courier">overflow()</font><font face="">
does not equal end-of-file, this character is placed into the "fresh" internal
buffer; otherwise no additional character is placed into the put area.</font></font>
<p><font size=-1><font face="">&nbsp;<b>BASE CLASS.</b> For the stream
buffer base class, </font><font face="Courier">basic_streambuf</font><font face="">
, </font><font face="Courier">overflow()</font><font face=""> is in a nonoperational
mode; its implementation returns </font><font face="Courier">traits::eof()</font><font face="">
, which indicates that the end of the stream is reached. Any useful behavior
of </font><font face="Courier">overflow()</font><font face=""> fully depends
on the characteristics of the external device, and </font><font face="Courier">overflow()</font><font face="">
is well defined for the derived classes, which override this virtual function.</font></font>
<p><font size=-1><font face="">&nbsp;<b>STRING BUFFER.</b> String buffers
make positions in their internal buffer available by extending the buffer.
The </font><font face="Courier">overflow()</font><font face=""> function
reallocates a new, larger character array. Then the character passed to
</font><font face="Courier">overflow()</font><font face="">
as an argument is added to the put area, and the get area's end pointer
might be adjusted to include this new character.<sup><a href="#3"> 3</a></sup></font></font>
<p><font size=-1><font face="">&nbsp;<b>FILE BUFFER.</b> A file buffer
makes positions in its internal buffer available by writing to the external
file. To be precise, it converts the characters contained in the put area
to the external character representation (if necessary) and writes the
result of the conversion to the file. After that it puts the character
that was received as an argument to </font><font face="Courier">overflow()</font><font face="">
into the (fully or partly) emptied put area, unless it was equal to end-of-file.</font></font>
<p><font face=""><font size=-1>&nbsp;<b>PUTTING BACK CHARACTERS TO THE
INPUT SEQUENCE</b></font></font>
<br><font size=-1><font face="">The stream buffer's public interface provides
two function for putting back characters to the input sequence: </font><font face="Courier">sputbackc()</font><font face="">
and </font><font face="Courier">sungetc()</font><font face="">.</font></font>
<p><font size=-1><font face="">&nbsp;</font><font face="Courier"> sputbackc()</font><font face="">
receives a character as an argument. This character is to be put back to
the input sequence, that is, stored in the input sequence before the current
read position. If the get area exits and characters have already been read,
i.e., next_pointer != 0 and begin_pointer &lt; next_pointer, a putback
position is available. In this case, the character is stored in the position
before the one the next_pointer currently refers to, and the next_pointer
is decreased so that it points to this previous position.</font></font>
<p><font size=-1><font face="">&nbsp;</font><font face="Courier"> sungetc()</font><font face="">
does not take an argument, but simply decrements the current read position,
which has the effect of putting back the previously extracted character.
No actual write access to the input sequence takes place, only the next_pointer
is moved one position back.</font></font>
<p><font size=-1><font face="">&nbsp;</font><font face="Courier"> pbackfail()</font><font face="">
is a protected member function that stores a character at the previous
position in the input sequence and makes available additional putback positions.</font></font>
<p><font size=-1><font face="">&nbsp;Both </font><font face="Courier">sputbackc()</font><font face="">
and </font><font face="Courier">sungetc()</font><font face=""> call the
protected member function </font><font face="Courier">pbackfail()</font><font face="">
. </font><font face="Courier">sungetc()</font><font face=""> uses the second
functionality of </font><font face="Courier">pbackfail()</font><font face="">
and invokes it, if the get area does not exist (i.e., next_pointer == 0)
or if no putback position is available (i.e., begin_pointer == next_pointer).
</font><font face="Courier">sputbackc()</font><font face="">
uses both features of </font><font face="Courier">pbackfail()</font><font face="">
. It invokes </font><font face="Courier">pbackfail()</font><font face="">
when no putback position is available and when a character is put back
that is different from the previously extracted one, that is, when an actual
write access to the input sequence is required.</font></font>
<p><font size=-1><font face="">&nbsp;The general notion of </font><font face="Courier">pbackfail()</font><font face="">
is: (1) to store the character received as argument at the previous position,
and to adjust the get area pointers so that the next read request will
return the character that was put back, and (2) to make a putback position
available in the internal buffer.</font></font>
<p><font size=-1><font face="">&nbsp;<b>BASE CLASS.</b> For the stream
buffer base class </font><font face="Courier">basic_streambuf</font><font face="">
, </font><font face="Courier">pbackfail()</font><font face=""> is in a
nonoperational mode; its implementation returns </font><font face="Courier">traits::eof()</font><font face="">
, which indicates failure. Any useful behavior fully depends on the characteristics
of the external device, and </font><font face="Courier">pbackfail()</font><font face="">
is well defined for the derived classes, which override this virtual function.</font></font>
<p><font size=-1><font face="">&nbsp;<b>STRING BUFFER.</b> For string stream
buffers, only the functionality (1) of </font><font face="Courier">pbackfail()</font><font face="">,
storing a character in the input sequence, is implemented. The next_pointer
is decreased, and if the character to be put back is not the previously
extracted one, the new character is stored at that position.</font></font>
<p><font size=-1><font face="">&nbsp;Functionality (2), making available
additional putback positions, does not make sense for a string stream buffer.
Putback positions are available only if characters have previously been
extracted from the string. When there are no previously extracted characters,
</font><font face="Courier">pbackfail()</font><font face="">
cannot make any available either.</font></font>
<p><font face=""><font size=-1>&nbsp;<b>FILE BUFFER.</b> For file stream
buffers, functionality (1), storing a character in the input sequence,
is implemented in the same way as for string stream buffers. The next_pointer
is decreased, and if the character to be put back is not the previously
extracted one, the new character is stored at that position. A file buffer
might fail to actually store the character, because the associated file
was opened only for input and does not allow write access.</font></font>
<p><font face=""><font size=-1>&nbsp;Functionality (2), making available
additional putback positions, is implemented-dependent. For a file stream
buffer it is conceivable that additional putback positions are made available
by reloading characters from the external file. The standard, however,
does not specify any implementation details.<sup><a href="#4">4</a></sup></font></font>
<p><font face=""><font size=-1>&nbsp;The subsequent two sections describe
the behavior of the string buffers and file buffer in terms of an example.
We explain in detail how input and output sequence, the internal character
buffer, and the get and put areas are related to each other for these two
derived classes. The third section describes the principle of the putback
area, which is basically the same for string buffers and file buffers.</font></font>
<p><font face=""><font size=-1>&nbsp;In order to show the principles, we
make assumptions about the implementation of these classes. Standard compatible
implementations, however, are allowed to differ and may work in a slightly
different way than demonstrated in the following. Still, the general principles
will be the same. The implementations of string buffers and file buffers
override the virtual functions discussed above in order to achieve the
results that we are going to describe. In the following, we do not aim
to explain exactly how each of the virtual functions is redefined, but
we intend to explain the overall net effect. Details of how to redefine
which of the virtual functions, and under which circumstances, are discussed
in section 3.4, Adding Stream Buffer Functionality.</font></font>
<br>&nbsp;
<br>&nbsp;
<p><b><font face=""><font size=-1>String Stream Buffers</font></font></b>
<br><font face=""><font size=-1>A string stream buffer maintains an internal
buffer that is large enough to hold the entire external sequence; the get
area contains the entire input sequence, and the put area represents the
entire output sequence.</font></font>
<p><font face=""><font size=-1>&nbsp;The get and put areas are related
and available simultaneously. Figure 2-7 shows a typical situation:</font></font>
<p><img SRC="fig02-07.jpg" ALT="Figure 2-7" BORDER=0 height=231 width=521>
<br><i><font face=""><font size=-1><b>Figure 2-7:</b> Get and put area
of a string stream buffer.</font></font></i>
<p><font face=""><font size=-1>&nbsp;In this example the capacity of the
internal character buffer is 16 characters, which is utterly unrealistic
for real implementations. We do this on purpose, in order to keep the example
simple yet demonstrate the crucial case of what happens if the buffer is
full or empty.</font></font>
<p><font size=-1><font face="">&nbsp;The character sequence </font><font face="Courier">Hello
World\n</font><font face=""> has been written to the output sequence, and
the pointers of the put area are assigned in the following way:</font></font>
<br>&nbsp;
<br>&nbsp;
<pre><font face=""><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin_pointer to the beginning of the character array

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next_pointer to the next empty position behind the text written to the output sequence

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end_pointer to the next position behind the character array</font></font>

</pre>
<font size=-1><font face="">The character sequence </font><font face="Courier">Hello</font><font face="">
has already been read from the input sequence, and the pointers of the
get area are assigned in the following way:</font></font>
<br>&nbsp;
<br>&nbsp;
<pre><font face=""><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin_pointer to the beginning of the character array

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next_pointer to the next position behind the text already read from the input sequence

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end_pointer to the same positions as the put area's next_pointer, because it is not&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; possible to read text that has not already been written</font></font>

</pre>
<font face=""><font size=-1>Let us discuss the effect of input and output
operations on the string stream buffer starting from the situation described
above.</font></font>
<p><font face=""><font size=-1>&nbsp;<b>OUTPUT</b></font></font>
<br><font face=""><font size=-1><b>"NORMAL" SITUATION.</b> In this situation
we write an additional character to the string stream buffer. The put area's
next_pointer refers to the next available position in the put area. Hence
the additional character is put to the position the put area's next_pointer
refers to. Afterwards the next_pointer is incremented, so that it points
to the next available position.</font></font>
<p><font face=""><font size=-1>&nbsp;<b>"OVERFLOW" SITUATION.</b> If we
keep on adding characters to the string stream buffer, the put area will
eventually be full. When the internal buffer is full, the put area's next_pointer
points to the end of the buffer area, i.e., next_pointer == end_pointer.
Figure 2-8 illustrates this situation:</font></font>
<p><img SRC="fig02-08.jpg" ALT="Figure 2-8" BORDER=0 height=231 width=521>
<br><i><font face=""><font size=-1><b>Figure 2-8:</b> String stream buffer
is full after output.</font></font></i>
<p><font size=-1><font face="">&nbsp;This situation is special, because
the internal buffer is full. If we want to write an additional character,
the string stream buffer needs to make available a new position in the
put area. This is achieved by calling </font><font face="Courier">overflow()</font><font face="">
. The function </font><font face="Courier">overflow()</font><font face="">
acquires a new character array that can hold more characters. Figure 2-9
shows the situation after the call to </font><font face="Courier">overflow()</font><font face="">
:</font></font>
<p><img SRC="fig02-09.jpg" ALT="Figure 2-9" BORDER=0 height=231 width=521>
<br><font size=-1><i><font face=""><b>Figure 2-9:</b> String stream buffer
after call to</font></i><font face=""> </font><font face="Courier">overflow()</font><font face="">.</font></font>
<p><font face=""><font size=-1>&nbsp;Afterwards the new character is put
into the new position in the put area and the put area's next_pointer is
incremented as always.</font></font>
<p><font face=""><font size=-1>&nbsp;<b>INPUT</b></font></font>
<br><font size=-1><font face="">During all these output operations on the
string stream buffer the input area basically did not change. After the
reallocation of the internal buffer due to the </font><font face="Courier">overflow()</font><font face="">,
the get area's pointers are reassigned to the same positions relative to
each other.</font></font>
<p><font face=""><font size=-1>&nbsp;<b>"NORMAL" SITUATION.</b> If we read
a character from the string stream buffer, we receive the character that
the get area's next_pointer refers to. Considering the situation in figure
2-10, this is a whitespace character. Afterwards the get area's next_pointer
is incremented.</font></font>
<p><img SRC="fig02-10.jpg" ALT="Figure 2-10" BORDER=0 height=231 width=521>
<br><i><font face=""><font size=-1><b>Figure 2-10:</b> String stream buffer
before input.</font></font></i>
<p><font face=""><font size=-1>&nbsp;<b>"UNDERFLOW" SITUATION.</b> Let
us assume that we keep on extracting characters from the string stream
buffer and there is no intervening insertion; i.e., the put area does not
change. We will ultimately reach the end of the get area, i.e., next_pointer
== end_pointer, as shown in figure 2-11.</font></font>
<p><img SRC="fig02-11.jpg" ALT="Figure 2-11" BORDER=0 height=231 width=521>
<br><i><font face=""><font size=-1><b>Figure 2-11:</b> String stream buffer
with exhausted get area.</font></font></i>
<p><font size=-1><font face="">&nbsp;If we now try to read a new character
from the string stream buffer, </font><font face="Courier">underflow()</font><font face="">
is called in order to make additional characters available for reading.
</font><font face="Courier">underflow()</font><font face="">
adjusts the get area's end_pointer so that it points to the same positions
as the put area's next_pointer. In this way, all previously written characters
are made available for subsequent read attempts. If all previously written
characters have already been read and the get area's end_pointer equals
the put area's end pointer, </font><font face="Courier">underflow()</font><font face="">
fails. In the situation shown in figure 2-11, additional characters can
be made available, and </font><font face="Courier">underflow()</font><font face="">
adjusts the get area's end_pointer as shown in figure 2-12:</font></font>
<p><img SRC="fig02-12.jpg" ALT="Figure 2-12" BORDER=0 height=231 width=521>
<br><font size=-1><i><font face=""><b>Figure 2-12:</b> String stream buffer
after call to</font></i><font face=""> </font><font face="Courier">underflow()</font><font face="">.</font></font>
<p><font size=-1><font face="">&nbsp;<b>DISCLAIMER.</b> The model explained
above is just one of many ways to implement a string buffer. As an alternative,
</font><font face="Courier">overflow()</font><font face="">
could allocate a new buffer area that holds exactly one additional position
and adjusts not only the put area's pointers but also the get area's end_pointer.
In this way each character written is immediately available for reading,
without any pointer adjustment performed via </font><font face="Courier">underflow()</font><font face="">
as in the example above. In this alternative model, </font><font face="Courier">underflow()</font><font face="">
need not be redefined at all. Naturally, this solution is less efficient
than the one described before, because the internal character buffer is
always full and must be reallocated for each single character written to
the string stream.</font></font>
<p><font face=""><font size=-1>&nbsp;<b>PUTBACK</b></font></font>
<br><font face=""><font size=-1>Figure 2-13 shows a typical situation in
which a number of characters have already been read from the input sequence.
In this situation, characters can be put back to the input sequence.</font></font>
<p><img SRC="fig02-13.jpg" ALT="Figure 2-13" BORDER=0 height=231 width=521>
<br><i><font face=""><font size=-1><b>Figure 2-13:</b> String stream buffer
before putback.</font></font></i>
<p><font size=-1><font face="">&nbsp;Only the get area is relevant to our
discussion of the putback support; the pointers of the put area are not
affected at all. The string </font><font face="Courier">Hello</font><font face="">
has been extracted, and the get area's next_pointer points to the next
available read position. If a character is now requested via </font><font face="Courier">sbumpc()</font><font face="">,
the next character (the blank between </font><font face="Courier">Hello</font><font face="">
and </font><font face="Courier">World\n</font><font face=""> ) is extracted
and afterwards the next_pointer points to the character </font><font face="Courier">W</font><font face="">.</font></font>
<p><font size=-1><font face="">&nbsp;<b>"NORMAL" SITUATION.</b> Let us
see what happens if we then call </font><font face="Courier">sungetc()</font><font face="">
, with the intention of putting back the just extracted character, which
was the blank. In this case the get area's next_pointer is simply decremented
and points to the blank again. The next extraction would again return the
blank character, which means that the previous extraction was reversed
by the call to </font><font face="Courier">sungetc()</font><font face="">.
A further call to </font><font face="Courier">sungetc()</font><font face="">
would decrement the next_pointer even further and make available the character
</font><font face="Courier">o</font><font face="">
for a subsequent read operation.</font></font>
<p><font size=-1><font face="">&nbsp;<b>"PBACKFAIL" SITUATION.</b> What
if, in that situation, </font><font face="Courier">sputbackc('l')</font><font face="">
is called instead of </font><font face="Courier">sungetc()</font><font face="">
? The function </font><font face="Courier">sungetc()</font><font face="">
is supposed to make available the character </font><font face="Courier">o</font><font face="">,
whereas </font><font face="Courier">sputbackc('l')</font><font face="">
should override the character </font><font face="Courier">o</font><font face="">
and put back the character </font><font face="Courier">l</font><font face="">
in its position. As the character that is put back is different from the
character that was extracted from this position, the function </font><font face="Courier">pbackfail()</font><font face="">
is called, and </font><font face="Courier">pbackfail()</font><font face="">
performs the write access to the get area and overrides the character </font><font face="Courier">o</font><font face="">
.<sup><a href="#5">5</a> </sup>The situation after </font><font face="Courier">sputbackc('l')</font><font face="">
looks like the one in figure 2-14.</font></font>
<p><img SRC="fig02-14.jpg" ALT="Figure 2-14" BORDER=0 height=231 width=521>
<br><font size=-1><i><font face=""><b>Figure 2-14:</b> String stream buffer
after putting back the character</font></i><font face=""> </font><font face="Courier">1</font><font face="">.</font></font>
<p><font size=-1><font face="">&nbsp;<b>ANOTHER "PBACKFAIL" SITUATION.</b>
We can keep on putting back characters via </font><font face="Courier">sputbackc()</font><font face="">
or </font><font face="Courier">sungetc()</font><font face=""> until we
hit the beginning of the get area, as shown in figure 2-15. The next attempt
to put back a character triggers </font><font face="Courier">pbackfail()</font><font face="">
, which is supposed to make further putback positions available. The get
area's next_pointer cannot be decremented any further, and </font><font face="Courier">pbackfail()</font><font face="">
indicates failure. Only if characters are read from the get area will putback
positions become available again.</font></font>
<p><img SRC="fig02-15.jpg" ALT="Figure 2-15" BORDER=0 height=231 width=521>
<br><i><font face=""><font size=-1><b>Figure 2-15:</b> String stream buffer
with the putback position available.</font></font></i>
<p><font size=-1><font face="">&nbsp;Note that the put area's pointers
are not affected by any of the putback operations. However, overwriting
characters in the get area by means of </font><font face="Courier">sputbackc()</font><font face="">
changes the content of the internal buffer, much like an output operation.
The modifications will be visible when the content of the string buffer
is retrieved via </font><font face="Courier">str()</font><font face="">,
for instance.</font></font>
<p><font face=""><font size=-1>&nbsp;<b>File Stream Buffers</b></font></font>
<br><font face=""><font size=-1>For a file buffer the internal character
buffer is usually smaller than the external sequences; i.e., the internal
buffer normally holds only subsequences of the external sequence as get
and put areas.<sup><a href="#6">6</a></sup></font></font>
<p><font face=""><font size=-1>&nbsp;It is implementation-defined, how
large the internal buffer is, whether the file stream buffer maintains
two separate character arrays to represent the get and put areas respectively,
or whether there is a shared internal character array for both areas. The
assumed sample implementation we present in the following sections is one
of a variety of conceivable implementations of a file stream buffer. Your
particular implementation might have implemented a different scheme.</font></font>
<p><font face=""><font size=-1>&nbsp;In our assumed implementation, the
file stream buffer maintains only one internal character array, which is
of a fixed size and too small to hold the entire content of the external
character sequences. For this reason, the internal character array holds
only a subsequence of the input sequence in the get area and a subsequence
of the output sequence in the put area. Logically, both the put and get
areas are present simultaneously; in practice only one of them can be active
at a time, because the file stream buffer has only one internal character
buffer: During output operations, the internal character array represents
the put area, and the get area is inactive; During input operations, the
internal character array represents the get area, and the put area is inactive.</font></font>
<p><font face=""><font size=-1>&nbsp;The respective inactive area does
logically exist, but it may not be immediately accessible. If, for instance,
the get area is active, no output operation should be triggered, because
it would need access to the currently inactive put area. An output operation
can only follow an input operation if the file is repositioned in between,
which puts the file stream buffer into a neutral state, from which it can
reactivate the put area and make its content available in the internal
buffer.</font></font>
<p><font face=""><font size=-1>&nbsp;Let us first explore input and output
separately before we discuss the scheme for exchanging the get and put
areas while switching from input to output and vice versa.</font></font>
<p><font face=""><font size=-1>&nbsp;<b>OUTPUT</b></font></font>
<br><font face=""><font size=-1>Initially, neither the put nor the get
area is available. An area is considered unavailable when its next_pointer
is zero. The begin_pointer and the end_pointer are undefined when the next_pointer
is zero; they can also be zero or have any other arbitrary value. The content
of the internal character buffer is undefined, too, in this situation;
it might be empty, filled with garbage, or not even allocated. Figure 2-16
shows this neutral situation.</font></font>
<p><img SRC="fig02-16.jpg" ALT="Figure 2-16" BORDER=0 height=231 width=521>
<br><i><font face=""><font size=-1><b>Figure 2-16:</b> File stream buffer
in neutral state.</font></font></i>
<br>&nbsp;
<p><font size=-1><font face="">Any output request in that neutral situation
triggers </font><font face="Courier">overflow()</font><font face=""> ,
which activates the put area, places the first character into the internal
character buffer, and adjusts the put area's pointers. Afterwards, the
internal buffer area is filled with the remaining characters that were
passed to the output operation, and the next_pointer is advanced accordingly.
Figure 2-17 shows the situation after output of the string </font><font face="Courier">Hello
World\n</font><font face="">.</font></font>
<p><img SRC="fig02-17.jpg" ALT="Figure 2-17" BORDER=0 height=231 width=521>
<br><i><font face=""><font size=-1><b>Figure 2-17:</b> File stream buffer
after an output operation.</font></font></i>
<p><font size=-1><font face="">&nbsp;If we keep on writing output to the
file stream buffer, the put area's next_pointer will eventually hit the
end_pointer. Then </font><font face="Courier">overflow()</font><font face="">
is called again in order to make available additional put positions. </font><font face="Courier">overflow()</font><font face="">
achieves this by transferring data from the internal buffer via code conversion
(if necessary) to the external file. It is implementation-dependent whether
all or only parts of the data in the internal buffer are transferred to
the external file. The standard requires only that </font><font face="Courier">overflow()</font><font face="">
make "enough" positions available in the buffer; it does not specify how
many positions. For our sample implementation, we assume that the entire
internal character buffer is written to the external file. Afterwards,
</font><font face="Courier">overflow()</font><font face="">
stores the first character in the internal character buffer and adjusts
the put area pointers as shown in figure 2-18.</font></font>
<p><img SRC="fig02-18.jpg" ALT="Figure 2-18" BORDER=0 height=231 width=521>
<br><font size=-1><i><font face=""><b>Figure 2-18:</b> File stream buffer
immediately after</font></i><font face=""> </font><font face="Courier">overflow()</font><font face="">.</font></font>
<p><font size=-1><font face="">&nbsp;Now there is plenty of room in the
put area for further output, and the output request that triggered </font><font face="Courier">overflow()</font><font face="">
can be completed.</font></font>
<p><font size=-1><font face="">&nbsp;The character sequence that is transferred
from the internal character buffer to the external file during </font><font face="Courier">overflow()</font><font face="">
is placed into successive locations on the external file starting at the
current external file position. Where the external file position indicator
stands depends on the circumstances.</font></font>
<p><font size=-1><font face="">&nbsp;Immediately after a file stream buffer
is connected to an external file (via </font><font face="Courier">open()</font><font face="">),
the external file position indicator is either at the beginning of the
file, which is the default situation, or at the end of the file, if the
open mode included the at-end flag.</font></font>
<p><font size=-1><font face="">&nbsp;After preceding output operations
(via </font><font face="Courier">sputc()</font><font face="">, </font><font face="Courier">sputn()</font><font face="">),
the external file position indicator stands where the last output operation
left it.</font></font>
<p><font size=-1><font face="">&nbsp;After an explicit repositioning of
the stream position (via </font><font face="Courier">seekoff()</font><font face="">
, </font><font face="Courier">seekpos()</font><font face="">), the external
file position indicator is reset to a corresponding position in the external
file.</font></font>
<p><font face=""><font size=-1>&nbsp;If the open mode includes the append
flag, the external file position indicator stands at the end of the file
and cannot be repositioned to any other position.</font></font>
<p><font face=""><font size=-1>&nbsp;<b>INPUT</b></font></font>
<br><font face=""><font size=-1>Input, like output, starts with a neutral
situation, in which neither get nor put areas are active. Figure 2-19 shows
this neutral situation.<sup><a href="#7">7</a></sup></font></font>
<p><img SRC="fig02-19.jpg" ALT="Figure 2-19" BORDER=0 height=231 width=521>
<br><i><font face=""><font size=-1><b>Figure 2-19:</b> File stream buffer
in neutral state.</font></font></i>
<p><font size=-1><font face="">&nbsp;An input request in this situation
triggers </font><font face="Courier">underflow()</font><font face=""> in
order to make available get positions for reading. This is achieved by
transferring data from the external file via code conversion (if necessary)
to the internal character buffer. It is implementation-dependent whether
</font><font face="Courier">underflow()</font><font face="">
fills the entire internal buffer or only a part of it with characters transferred
from
the external file. In our sample implementation we assume that </font><font face="Courier">underflow()</font><font face="">
fills the entire internal buffer if possible. The get area is activated,
and the get area's pointers are adjusted. Figure 2-20 shows the situation
after the invocation of </font><font face="Courier">underflow()</font><font face="">
.</font></font>
<p><img SRC="fig02-20.jpg" ALT="Figure 2-20" BORDER=0 height=231 width=521>
<br><font size=-1><i><font face=""><b>Figure 2-20:</b> File stream buffer
immediately after</font></i><font face=""> </font><font face="Courier">underflow()</font><font face="">.</font></font>
<p><font size=-1><font face="">&nbsp;This is the situation after requesting
the first character from the file stream via </font><font face="Courier">sgetc()</font><font face="">.
Had we extracted the character via </font><font face="Courier">sbumpc()</font><font face="">
instead of </font><font face="Courier">sgetc()</font><font face=""> , </font><font face="Courier">uflow()</font><font face="">
would have been called instead of </font><font face="Courier">underflow()</font><font face="">
, with basically the same result. The only difference would be that the
put area's next_pointer would be advanced by one position and point the
next available read position.</font></font>
<p><font size=-1><font face="">&nbsp;If we keep on requesting input from
the file stream buffer, the get area's next_pointer will eventually hit
the end of the internal buffer. </font><font face="Courier">underflow()</font><font face="">
or </font><font face="Courier">uflow()</font><font face=""> will then be
triggered again. These operations discard the current content of the internal
character buffer and transfer the next sequence of characters from the
external file into the internal buffer.</font></font>
<p><font size=-1><font face="">&nbsp;The character sequence that is transferred
from the external file to the internal character buffer during </font><font face="Courier">underflow()</font><font face="">
or </font><font face="Courier">uflow()</font><font face=""> is taken from
successive locations on the external file starting at the current external
file position. Where the external file position indicator stands depends
on the circumstances.</font></font>
<p><font size=-1><font face="">&nbsp;Immediately after a file stream buffer
is connected to an external file (via </font><font face="Courier">open()</font><font face="">),
the file position indicator is either at the beginning of the file, which
is the default situation, or at the end of the file, if the open mode included
the at-end flag.</font></font>
<p><font size=-1><font face="">&nbsp;After preceding input operations (via
</font><font face="Courier">sgetc()</font><font face="">,
</font><font face="Courier">sbumpc()</font><font face="">),
the external file position indicator stands where the last input operation
left it.</font></font>
<p><font size=-1><font face="">&nbsp;After an explicit repositioning of
the stream position (via </font><font face="Courier">seekoff()</font><font face="">
, </font><font face="Courier">seekpos()</font><font face="">), the external
file position indicator is reset to a corresponding position in the external
file.</font></font>
<p><font face=""><font size=-1>&nbsp;<b>SWITCHING BETWEEN INPUT AND OUTPUT</b></font></font>
<br><font face=""><font size=-1>On bidirectional file streams, input <i>and</i>
output operations are allowed, and for this reason, a bidirectional file
stream uses its file stream buffer's put <i>and</i> get areas. Switching
between input and output operations must obey certain rules, which are
described in section 1.4.3, Bidirectional File Streams. A brief recap:</font></font>
<br>&nbsp;
<br>&nbsp;
<blockquote><font face=""><font size=-1>After output, the file stream must
be flushed or repositioned before any input is permitted.</font></font>
<p><font face=""><font size=-1>&nbsp;After input, the file stream must
be repositioned before any output is allowed, unless the preceding input
operations have reached end-of-file, in which case output can immediately
follow input.</font></font>
<br>&nbsp;
<br>&nbsp;</blockquote>
<font face=""><font size=-1>In our example, where the file stream buffer
has only one internal character array, which represents either the put
or the get area, the file stream buffer must exchange the get and put areas
with every switch between input and output operations. Again, the following
explanations are based on our sample implementation; your particular implementation
might work differently.</font></font>
<p><font face=""><font size=-1>&nbsp;<b>SWITCHING FROM OUTPUT TO INPUT</b></font></font>
<br><font face=""><font size=-1>Let us assume that the last operation on
the file stream buffer was an output operation, in which case the put area
is active and the get area is inactive. An example is shown in figure 2-21.</font></font>
<p><img SRC="fig02-21.jpg" ALT="Figure 2-21" BORDER=0 height=231 width=521>
<br><i><font face=""><font size=-1><b>Figure 2-21:</b> File stream buffer
after an output operation.</font></font></i>
<p><font face=""><font size=-1>&nbsp;Before any input operation can follow,
the file stream must be flushed or repositioned, due to the rules for file
stream operations. Both operations trigger the file stream buffer to transfer
the content of its internal character buffer to the external file. After
this transfer, the file stream buffer is in its neutral state again, that
is, both areas are inactive, as shown in figure 2-22.</font></font>
<p><img SRC="fig02-22.jpg" ALT="Figure 2-22" BORDER=0 height=231 width=521>
<br><i><font face=""><font size=-1><b>Figure 2-22:</b> File stream buffer
in neutral state after flush or repositioning.</font></font></i>
<p><font face=""><font size=-1>&nbsp;If the requested operation was a request
for repositioning, the file stream buffer not only transfers the content
of the internal buffer to the external file but also resets the file position
indicator of the external file as requested. Resetting the external file
position indicator only affects the external file but has no direct effect
on the get or put areas.</font></font>
<p><font size=-1><font face="">&nbsp;An input operation following the flush
or repositioning works as described earlier for input in general: The get
area is not available. As a result, </font><font face="Courier">underflow()</font><font face="">
or </font><font face="Courier">uflow()</font><font face=""> is called,
characters are transferred from the external file to the internal character
buffer, and the get area's pointers are adjusted accordingly. The character
sequence transferred from the external file starts at the current external
file position. Depending on whether the preceding operation was a flush
or a repositioning, the external file position is either the last write
position or the position to which the file position indicator was repositioned.
Figure 2-23 shows the situation after a successful input operation.</font></font>
<p><img SRC="fig02-23.jpg" ALT="Figure 2-23" BORDER=0 height=231 width=521>
<br><i><font face=""><font size=-1><b>Figure 2-23:</b> File stream buffer
after an input operation.</font></font></i>
<p><font face=""><font size=-1>&nbsp;<b>SWITCHING FROM INPUT TO OUTPUT</b></font></font>
<br><font face=""><font size=-1>After this input operation, the get area
is active and the put area is inactive. The situation is exactly as shown
in figure 2-23. An output operation can follow only if the input operation
reached the end of the file. Otherwise, before any output operation can
follow, the file stream must be repositioned.</font></font>
<p><font face=""><font size=-1>&nbsp;Reaching the end of the file during
input puts the file stream buffer into its neutral state, because the entire
file content has been consumed, and further input is not possible without
any intervening output or repositioning. For that reason, the content of
the internal character buffer can be discarded and both areas deactivated.
As
expected, the file position indicator of the external file stands at the
end of the external file in this case.</font></font>
<p><font face=""><font size=-1>&nbsp;Repositioning, too, involves the file
stream buffer's discarding the content of its internal character buffer
and putting itself into the neutral state, in which both areas are inactive.
The file position indicator of the external file is reset accordingly,
which affects only the external file but has no immediate effect on the
get or put areas.</font></font>
<p><font face=""><font size=-1>&nbsp;No matter whether the file stream
is repositioned or whether the preceding input operation has reached the
end of the file, the file stream buffer is put into its neutral state,
as shown in figure 2-24.</font></font>
<p><img SRC="fig02-24.jpg" ALT="Figure 2-24" BORDER=0 height=231 width=521>
<br><i><font face=""><font size=-1><b>Figure 2-24:</b> File stream buffer
in neutral state after repositioning or reaching end of file during input.</font></font></i>
<p><font size=-1><font face="">&nbsp;An output operation in this situation
works as described earlier for output in general: First, </font><font face="Courier">overflow()</font><font face="">
is invoked, which activates the put area. Then the respective character
sequence that was passed to the output operation is stored in the internal
buffer area, and the put area's pointers are adjusted. Figure 2-25 shows
the situation after successful output of </font><font face="Courier">Hello
World\n</font><font face="">.</font></font>
<p><img SRC="fig02-25.jpg" ALT="Figure 2-25" BORDER=0 height=231 width=521>
<br><i><font face=""><font size=-1><b>Figure 2-25:</b> File stream buffer
after an output operation.</font></font></i>
<p><font face=""><font size=-1>&nbsp;<b>DISCLAIMER.</b> The explanations
given above regarding the management of a file stream buffer's put and
get areas are not to be taken literally. An implementation is free to achieve
the same effect in a different way. In particular, the neutral state can
be expressed in a different way, but it always exists logically. The neutral
state serves as the initial state of a file stream buffer, but it is also
logically reached when input operations hit the end of the file or when
the stream position is reset. A file stream buffer may also put itself
into the neutral state for other reasons, such as error situations. How
the neutral state is expressed or how exactly an implementation of a file
stream buffer uses its internal character buffer(s) to represent the put
and get areas is an implementation detail left open by the standard.</font></font>
<p><font face=""><font size=-1>&nbsp;<b>PUTBACK</b></font></font>
<br><font size=-1><font face="">Putting back characters to the input sequence
via </font><font face="Courier">sungetc()</font><font face=""> or </font><font face="Courier">sputbackc()</font><font face="">
can be successful only following preceding input operations. Let us consider
such a situation. As a result of the preceding input operations, the get
area is active, and the file stream buffer might look like the one shown
in figure 2-26.</font></font>
<p><img SRC="fig02-26.jpg" ALT="Figure 2-26" BORDER=0 height=231 width=521>
<br><i><font face=""><font size=-1><b>Figure 2-26:</b> File stream buffer
after an input operation.</font></font></i>
<p><font size=-1><font face="">&nbsp;Putting back the previously read character
means decrementing the get area's next_pointer. Putting back a character
different from the previously read one means decrementing the get area's
next_pointer and storing the different character at that location in the
internal character buffer. </font><font face="Courier">pbackfail()</font><font face="">
is responsible for this write access to the get area. The write access
will be rejected if the file stream buffer is not connected to an open
file. Figure 2-27 shows the situation after three previously read characters
have successfully been put back.</font></font>
<p><img SRC="fig02-27.jpg" ALT="Figure 2-27" BORDER=0 height=231 width=521>
<br><i><font face=""><font size=-1><b>Figure 2-27:</b> File stream buffer
after some putback operations.</font></font></i>
<p><font size=-1><font face="">&nbsp;If we keep on putting back characters,
we will eventually hit the begin_pointer. Then the next_pointer cannot
be decreased any further, and </font><font face="Courier">pbackfail()</font><font face="">
is triggered in order to make further putback positions available. What
</font><font face="Courier">pbackfail()</font><font face="">
does in such a situation is implementation-dependent. In our example, the
attempt to put back any further characters will fail, because we consider
it unusual that a large number of characters is put back into the input
sequence, and for that reason we do not support it. Alternatively, a file
buffer implementation could make additional putback positions available
by extracting previously read characters from the external file, if the
underlying file system allows that.</font></font>
<p><font face=""><font size=-1>&nbsp;Let us discuss another situation.
After successive input operations, the get area's next_pointer will eventually
hit the end_pointer. Figure 2-28 shows a situation in which the get area
is entirely consumed.</font></font>
<p><img SRC="fig02-28.jpg" ALT="Figure 2-28" BORDER=0 height=231 width=521>
<br><i><font face=""><font size=-1><b>Figure 2-28:</b> File stream buffer
with consumed get area.</font></font></i>
<p><font size=-1><font face="">&nbsp;The next input operation triggers
</font><font face="Courier">underflow()</font><font face="">
or </font><font face="Courier">uflow()</font><font face="">, which then
refills the internal buffer from the external file. In order to allow putback
of characters even immediately after </font><font face="Courier">underflow()</font><font face="">
or </font><font face="Courier">uflow()</font><font face=""> , we can keep
the first four positions in the internal character buffer reserved as putback
positions in our sample implementation. The number of putback positions
a file stream buffer reserves, if any, is implementation defined. In our
sample implementation, </font><font face="Courier">underflow()</font><font face="">
or </font><font face="Courier">uflow()</font><font face=""> copies the
last four characters of the consumed get area to the first four locations
of the internal character buffer before they fill the rest of the internal
buffer with characters transferred from the external file. Figure 2-29
shows the file stream buffer after invocation of </font><font face="Courier">underflow()</font><font face="">
.</font></font>
<p><img SRC="fig02-29.jpg" ALT="Figure 2-29" BORDER=0 height=231 width=521>
<br><font size=-1><i><font face=""><b>Figure 2-29:</b> File stream buffer
after </font></i><font face="Courier">overflow()</font><font face=""> ,
<i>showing
the reserved putback positions.</i></font></font>
<p><font face=""><font size=-1>&nbsp;Now it is possible to put back four
characters into the get area even if it has just been refilled from the
external sequence.</font></font>
<p><font face=""><font size=-1>&nbsp;In general, putting back characters
is possible only if the get area is active, which means that for bidirectional
file streams putback cannot immediately follow an output operation. The
same rules as for input following output apply, that is, the file stream
must be flushed or repositioned before any characters can be put back into
the input sequence after an output operation.</font></font>
<p><font face=""><font size=-1>&nbsp;If an output operation is performed
after putting characters back into the input sequence, the entire get area,
including the putback positions, is discarded to make room for the put
area. As a result, any changes made to the putback positions are lost.</font></font>
<p><font face=""><font size=-1>&nbsp;<b>ACKNOWLEDGMENTS</b></font></font>
<br><font face=""><font size=-1>This article is excerpted from the new
book <i>Standard C++ IOStreams and Locales</i> by Angelika Langer and Klaus
Kreft, &copy; 2000 Addison Wesley Longman Inc., which contains further
detailed treatments of points touched on briefly in this article, including
formatted and unformatted I/O using iostreams, internationalization using
locales and standard facets, techniques for user-defined I/O operations,
special-purpose streams and stream buffers and user-defined facets. For
the complete table of contents see <a href="http://www.awl.com/cseng/titles/0-201-18395-1/">http://www.awl.com/cseng/titles/0-201-18395-1/</a>
.</font></font>
<p><font face=""><font size=-1>&nbsp;<b>FOOTNOTES</b></font></font>
<br><a NAME="1"></a><font face=""><font size=-1><sup>1</sup> The list of
stream buffer operations is not meant to be complete. Only the most important
and typical functions are listed. For a complete description of the stream
buffer base class's interface, see the reference section. Also, section
3.4, Adding Stream Buffer Functionality, provides more details on the protected
interface.</font></font>
<p><a NAME="2"></a><font face=""><font size=-1><sup>2</sup> Section 2.2.3,
String Stream Buffers, explains in greater detail why this is.</font></font>
<p><a NAME="3"></a><font size=-1><font face=""><sup>3</sup> The adjustment
of the get area's end pointer might alternatively be deferred to the next
input operations and would then be performed during </font><font face="Courier">underflow()</font><font face="">.</font></font>
<p><a NAME="4"></a><font face=""><font size=-1><sup>4</sup> Details of
a typical implementation are described in section 2.2.4, File Stream Buffers.</font></font>
<p><a NAME="5"></a><font face=""><font size=-1><sup>5</sup> Positions in
the internal sequence are overwritten only if the stream buffer's open
mode allows it. A stream buffer whose open mode does not include output
mode will not allow any write access to the internal sequence.</font></font>
<p><a NAME="6"></a><font face=""><font size=-1><sup>6</sup> Only in rare
situations, when the file size is less than or equal to the buffer size,
can the internal buffer hold the whole file.</font></font>
<p><a NAME="7"></a><font face=""><font size=-1><sup>7</sup> Whether the
initial neutral state exists in practice is implementation defined. An
implementation can also activate the get area right away and fill it with
characters transferred from the external file before any actual input request.</font></font>
<br>&nbsp;
</body>
</html>
